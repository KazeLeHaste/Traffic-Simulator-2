/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./css/dark-theme.css":
/*!****************************!*\
  !*** ./css/dark-theme.css ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_dark_theme_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js!./dark-theme.css */ "./node_modules/css-loader/dist/cjs.js!./css/dark-theme.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());
options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_dark_theme_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_dark_theme_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_dark_theme_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_dark_theme_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./css/dat-gui.css":
/*!*************************!*\
  !*** ./css/dat-gui.css ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_dat_gui_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js!./dat-gui.css */ "./node_modules/css-loader/dist/cjs.js!./css/dat-gui.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());
options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_dat_gui_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_dat_gui_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_dat_gui_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_dat_gui_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./css/kpi-visualization.css":
/*!***********************************!*\
  !*** ./css/kpi-visualization.css ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_kpi_visualization_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js!./kpi-visualization.css */ "./node_modules/css-loader/dist/cjs.js!./css/kpi-visualization.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());
options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_kpi_visualization_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_kpi_visualization_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_kpi_visualization_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_kpi_visualization_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./css/style.css":
/*!***********************!*\
  !*** ./css/style.css ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js!./style.css */ "./node_modules/css-loader/dist/cjs.js!./css/style.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());
options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./node_modules/@kurkle/color/dist/color.cjs":
/*!***************************************************!*\
  !*** ./node_modules/@kurkle/color/dist/color.cjs ***!
  \***************************************************/
/***/ (function(module) {

/*!
 * @kurkle/color v0.3.4
 * https://github.com/kurkle/color#readme
 * (c) 2024 Jukka Kurkela
 * Released under the MIT License
 */
(function (global, factory) {
 true ? module.exports = factory() :
0;
})(this, (function () { 'use strict';

function round(v) {
  return v + 0.5 | 0;
}
const lim = (v, l, h) => Math.max(Math.min(v, h), l);
function p2b(v) {
  return lim(round(v * 2.55), 0, 255);
}
function b2p(v) {
  return lim(round(v / 2.55), 0, 100);
}
function n2b(v) {
  return lim(round(v * 255), 0, 255);
}
function b2n(v) {
  return lim(round(v / 2.55) / 100, 0, 1);
}
function n2p(v) {
  return lim(round(v * 100), 0, 100);
}

const map$1 = {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15};
const hex = [...'0123456789ABCDEF'];
const h1 = b => hex[b & 0xF];
const h2 = b => hex[(b & 0xF0) >> 4] + hex[b & 0xF];
const eq = b => ((b & 0xF0) >> 4) === (b & 0xF);
const isShort = v => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
function hexParse(str) {
  var len = str.length;
  var ret;
  if (str[0] === '#') {
    if (len === 4 || len === 5) {
      ret = {
        r: 255 & map$1[str[1]] * 17,
        g: 255 & map$1[str[2]] * 17,
        b: 255 & map$1[str[3]] * 17,
        a: len === 5 ? map$1[str[4]] * 17 : 255
      };
    } else if (len === 7 || len === 9) {
      ret = {
        r: map$1[str[1]] << 4 | map$1[str[2]],
        g: map$1[str[3]] << 4 | map$1[str[4]],
        b: map$1[str[5]] << 4 | map$1[str[6]],
        a: len === 9 ? (map$1[str[7]] << 4 | map$1[str[8]]) : 255
      };
    }
  }
  return ret;
}
const alpha = (a, f) => a < 255 ? f(a) : '';
function hexString(v) {
  var f = isShort(v) ? h1 : h2;
  return v
    ? '#' + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f)
    : undefined;
}

const HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function hsl2rgbn(h, s, l) {
  const a = s * Math.min(l, 1 - l);
  const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
  return [f(0), f(8), f(4)];
}
function hsv2rgbn(h, s, v) {
  const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
  return [f(5), f(3), f(1)];
}
function hwb2rgbn(h, w, b) {
  const rgb = hsl2rgbn(h, 1, 0.5);
  let i;
  if (w + b > 1) {
    i = 1 / (w + b);
    w *= i;
    b *= i;
  }
  for (i = 0; i < 3; i++) {
    rgb[i] *= 1 - w - b;
    rgb[i] += w;
  }
  return rgb;
}
function hueValue(r, g, b, d, max) {
  if (r === max) {
    return ((g - b) / d) + (g < b ? 6 : 0);
  }
  if (g === max) {
    return (b - r) / d + 2;
  }
  return (r - g) / d + 4;
}
function rgb2hsl(v) {
  const range = 255;
  const r = v.r / range;
  const g = v.g / range;
  const b = v.b / range;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const l = (max + min) / 2;
  let h, s, d;
  if (max !== min) {
    d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    h = hueValue(r, g, b, d, max);
    h = h * 60 + 0.5;
  }
  return [h | 0, s || 0, l];
}
function calln(f, a, b, c) {
  return (
    Array.isArray(a)
      ? f(a[0], a[1], a[2])
      : f(a, b, c)
  ).map(n2b);
}
function hsl2rgb(h, s, l) {
  return calln(hsl2rgbn, h, s, l);
}
function hwb2rgb(h, w, b) {
  return calln(hwb2rgbn, h, w, b);
}
function hsv2rgb(h, s, v) {
  return calln(hsv2rgbn, h, s, v);
}
function hue(h) {
  return (h % 360 + 360) % 360;
}
function hueParse(str) {
  const m = HUE_RE.exec(str);
  let a = 255;
  let v;
  if (!m) {
    return;
  }
  if (m[5] !== v) {
    a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
  }
  const h = hue(+m[2]);
  const p1 = +m[3] / 100;
  const p2 = +m[4] / 100;
  if (m[1] === 'hwb') {
    v = hwb2rgb(h, p1, p2);
  } else if (m[1] === 'hsv') {
    v = hsv2rgb(h, p1, p2);
  } else {
    v = hsl2rgb(h, p1, p2);
  }
  return {
    r: v[0],
    g: v[1],
    b: v[2],
    a: a
  };
}
function rotate(v, deg) {
  var h = rgb2hsl(v);
  h[0] = hue(h[0] + deg);
  h = hsl2rgb(h);
  v.r = h[0];
  v.g = h[1];
  v.b = h[2];
}
function hslString(v) {
  if (!v) {
    return;
  }
  const a = rgb2hsl(v);
  const h = a[0];
  const s = n2p(a[1]);
  const l = n2p(a[2]);
  return v.a < 255
    ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})`
    : `hsl(${h}, ${s}%, ${l}%)`;
}

const map = {
	x: 'dark',
	Z: 'light',
	Y: 're',
	X: 'blu',
	W: 'gr',
	V: 'medium',
	U: 'slate',
	A: 'ee',
	T: 'ol',
	S: 'or',
	B: 'ra',
	C: 'lateg',
	D: 'ights',
	R: 'in',
	Q: 'turquois',
	E: 'hi',
	P: 'ro',
	O: 'al',
	N: 'le',
	M: 'de',
	L: 'yello',
	F: 'en',
	K: 'ch',
	G: 'arks',
	H: 'ea',
	I: 'ightg',
	J: 'wh'
};
const names$1 = {
	OiceXe: 'f0f8ff',
	antiquewEte: 'faebd7',
	aqua: 'ffff',
	aquamarRe: '7fffd4',
	azuY: 'f0ffff',
	beige: 'f5f5dc',
	bisque: 'ffe4c4',
	black: '0',
	blanKedOmond: 'ffebcd',
	Xe: 'ff',
	XeviTet: '8a2be2',
	bPwn: 'a52a2a',
	burlywood: 'deb887',
	caMtXe: '5f9ea0',
	KartYuse: '7fff00',
	KocTate: 'd2691e',
	cSO: 'ff7f50',
	cSnflowerXe: '6495ed',
	cSnsilk: 'fff8dc',
	crimson: 'dc143c',
	cyan: 'ffff',
	xXe: '8b',
	xcyan: '8b8b',
	xgTMnPd: 'b8860b',
	xWay: 'a9a9a9',
	xgYF: '6400',
	xgYy: 'a9a9a9',
	xkhaki: 'bdb76b',
	xmagFta: '8b008b',
	xTivegYF: '556b2f',
	xSange: 'ff8c00',
	xScEd: '9932cc',
	xYd: '8b0000',
	xsOmon: 'e9967a',
	xsHgYF: '8fbc8f',
	xUXe: '483d8b',
	xUWay: '2f4f4f',
	xUgYy: '2f4f4f',
	xQe: 'ced1',
	xviTet: '9400d3',
	dAppRk: 'ff1493',
	dApskyXe: 'bfff',
	dimWay: '696969',
	dimgYy: '696969',
	dodgerXe: '1e90ff',
	fiYbrick: 'b22222',
	flSOwEte: 'fffaf0',
	foYstWAn: '228b22',
	fuKsia: 'ff00ff',
	gaRsbSo: 'dcdcdc',
	ghostwEte: 'f8f8ff',
	gTd: 'ffd700',
	gTMnPd: 'daa520',
	Way: '808080',
	gYF: '8000',
	gYFLw: 'adff2f',
	gYy: '808080',
	honeyMw: 'f0fff0',
	hotpRk: 'ff69b4',
	RdianYd: 'cd5c5c',
	Rdigo: '4b0082',
	ivSy: 'fffff0',
	khaki: 'f0e68c',
	lavFMr: 'e6e6fa',
	lavFMrXsh: 'fff0f5',
	lawngYF: '7cfc00',
	NmoncEffon: 'fffacd',
	ZXe: 'add8e6',
	ZcSO: 'f08080',
	Zcyan: 'e0ffff',
	ZgTMnPdLw: 'fafad2',
	ZWay: 'd3d3d3',
	ZgYF: '90ee90',
	ZgYy: 'd3d3d3',
	ZpRk: 'ffb6c1',
	ZsOmon: 'ffa07a',
	ZsHgYF: '20b2aa',
	ZskyXe: '87cefa',
	ZUWay: '778899',
	ZUgYy: '778899',
	ZstAlXe: 'b0c4de',
	ZLw: 'ffffe0',
	lime: 'ff00',
	limegYF: '32cd32',
	lRF: 'faf0e6',
	magFta: 'ff00ff',
	maPon: '800000',
	VaquamarRe: '66cdaa',
	VXe: 'cd',
	VScEd: 'ba55d3',
	VpurpN: '9370db',
	VsHgYF: '3cb371',
	VUXe: '7b68ee',
	VsprRggYF: 'fa9a',
	VQe: '48d1cc',
	VviTetYd: 'c71585',
	midnightXe: '191970',
	mRtcYam: 'f5fffa',
	mistyPse: 'ffe4e1',
	moccasR: 'ffe4b5',
	navajowEte: 'ffdead',
	navy: '80',
	Tdlace: 'fdf5e6',
	Tive: '808000',
	TivedBb: '6b8e23',
	Sange: 'ffa500',
	SangeYd: 'ff4500',
	ScEd: 'da70d6',
	pOegTMnPd: 'eee8aa',
	pOegYF: '98fb98',
	pOeQe: 'afeeee',
	pOeviTetYd: 'db7093',
	papayawEp: 'ffefd5',
	pHKpuff: 'ffdab9',
	peru: 'cd853f',
	pRk: 'ffc0cb',
	plum: 'dda0dd',
	powMrXe: 'b0e0e6',
	purpN: '800080',
	YbeccapurpN: '663399',
	Yd: 'ff0000',
	Psybrown: 'bc8f8f',
	PyOXe: '4169e1',
	saddNbPwn: '8b4513',
	sOmon: 'fa8072',
	sandybPwn: 'f4a460',
	sHgYF: '2e8b57',
	sHshell: 'fff5ee',
	siFna: 'a0522d',
	silver: 'c0c0c0',
	skyXe: '87ceeb',
	UXe: '6a5acd',
	UWay: '708090',
	UgYy: '708090',
	snow: 'fffafa',
	sprRggYF: 'ff7f',
	stAlXe: '4682b4',
	tan: 'd2b48c',
	teO: '8080',
	tEstN: 'd8bfd8',
	tomato: 'ff6347',
	Qe: '40e0d0',
	viTet: 'ee82ee',
	JHt: 'f5deb3',
	wEte: 'ffffff',
	wEtesmoke: 'f5f5f5',
	Lw: 'ffff00',
	LwgYF: '9acd32'
};
function unpack() {
  const unpacked = {};
  const keys = Object.keys(names$1);
  const tkeys = Object.keys(map);
  let i, j, k, ok, nk;
  for (i = 0; i < keys.length; i++) {
    ok = nk = keys[i];
    for (j = 0; j < tkeys.length; j++) {
      k = tkeys[j];
      nk = nk.replace(k, map[k]);
    }
    k = parseInt(names$1[ok], 16);
    unpacked[nk] = [k >> 16 & 0xFF, k >> 8 & 0xFF, k & 0xFF];
  }
  return unpacked;
}

let names;
function nameParse(str) {
  if (!names) {
    names = unpack();
    names.transparent = [0, 0, 0, 0];
  }
  const a = names[str.toLowerCase()];
  return a && {
    r: a[0],
    g: a[1],
    b: a[2],
    a: a.length === 4 ? a[3] : 255
  };
}

const RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function rgbParse(str) {
  const m = RGB_RE.exec(str);
  let a = 255;
  let r, g, b;
  if (!m) {
    return;
  }
  if (m[7] !== r) {
    const v = +m[7];
    a = m[8] ? p2b(v) : lim(v * 255, 0, 255);
  }
  r = +m[1];
  g = +m[3];
  b = +m[5];
  r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));
  g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));
  b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));
  return {
    r: r,
    g: g,
    b: b,
    a: a
  };
}
function rgbString(v) {
  return v && (
    v.a < 255
      ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})`
      : `rgb(${v.r}, ${v.g}, ${v.b})`
  );
}

const to = v => v <= 0.0031308 ? v * 12.92 : Math.pow(v, 1.0 / 2.4) * 1.055 - 0.055;
const from = v => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
function interpolate(rgb1, rgb2, t) {
  const r = from(b2n(rgb1.r));
  const g = from(b2n(rgb1.g));
  const b = from(b2n(rgb1.b));
  return {
    r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),
    g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),
    b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),
    a: rgb1.a + t * (rgb2.a - rgb1.a)
  };
}

function modHSL(v, i, ratio) {
  if (v) {
    let tmp = rgb2hsl(v);
    tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
    tmp = hsl2rgb(tmp);
    v.r = tmp[0];
    v.g = tmp[1];
    v.b = tmp[2];
  }
}
function clone(v, proto) {
  return v ? Object.assign(proto || {}, v) : v;
}
function fromObject(input) {
  var v = {r: 0, g: 0, b: 0, a: 255};
  if (Array.isArray(input)) {
    if (input.length >= 3) {
      v = {r: input[0], g: input[1], b: input[2], a: 255};
      if (input.length > 3) {
        v.a = n2b(input[3]);
      }
    }
  } else {
    v = clone(input, {r: 0, g: 0, b: 0, a: 1});
    v.a = n2b(v.a);
  }
  return v;
}
function functionParse(str) {
  if (str.charAt(0) === 'r') {
    return rgbParse(str);
  }
  return hueParse(str);
}
class Color {
  constructor(input) {
    if (input instanceof Color) {
      return input;
    }
    const type = typeof input;
    let v;
    if (type === 'object') {
      v = fromObject(input);
    } else if (type === 'string') {
      v = hexParse(input) || nameParse(input) || functionParse(input);
    }
    this._rgb = v;
    this._valid = !!v;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var v = clone(this._rgb);
    if (v) {
      v.a = b2n(v.a);
    }
    return v;
  }
  set rgb(obj) {
    this._rgb = fromObject(obj);
  }
  rgbString() {
    return this._valid ? rgbString(this._rgb) : undefined;
  }
  hexString() {
    return this._valid ? hexString(this._rgb) : undefined;
  }
  hslString() {
    return this._valid ? hslString(this._rgb) : undefined;
  }
  mix(color, weight) {
    if (color) {
      const c1 = this.rgb;
      const c2 = color.rgb;
      let w2;
      const p = weight === w2 ? 0.5 : weight;
      const w = 2 * p - 1;
      const a = c1.a - c2.a;
      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
      w2 = 1 - w1;
      c1.r = 0xFF & w1 * c1.r + w2 * c2.r + 0.5;
      c1.g = 0xFF & w1 * c1.g + w2 * c2.g + 0.5;
      c1.b = 0xFF & w1 * c1.b + w2 * c2.b + 0.5;
      c1.a = p * c1.a + (1 - p) * c2.a;
      this.rgb = c1;
    }
    return this;
  }
  interpolate(color, t) {
    if (color) {
      this._rgb = interpolate(this._rgb, color._rgb, t);
    }
    return this;
  }
  clone() {
    return new Color(this.rgb);
  }
  alpha(a) {
    this._rgb.a = n2b(a);
    return this;
  }
  clearer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 - ratio;
    return this;
  }
  greyscale() {
    const rgb = this._rgb;
    const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
    rgb.r = rgb.g = rgb.b = val;
    return this;
  }
  opaquer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 + ratio;
    return this;
  }
  negate() {
    const v = this._rgb;
    v.r = 255 - v.r;
    v.g = 255 - v.g;
    v.b = 255 - v.b;
    return this;
  }
  lighten(ratio) {
    modHSL(this._rgb, 2, ratio);
    return this;
  }
  darken(ratio) {
    modHSL(this._rgb, 2, -ratio);
    return this;
  }
  saturate(ratio) {
    modHSL(this._rgb, 1, ratio);
    return this;
  }
  desaturate(ratio) {
    modHSL(this._rgb, 1, -ratio);
    return this;
  }
  rotate(deg) {
    rotate(this._rgb, deg);
    return this;
  }
}

function index_esm(input) {
  return new Color(input);
}

var color = /*#__PURE__*/Object.freeze({
__proto__: null,
Color: Color,
b2n: b2n,
b2p: b2p,
default: index_esm,
hexParse: hexParse,
hexString: hexString,
hsl2rgb: hsl2rgb,
hslString: hslString,
hsv2rgb: hsv2rgb,
hueParse: hueParse,
hwb2rgb: hwb2rgb,
lim: lim,
n2b: n2b,
n2p: n2p,
nameParse: nameParse,
p2b: p2b,
rgb2hsl: rgb2hsl,
rgbParse: rgbParse,
rgbString: rgbString,
rotate: rotate,
round: round
});

var index = Object.assign(index_esm, color);

return index;

}));


/***/ }),

/***/ "./node_modules/chart.js/auto/auto.cjs":
/*!*********************************************!*\
  !*** ./node_modules/chart.js/auto/auto.cjs ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const chartjs = __webpack_require__(/*! ../dist/chart.cjs */ "./node_modules/chart.js/dist/chart.cjs");
const {Chart, registerables} = chartjs;

Chart.register(...registerables);

module.exports = Object.assign(Chart, chartjs);


/***/ }),

/***/ "./node_modules/chart.js/dist/chart.cjs":
/*!**********************************************!*\
  !*** ./node_modules/chart.js/dist/chart.cjs ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*!
 * Chart.js v4.5.0
 * https://www.chartjs.org
 * (c) 2025 Chart.js Contributors
 * Released under the MIT License
 */


var helpers_dataset = __webpack_require__(/*! ./chunks/helpers.dataset.cjs */ "./node_modules/chart.js/dist/chunks/helpers.dataset.cjs");
__webpack_require__(/*! @kurkle/color */ "./node_modules/@kurkle/color/dist/color.cjs");

class Animator {
    constructor(){
        this._request = null;
        this._charts = new Map();
        this._running = false;
        this._lastDate = undefined;
    }
 _notify(chart, anims, date, type) {
        const callbacks = anims.listeners[type];
        const numSteps = anims.duration;
        callbacks.forEach((fn)=>fn({
                chart,
                initial: anims.initial,
                numSteps,
                currentStep: Math.min(date - anims.start, numSteps)
            }));
    }
 _refresh() {
        if (this._request) {
            return;
        }
        this._running = true;
        this._request = helpers_dataset.requestAnimFrame.call(window, ()=>{
            this._update();
            this._request = null;
            if (this._running) {
                this._refresh();
            }
        });
    }
 _update(date = Date.now()) {
        let remaining = 0;
        this._charts.forEach((anims, chart)=>{
            if (!anims.running || !anims.items.length) {
                return;
            }
            const items = anims.items;
            let i = items.length - 1;
            let draw = false;
            let item;
            for(; i >= 0; --i){
                item = items[i];
                if (item._active) {
                    if (item._total > anims.duration) {
                        anims.duration = item._total;
                    }
                    item.tick(date);
                    draw = true;
                } else {
                    items[i] = items[items.length - 1];
                    items.pop();
                }
            }
            if (draw) {
                chart.draw();
                this._notify(chart, anims, date, 'progress');
            }
            if (!items.length) {
                anims.running = false;
                this._notify(chart, anims, date, 'complete');
                anims.initial = false;
            }
            remaining += items.length;
        });
        this._lastDate = date;
        if (remaining === 0) {
            this._running = false;
        }
    }
 _getAnims(chart) {
        const charts = this._charts;
        let anims = charts.get(chart);
        if (!anims) {
            anims = {
                running: false,
                initial: true,
                items: [],
                listeners: {
                    complete: [],
                    progress: []
                }
            };
            charts.set(chart, anims);
        }
        return anims;
    }
 listen(chart, event, cb) {
        this._getAnims(chart).listeners[event].push(cb);
    }
 add(chart, items) {
        if (!items || !items.length) {
            return;
        }
        this._getAnims(chart).items.push(...items);
    }
 has(chart) {
        return this._getAnims(chart).items.length > 0;
    }
 start(chart) {
        const anims = this._charts.get(chart);
        if (!anims) {
            return;
        }
        anims.running = true;
        anims.start = Date.now();
        anims.duration = anims.items.reduce((acc, cur)=>Math.max(acc, cur._duration), 0);
        this._refresh();
    }
    running(chart) {
        if (!this._running) {
            return false;
        }
        const anims = this._charts.get(chart);
        if (!anims || !anims.running || !anims.items.length) {
            return false;
        }
        return true;
    }
 stop(chart) {
        const anims = this._charts.get(chart);
        if (!anims || !anims.items.length) {
            return;
        }
        const items = anims.items;
        let i = items.length - 1;
        for(; i >= 0; --i){
            items[i].cancel();
        }
        anims.items = [];
        this._notify(chart, anims, Date.now(), 'complete');
    }
 remove(chart) {
        return this._charts.delete(chart);
    }
}
var animator = /* #__PURE__ */ new Animator();

const transparent = 'transparent';
const interpolators = {
    boolean (from, to, factor) {
        return factor > 0.5 ? to : from;
    },
 color (from, to, factor) {
        const c0 = helpers_dataset.color(from || transparent);
        const c1 = c0.valid && helpers_dataset.color(to || transparent);
        return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to;
    },
    number (from, to, factor) {
        return from + (to - from) * factor;
    }
};
class Animation {
    constructor(cfg, target, prop, to){
        const currentValue = target[prop];
        to = helpers_dataset.resolve([
            cfg.to,
            to,
            currentValue,
            cfg.from
        ]);
        const from = helpers_dataset.resolve([
            cfg.from,
            currentValue,
            to
        ]);
        this._active = true;
        this._fn = cfg.fn || interpolators[cfg.type || typeof from];
        this._easing = helpers_dataset.effects[cfg.easing] || helpers_dataset.effects.linear;
        this._start = Math.floor(Date.now() + (cfg.delay || 0));
        this._duration = this._total = Math.floor(cfg.duration);
        this._loop = !!cfg.loop;
        this._target = target;
        this._prop = prop;
        this._from = from;
        this._to = to;
        this._promises = undefined;
    }
    active() {
        return this._active;
    }
    update(cfg, to, date) {
        if (this._active) {
            this._notify(false);
            const currentValue = this._target[this._prop];
            const elapsed = date - this._start;
            const remain = this._duration - elapsed;
            this._start = date;
            this._duration = Math.floor(Math.max(remain, cfg.duration));
            this._total += elapsed;
            this._loop = !!cfg.loop;
            this._to = helpers_dataset.resolve([
                cfg.to,
                to,
                currentValue,
                cfg.from
            ]);
            this._from = helpers_dataset.resolve([
                cfg.from,
                currentValue,
                to
            ]);
        }
    }
    cancel() {
        if (this._active) {
            this.tick(Date.now());
            this._active = false;
            this._notify(false);
        }
    }
    tick(date) {
        const elapsed = date - this._start;
        const duration = this._duration;
        const prop = this._prop;
        const from = this._from;
        const loop = this._loop;
        const to = this._to;
        let factor;
        this._active = from !== to && (loop || elapsed < duration);
        if (!this._active) {
            this._target[prop] = to;
            this._notify(true);
            return;
        }
        if (elapsed < 0) {
            this._target[prop] = from;
            return;
        }
        factor = elapsed / duration % 2;
        factor = loop && factor > 1 ? 2 - factor : factor;
        factor = this._easing(Math.min(1, Math.max(0, factor)));
        this._target[prop] = this._fn(from, to, factor);
    }
    wait() {
        const promises = this._promises || (this._promises = []);
        return new Promise((res, rej)=>{
            promises.push({
                res,
                rej
            });
        });
    }
    _notify(resolved) {
        const method = resolved ? 'res' : 'rej';
        const promises = this._promises || [];
        for(let i = 0; i < promises.length; i++){
            promises[i][method]();
        }
    }
}

class Animations {
    constructor(chart, config){
        this._chart = chart;
        this._properties = new Map();
        this.configure(config);
    }
    configure(config) {
        if (!helpers_dataset.isObject(config)) {
            return;
        }
        const animationOptions = Object.keys(helpers_dataset.defaults.animation);
        const animatedProps = this._properties;
        Object.getOwnPropertyNames(config).forEach((key)=>{
            const cfg = config[key];
            if (!helpers_dataset.isObject(cfg)) {
                return;
            }
            const resolved = {};
            for (const option of animationOptions){
                resolved[option] = cfg[option];
            }
            (helpers_dataset.isArray(cfg.properties) && cfg.properties || [
                key
            ]).forEach((prop)=>{
                if (prop === key || !animatedProps.has(prop)) {
                    animatedProps.set(prop, resolved);
                }
            });
        });
    }
 _animateOptions(target, values) {
        const newOptions = values.options;
        const options = resolveTargetOptions(target, newOptions);
        if (!options) {
            return [];
        }
        const animations = this._createAnimations(options, newOptions);
        if (newOptions.$shared) {
            awaitAll(target.options.$animations, newOptions).then(()=>{
                target.options = newOptions;
            }, ()=>{
            });
        }
        return animations;
    }
 _createAnimations(target, values) {
        const animatedProps = this._properties;
        const animations = [];
        const running = target.$animations || (target.$animations = {});
        const props = Object.keys(values);
        const date = Date.now();
        let i;
        for(i = props.length - 1; i >= 0; --i){
            const prop = props[i];
            if (prop.charAt(0) === '$') {
                continue;
            }
            if (prop === 'options') {
                animations.push(...this._animateOptions(target, values));
                continue;
            }
            const value = values[prop];
            let animation = running[prop];
            const cfg = animatedProps.get(prop);
            if (animation) {
                if (cfg && animation.active()) {
                    animation.update(cfg, value, date);
                    continue;
                } else {
                    animation.cancel();
                }
            }
            if (!cfg || !cfg.duration) {
                target[prop] = value;
                continue;
            }
            running[prop] = animation = new Animation(cfg, target, prop, value);
            animations.push(animation);
        }
        return animations;
    }
 update(target, values) {
        if (this._properties.size === 0) {
            Object.assign(target, values);
            return;
        }
        const animations = this._createAnimations(target, values);
        if (animations.length) {
            animator.add(this._chart, animations);
            return true;
        }
    }
}
function awaitAll(animations, properties) {
    const running = [];
    const keys = Object.keys(properties);
    for(let i = 0; i < keys.length; i++){
        const anim = animations[keys[i]];
        if (anim && anim.active()) {
            running.push(anim.wait());
        }
    }
    return Promise.all(running);
}
function resolveTargetOptions(target, newOptions) {
    if (!newOptions) {
        return;
    }
    let options = target.options;
    if (!options) {
        target.options = newOptions;
        return;
    }
    if (options.$shared) {
        target.options = options = Object.assign({}, options, {
            $shared: false,
            $animations: {}
        });
    }
    return options;
}

function scaleClip(scale, allowedOverflow) {
    const opts = scale && scale.options || {};
    const reverse = opts.reverse;
    const min = opts.min === undefined ? allowedOverflow : 0;
    const max = opts.max === undefined ? allowedOverflow : 0;
    return {
        start: reverse ? max : min,
        end: reverse ? min : max
    };
}
function defaultClip(xScale, yScale, allowedOverflow) {
    if (allowedOverflow === false) {
        return false;
    }
    const x = scaleClip(xScale, allowedOverflow);
    const y = scaleClip(yScale, allowedOverflow);
    return {
        top: y.end,
        right: x.end,
        bottom: y.start,
        left: x.start
    };
}
function toClip(value) {
    let t, r, b, l;
    if (helpers_dataset.isObject(value)) {
        t = value.top;
        r = value.right;
        b = value.bottom;
        l = value.left;
    } else {
        t = r = b = l = value;
    }
    return {
        top: t,
        right: r,
        bottom: b,
        left: l,
        disabled: value === false
    };
}
function getSortedDatasetIndices(chart, filterVisible) {
    const keys = [];
    const metasets = chart._getSortedDatasetMetas(filterVisible);
    let i, ilen;
    for(i = 0, ilen = metasets.length; i < ilen; ++i){
        keys.push(metasets[i].index);
    }
    return keys;
}
function applyStack(stack, value, dsIndex, options = {}) {
    const keys = stack.keys;
    const singleMode = options.mode === 'single';
    let i, ilen, datasetIndex, otherValue;
    if (value === null) {
        return;
    }
    let found = false;
    for(i = 0, ilen = keys.length; i < ilen; ++i){
        datasetIndex = +keys[i];
        if (datasetIndex === dsIndex) {
            found = true;
            if (options.all) {
                continue;
            }
            break;
        }
        otherValue = stack.values[datasetIndex];
        if (helpers_dataset.isNumberFinite(otherValue) && (singleMode || value === 0 || helpers_dataset.sign(value) === helpers_dataset.sign(otherValue))) {
            value += otherValue;
        }
    }
    if (!found && !options.all) {
        return 0;
    }
    return value;
}
function convertObjectDataToArray(data, meta) {
    const { iScale , vScale  } = meta;
    const iAxisKey = iScale.axis === 'x' ? 'x' : 'y';
    const vAxisKey = vScale.axis === 'x' ? 'x' : 'y';
    const keys = Object.keys(data);
    const adata = new Array(keys.length);
    let i, ilen, key;
    for(i = 0, ilen = keys.length; i < ilen; ++i){
        key = keys[i];
        adata[i] = {
            [iAxisKey]: key,
            [vAxisKey]: data[key]
        };
    }
    return adata;
}
function isStacked(scale, meta) {
    const stacked = scale && scale.options.stacked;
    return stacked || stacked === undefined && meta.stack !== undefined;
}
function getStackKey(indexScale, valueScale, meta) {
    return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
}
function getUserBounds(scale) {
    const { min , max , minDefined , maxDefined  } = scale.getUserBounds();
    return {
        min: minDefined ? min : Number.NEGATIVE_INFINITY,
        max: maxDefined ? max : Number.POSITIVE_INFINITY
    };
}
function getOrCreateStack(stacks, stackKey, indexValue) {
    const subStack = stacks[stackKey] || (stacks[stackKey] = {});
    return subStack[indexValue] || (subStack[indexValue] = {});
}
function getLastIndexInStack(stack, vScale, positive, type) {
    for (const meta of vScale.getMatchingVisibleMetas(type).reverse()){
        const value = stack[meta.index];
        if (positive && value > 0 || !positive && value < 0) {
            return meta.index;
        }
    }
    return null;
}
function updateStacks(controller, parsed) {
    const { chart , _cachedMeta: meta  } = controller;
    const stacks = chart._stacks || (chart._stacks = {});
    const { iScale , vScale , index: datasetIndex  } = meta;
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const key = getStackKey(iScale, vScale, meta);
    const ilen = parsed.length;
    let stack;
    for(let i = 0; i < ilen; ++i){
        const item = parsed[i];
        const { [iAxis]: index , [vAxis]: value  } = item;
        const itemStacks = item._stacks || (item._stacks = {});
        stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);
        stack[datasetIndex] = value;
        stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
        stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
        const visualValues = stack._visualValues || (stack._visualValues = {});
        visualValues[datasetIndex] = value;
    }
}
function getFirstScaleId(chart, axis) {
    const scales = chart.scales;
    return Object.keys(scales).filter((key)=>scales[key].axis === axis).shift();
}
function createDatasetContext(parent, index) {
    return helpers_dataset.createContext(parent, {
        active: false,
        dataset: undefined,
        datasetIndex: index,
        index,
        mode: 'default',
        type: 'dataset'
    });
}
function createDataContext(parent, index, element) {
    return helpers_dataset.createContext(parent, {
        active: false,
        dataIndex: index,
        parsed: undefined,
        raw: undefined,
        element,
        index,
        mode: 'default',
        type: 'data'
    });
}
function clearStacks(meta, items) {
    const datasetIndex = meta.controller.index;
    const axis = meta.vScale && meta.vScale.axis;
    if (!axis) {
        return;
    }
    items = items || meta._parsed;
    for (const parsed of items){
        const stacks = parsed._stacks;
        if (!stacks || stacks[axis] === undefined || stacks[axis][datasetIndex] === undefined) {
            return;
        }
        delete stacks[axis][datasetIndex];
        if (stacks[axis]._visualValues !== undefined && stacks[axis]._visualValues[datasetIndex] !== undefined) {
            delete stacks[axis]._visualValues[datasetIndex];
        }
    }
}
const isDirectUpdateMode = (mode)=>mode === 'reset' || mode === 'none';
const cloneIfNotShared = (cached, shared)=>shared ? cached : Object.assign({}, cached);
const createStack = (canStack, meta, chart)=>canStack && !meta.hidden && meta._stacked && {
        keys: getSortedDatasetIndices(chart, true),
        values: null
    };
class DatasetController {
 static defaults = {};
 static datasetElementType = null;
 static dataElementType = null;
 constructor(chart, datasetIndex){
        this.chart = chart;
        this._ctx = chart.ctx;
        this.index = datasetIndex;
        this._cachedDataOpts = {};
        this._cachedMeta = this.getMeta();
        this._type = this._cachedMeta.type;
        this.options = undefined;
         this._parsing = false;
        this._data = undefined;
        this._objectData = undefined;
        this._sharedOptions = undefined;
        this._drawStart = undefined;
        this._drawCount = undefined;
        this.enableOptionSharing = false;
        this.supportsDecimation = false;
        this.$context = undefined;
        this._syncList = [];
        this.datasetElementType = new.target.datasetElementType;
        this.dataElementType = new.target.dataElementType;
        this.initialize();
    }
    initialize() {
        const meta = this._cachedMeta;
        this.configure();
        this.linkScales();
        meta._stacked = isStacked(meta.vScale, meta);
        this.addElements();
        if (this.options.fill && !this.chart.isPluginEnabled('filler')) {
            console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
        }
    }
    updateIndex(datasetIndex) {
        if (this.index !== datasetIndex) {
            clearStacks(this._cachedMeta);
        }
        this.index = datasetIndex;
    }
    linkScales() {
        const chart = this.chart;
        const meta = this._cachedMeta;
        const dataset = this.getDataset();
        const chooseId = (axis, x, y, r)=>axis === 'x' ? x : axis === 'r' ? r : y;
        const xid = meta.xAxisID = helpers_dataset.valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, 'x'));
        const yid = meta.yAxisID = helpers_dataset.valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, 'y'));
        const rid = meta.rAxisID = helpers_dataset.valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, 'r'));
        const indexAxis = meta.indexAxis;
        const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
        const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
        meta.xScale = this.getScaleForId(xid);
        meta.yScale = this.getScaleForId(yid);
        meta.rScale = this.getScaleForId(rid);
        meta.iScale = this.getScaleForId(iid);
        meta.vScale = this.getScaleForId(vid);
    }
    getDataset() {
        return this.chart.data.datasets[this.index];
    }
    getMeta() {
        return this.chart.getDatasetMeta(this.index);
    }
 getScaleForId(scaleID) {
        return this.chart.scales[scaleID];
    }
 _getOtherScale(scale) {
        const meta = this._cachedMeta;
        return scale === meta.iScale ? meta.vScale : meta.iScale;
    }
    reset() {
        this._update('reset');
    }
 _destroy() {
        const meta = this._cachedMeta;
        if (this._data) {
            helpers_dataset.unlistenArrayEvents(this._data, this);
        }
        if (meta._stacked) {
            clearStacks(meta);
        }
    }
 _dataCheck() {
        const dataset = this.getDataset();
        const data = dataset.data || (dataset.data = []);
        const _data = this._data;
        if (helpers_dataset.isObject(data)) {
            const meta = this._cachedMeta;
            this._data = convertObjectDataToArray(data, meta);
        } else if (_data !== data) {
            if (_data) {
                helpers_dataset.unlistenArrayEvents(_data, this);
                const meta = this._cachedMeta;
                clearStacks(meta);
                meta._parsed = [];
            }
            if (data && Object.isExtensible(data)) {
                helpers_dataset.listenArrayEvents(data, this);
            }
            this._syncList = [];
            this._data = data;
        }
    }
    addElements() {
        const meta = this._cachedMeta;
        this._dataCheck();
        if (this.datasetElementType) {
            meta.dataset = new this.datasetElementType();
        }
    }
    buildOrUpdateElements(resetNewElements) {
        const meta = this._cachedMeta;
        const dataset = this.getDataset();
        let stackChanged = false;
        this._dataCheck();
        const oldStacked = meta._stacked;
        meta._stacked = isStacked(meta.vScale, meta);
        if (meta.stack !== dataset.stack) {
            stackChanged = true;
            clearStacks(meta);
            meta.stack = dataset.stack;
        }
        this._resyncElements(resetNewElements);
        if (stackChanged || oldStacked !== meta._stacked) {
            updateStacks(this, meta._parsed);
            meta._stacked = isStacked(meta.vScale, meta);
        }
    }
 configure() {
        const config = this.chart.config;
        const scopeKeys = config.datasetScopeKeys(this._type);
        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
        this.options = config.createResolver(scopes, this.getContext());
        this._parsing = this.options.parsing;
        this._cachedDataOpts = {};
    }
 parse(start, count) {
        const { _cachedMeta: meta , _data: data  } = this;
        const { iScale , _stacked  } = meta;
        const iAxis = iScale.axis;
        let sorted = start === 0 && count === data.length ? true : meta._sorted;
        let prev = start > 0 && meta._parsed[start - 1];
        let i, cur, parsed;
        if (this._parsing === false) {
            meta._parsed = data;
            meta._sorted = true;
            parsed = data;
        } else {
            if (helpers_dataset.isArray(data[start])) {
                parsed = this.parseArrayData(meta, data, start, count);
            } else if (helpers_dataset.isObject(data[start])) {
                parsed = this.parseObjectData(meta, data, start, count);
            } else {
                parsed = this.parsePrimitiveData(meta, data, start, count);
            }
            const isNotInOrderComparedToPrev = ()=>cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
            for(i = 0; i < count; ++i){
                meta._parsed[i + start] = cur = parsed[i];
                if (sorted) {
                    if (isNotInOrderComparedToPrev()) {
                        sorted = false;
                    }
                    prev = cur;
                }
            }
            meta._sorted = sorted;
        }
        if (_stacked) {
            updateStacks(this, parsed);
        }
    }
 parsePrimitiveData(meta, data, start, count) {
        const { iScale , vScale  } = meta;
        const iAxis = iScale.axis;
        const vAxis = vScale.axis;
        const labels = iScale.getLabels();
        const singleScale = iScale === vScale;
        const parsed = new Array(count);
        let i, ilen, index;
        for(i = 0, ilen = count; i < ilen; ++i){
            index = i + start;
            parsed[i] = {
                [iAxis]: singleScale || iScale.parse(labels[index], index),
                [vAxis]: vScale.parse(data[index], index)
            };
        }
        return parsed;
    }
 parseArrayData(meta, data, start, count) {
        const { xScale , yScale  } = meta;
        const parsed = new Array(count);
        let i, ilen, index, item;
        for(i = 0, ilen = count; i < ilen; ++i){
            index = i + start;
            item = data[index];
            parsed[i] = {
                x: xScale.parse(item[0], index),
                y: yScale.parse(item[1], index)
            };
        }
        return parsed;
    }
 parseObjectData(meta, data, start, count) {
        const { xScale , yScale  } = meta;
        const { xAxisKey ='x' , yAxisKey ='y'  } = this._parsing;
        const parsed = new Array(count);
        let i, ilen, index, item;
        for(i = 0, ilen = count; i < ilen; ++i){
            index = i + start;
            item = data[index];
            parsed[i] = {
                x: xScale.parse(helpers_dataset.resolveObjectKey(item, xAxisKey), index),
                y: yScale.parse(helpers_dataset.resolveObjectKey(item, yAxisKey), index)
            };
        }
        return parsed;
    }
 getParsed(index) {
        return this._cachedMeta._parsed[index];
    }
 getDataElement(index) {
        return this._cachedMeta.data[index];
    }
 applyStack(scale, parsed, mode) {
        const chart = this.chart;
        const meta = this._cachedMeta;
        const value = parsed[scale.axis];
        const stack = {
            keys: getSortedDatasetIndices(chart, true),
            values: parsed._stacks[scale.axis]._visualValues
        };
        return applyStack(stack, value, meta.index, {
            mode
        });
    }
 updateRangeFromParsed(range, scale, parsed, stack) {
        const parsedValue = parsed[scale.axis];
        let value = parsedValue === null ? NaN : parsedValue;
        const values = stack && parsed._stacks[scale.axis];
        if (stack && values) {
            stack.values = values;
            value = applyStack(stack, parsedValue, this._cachedMeta.index);
        }
        range.min = Math.min(range.min, value);
        range.max = Math.max(range.max, value);
    }
 getMinMax(scale, canStack) {
        const meta = this._cachedMeta;
        const _parsed = meta._parsed;
        const sorted = meta._sorted && scale === meta.iScale;
        const ilen = _parsed.length;
        const otherScale = this._getOtherScale(scale);
        const stack = createStack(canStack, meta, this.chart);
        const range = {
            min: Number.POSITIVE_INFINITY,
            max: Number.NEGATIVE_INFINITY
        };
        const { min: otherMin , max: otherMax  } = getUserBounds(otherScale);
        let i, parsed;
        function _skip() {
            parsed = _parsed[i];
            const otherValue = parsed[otherScale.axis];
            return !helpers_dataset.isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
        }
        for(i = 0; i < ilen; ++i){
            if (_skip()) {
                continue;
            }
            this.updateRangeFromParsed(range, scale, parsed, stack);
            if (sorted) {
                break;
            }
        }
        if (sorted) {
            for(i = ilen - 1; i >= 0; --i){
                if (_skip()) {
                    continue;
                }
                this.updateRangeFromParsed(range, scale, parsed, stack);
                break;
            }
        }
        return range;
    }
    getAllParsedValues(scale) {
        const parsed = this._cachedMeta._parsed;
        const values = [];
        let i, ilen, value;
        for(i = 0, ilen = parsed.length; i < ilen; ++i){
            value = parsed[i][scale.axis];
            if (helpers_dataset.isNumberFinite(value)) {
                values.push(value);
            }
        }
        return values;
    }
 getMaxOverflow() {
        return false;
    }
 getLabelAndValue(index) {
        const meta = this._cachedMeta;
        const iScale = meta.iScale;
        const vScale = meta.vScale;
        const parsed = this.getParsed(index);
        return {
            label: iScale ? '' + iScale.getLabelForValue(parsed[iScale.axis]) : '',
            value: vScale ? '' + vScale.getLabelForValue(parsed[vScale.axis]) : ''
        };
    }
 _update(mode) {
        const meta = this._cachedMeta;
        this.update(mode || 'default');
        meta._clip = toClip(helpers_dataset.valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
    }
 update(mode) {}
    draw() {
        const ctx = this._ctx;
        const chart = this.chart;
        const meta = this._cachedMeta;
        const elements = meta.data || [];
        const area = chart.chartArea;
        const active = [];
        const start = this._drawStart || 0;
        const count = this._drawCount || elements.length - start;
        const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
        let i;
        if (meta.dataset) {
            meta.dataset.draw(ctx, area, start, count);
        }
        for(i = start; i < start + count; ++i){
            const element = elements[i];
            if (element.hidden) {
                continue;
            }
            if (element.active && drawActiveElementsOnTop) {
                active.push(element);
            } else {
                element.draw(ctx, area);
            }
        }
        for(i = 0; i < active.length; ++i){
            active[i].draw(ctx, area);
        }
    }
 getStyle(index, active) {
        const mode = active ? 'active' : 'default';
        return index === undefined && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index || 0, mode);
    }
 getContext(index, active, mode) {
        const dataset = this.getDataset();
        let context;
        if (index >= 0 && index < this._cachedMeta.data.length) {
            const element = this._cachedMeta.data[index];
            context = element.$context || (element.$context = createDataContext(this.getContext(), index, element));
            context.parsed = this.getParsed(index);
            context.raw = dataset.data[index];
            context.index = context.dataIndex = index;
        } else {
            context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
            context.dataset = dataset;
            context.index = context.datasetIndex = this.index;
        }
        context.active = !!active;
        context.mode = mode;
        return context;
    }
 resolveDatasetElementOptions(mode) {
        return this._resolveElementOptions(this.datasetElementType.id, mode);
    }
 resolveDataElementOptions(index, mode) {
        return this._resolveElementOptions(this.dataElementType.id, mode, index);
    }
 _resolveElementOptions(elementType, mode = 'default', index) {
        const active = mode === 'active';
        const cache = this._cachedDataOpts;
        const cacheKey = elementType + '-' + mode;
        const cached = cache[cacheKey];
        const sharing = this.enableOptionSharing && helpers_dataset.defined(index);
        if (cached) {
            return cloneIfNotShared(cached, sharing);
        }
        const config = this.chart.config;
        const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
        const prefixes = active ? [
            `${elementType}Hover`,
            'hover',
            elementType,
            ''
        ] : [
            elementType,
            ''
        ];
        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
        const names = Object.keys(helpers_dataset.defaults.elements[elementType]);
        const context = ()=>this.getContext(index, active, mode);
        const values = config.resolveNamedOptions(scopes, names, context, prefixes);
        if (values.$shared) {
            values.$shared = sharing;
            cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
        }
        return values;
    }
 _resolveAnimations(index, transition, active) {
        const chart = this.chart;
        const cache = this._cachedDataOpts;
        const cacheKey = `animation-${transition}`;
        const cached = cache[cacheKey];
        if (cached) {
            return cached;
        }
        let options;
        if (chart.options.animation !== false) {
            const config = this.chart.config;
            const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
            const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
            options = config.createResolver(scopes, this.getContext(index, active, transition));
        }
        const animations = new Animations(chart, options && options.animations);
        if (options && options._cacheable) {
            cache[cacheKey] = Object.freeze(animations);
        }
        return animations;
    }
 getSharedOptions(options) {
        if (!options.$shared) {
            return;
        }
        return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
    }
 includeOptions(mode, sharedOptions) {
        return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
    }
 _getSharedOptions(start, mode) {
        const firstOpts = this.resolveDataElementOptions(start, mode);
        const previouslySharedOptions = this._sharedOptions;
        const sharedOptions = this.getSharedOptions(firstOpts);
        const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
        this.updateSharedOptions(sharedOptions, mode, firstOpts);
        return {
            sharedOptions,
            includeOptions
        };
    }
 updateElement(element, index, properties, mode) {
        if (isDirectUpdateMode(mode)) {
            Object.assign(element, properties);
        } else {
            this._resolveAnimations(index, mode).update(element, properties);
        }
    }
 updateSharedOptions(sharedOptions, mode, newOptions) {
        if (sharedOptions && !isDirectUpdateMode(mode)) {
            this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);
        }
    }
 _setStyle(element, index, mode, active) {
        element.active = active;
        const options = this.getStyle(index, active);
        this._resolveAnimations(index, mode, active).update(element, {
            options: !active && this.getSharedOptions(options) || options
        });
    }
    removeHoverStyle(element, datasetIndex, index) {
        this._setStyle(element, index, 'active', false);
    }
    setHoverStyle(element, datasetIndex, index) {
        this._setStyle(element, index, 'active', true);
    }
 _removeDatasetHoverStyle() {
        const element = this._cachedMeta.dataset;
        if (element) {
            this._setStyle(element, undefined, 'active', false);
        }
    }
 _setDatasetHoverStyle() {
        const element = this._cachedMeta.dataset;
        if (element) {
            this._setStyle(element, undefined, 'active', true);
        }
    }
 _resyncElements(resetNewElements) {
        const data = this._data;
        const elements = this._cachedMeta.data;
        for (const [method, arg1, arg2] of this._syncList){
            this[method](arg1, arg2);
        }
        this._syncList = [];
        const numMeta = elements.length;
        const numData = data.length;
        const count = Math.min(numData, numMeta);
        if (count) {
            this.parse(0, count);
        }
        if (numData > numMeta) {
            this._insertElements(numMeta, numData - numMeta, resetNewElements);
        } else if (numData < numMeta) {
            this._removeElements(numData, numMeta - numData);
        }
    }
 _insertElements(start, count, resetNewElements = true) {
        const meta = this._cachedMeta;
        const data = meta.data;
        const end = start + count;
        let i;
        const move = (arr)=>{
            arr.length += count;
            for(i = arr.length - 1; i >= end; i--){
                arr[i] = arr[i - count];
            }
        };
        move(data);
        for(i = start; i < end; ++i){
            data[i] = new this.dataElementType();
        }
        if (this._parsing) {
            move(meta._parsed);
        }
        this.parse(start, count);
        if (resetNewElements) {
            this.updateElements(data, start, count, 'reset');
        }
    }
    updateElements(element, start, count, mode) {}
 _removeElements(start, count) {
        const meta = this._cachedMeta;
        if (this._parsing) {
            const removed = meta._parsed.splice(start, count);
            if (meta._stacked) {
                clearStacks(meta, removed);
            }
        }
        meta.data.splice(start, count);
    }
 _sync(args) {
        if (this._parsing) {
            this._syncList.push(args);
        } else {
            const [method, arg1, arg2] = args;
            this[method](arg1, arg2);
        }
        this.chart._dataChanges.push([
            this.index,
            ...args
        ]);
    }
    _onDataPush() {
        const count = arguments.length;
        this._sync([
            '_insertElements',
            this.getDataset().data.length - count,
            count
        ]);
    }
    _onDataPop() {
        this._sync([
            '_removeElements',
            this._cachedMeta.data.length - 1,
            1
        ]);
    }
    _onDataShift() {
        this._sync([
            '_removeElements',
            0,
            1
        ]);
    }
    _onDataSplice(start, count) {
        if (count) {
            this._sync([
                '_removeElements',
                start,
                count
            ]);
        }
        const newCount = arguments.length - 2;
        if (newCount) {
            this._sync([
                '_insertElements',
                start,
                newCount
            ]);
        }
    }
    _onDataUnshift() {
        this._sync([
            '_insertElements',
            0,
            arguments.length
        ]);
    }
}

function getAllScaleValues(scale, type) {
    if (!scale._cache.$bar) {
        const visibleMetas = scale.getMatchingVisibleMetas(type);
        let values = [];
        for(let i = 0, ilen = visibleMetas.length; i < ilen; i++){
            values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));
        }
        scale._cache.$bar = helpers_dataset._arrayUnique(values.sort((a, b)=>a - b));
    }
    return scale._cache.$bar;
}
 function computeMinSampleSize(meta) {
    const scale = meta.iScale;
    const values = getAllScaleValues(scale, meta.type);
    let min = scale._length;
    let i, ilen, curr, prev;
    const updateMinAndPrev = ()=>{
        if (curr === 32767 || curr === -32768) {
            return;
        }
        if (helpers_dataset.defined(prev)) {
            min = Math.min(min, Math.abs(curr - prev) || min);
        }
        prev = curr;
    };
    for(i = 0, ilen = values.length; i < ilen; ++i){
        curr = scale.getPixelForValue(values[i]);
        updateMinAndPrev();
    }
    prev = undefined;
    for(i = 0, ilen = scale.ticks.length; i < ilen; ++i){
        curr = scale.getPixelForTick(i);
        updateMinAndPrev();
    }
    return min;
}
 function computeFitCategoryTraits(index, ruler, options, stackCount) {
    const thickness = options.barThickness;
    let size, ratio;
    if (helpers_dataset.isNullOrUndef(thickness)) {
        size = ruler.min * options.categoryPercentage;
        ratio = options.barPercentage;
    } else {
        size = thickness * stackCount;
        ratio = 1;
    }
    return {
        chunk: size / stackCount,
        ratio,
        start: ruler.pixels[index] - size / 2
    };
}
 function computeFlexCategoryTraits(index, ruler, options, stackCount) {
    const pixels = ruler.pixels;
    const curr = pixels[index];
    let prev = index > 0 ? pixels[index - 1] : null;
    let next = index < pixels.length - 1 ? pixels[index + 1] : null;
    const percent = options.categoryPercentage;
    if (prev === null) {
        prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
    }
    if (next === null) {
        next = curr + curr - prev;
    }
    const start = curr - (curr - Math.min(prev, next)) / 2 * percent;
    const size = Math.abs(next - prev) / 2 * percent;
    return {
        chunk: size / stackCount,
        ratio: options.barPercentage,
        start
    };
}
function parseFloatBar(entry, item, vScale, i) {
    const startValue = vScale.parse(entry[0], i);
    const endValue = vScale.parse(entry[1], i);
    const min = Math.min(startValue, endValue);
    const max = Math.max(startValue, endValue);
    let barStart = min;
    let barEnd = max;
    if (Math.abs(min) > Math.abs(max)) {
        barStart = max;
        barEnd = min;
    }
    item[vScale.axis] = barEnd;
    item._custom = {
        barStart,
        barEnd,
        start: startValue,
        end: endValue,
        min,
        max
    };
}
function parseValue(entry, item, vScale, i) {
    if (helpers_dataset.isArray(entry)) {
        parseFloatBar(entry, item, vScale, i);
    } else {
        item[vScale.axis] = vScale.parse(entry, i);
    }
    return item;
}
function parseArrayOrPrimitive(meta, data, start, count) {
    const iScale = meta.iScale;
    const vScale = meta.vScale;
    const labels = iScale.getLabels();
    const singleScale = iScale === vScale;
    const parsed = [];
    let i, ilen, item, entry;
    for(i = start, ilen = start + count; i < ilen; ++i){
        entry = data[i];
        item = {};
        item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
        parsed.push(parseValue(entry, item, vScale, i));
    }
    return parsed;
}
function isFloatBar(custom) {
    return custom && custom.barStart !== undefined && custom.barEnd !== undefined;
}
function barSign(size, vScale, actualBase) {
    if (size !== 0) {
        return helpers_dataset.sign(size);
    }
    return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
}
function borderProps(properties) {
    let reverse, start, end, top, bottom;
    if (properties.horizontal) {
        reverse = properties.base > properties.x;
        start = 'left';
        end = 'right';
    } else {
        reverse = properties.base < properties.y;
        start = 'bottom';
        end = 'top';
    }
    if (reverse) {
        top = 'end';
        bottom = 'start';
    } else {
        top = 'start';
        bottom = 'end';
    }
    return {
        start,
        end,
        reverse,
        top,
        bottom
    };
}
function setBorderSkipped(properties, options, stack, index) {
    let edge = options.borderSkipped;
    const res = {};
    if (!edge) {
        properties.borderSkipped = res;
        return;
    }
    if (edge === true) {
        properties.borderSkipped = {
            top: true,
            right: true,
            bottom: true,
            left: true
        };
        return;
    }
    const { start , end , reverse , top , bottom  } = borderProps(properties);
    if (edge === 'middle' && stack) {
        properties.enableBorderRadius = true;
        if ((stack._top || 0) === index) {
            edge = top;
        } else if ((stack._bottom || 0) === index) {
            edge = bottom;
        } else {
            res[parseEdge(bottom, start, end, reverse)] = true;
            edge = top;
        }
    }
    res[parseEdge(edge, start, end, reverse)] = true;
    properties.borderSkipped = res;
}
function parseEdge(edge, a, b, reverse) {
    if (reverse) {
        edge = swap(edge, a, b);
        edge = startEnd(edge, b, a);
    } else {
        edge = startEnd(edge, a, b);
    }
    return edge;
}
function swap(orig, v1, v2) {
    return orig === v1 ? v2 : orig === v2 ? v1 : orig;
}
function startEnd(v, start, end) {
    return v === 'start' ? start : v === 'end' ? end : v;
}
function setInflateAmount(properties, { inflateAmount  }, ratio) {
    properties.inflateAmount = inflateAmount === 'auto' ? ratio === 1 ? 0.33 : 0 : inflateAmount;
}
class BarController extends DatasetController {
    static id = 'bar';
 static defaults = {
        datasetElementType: false,
        dataElementType: 'bar',
        categoryPercentage: 0.8,
        barPercentage: 0.9,
        grouped: true,
        animations: {
            numbers: {
                type: 'number',
                properties: [
                    'x',
                    'y',
                    'base',
                    'width',
                    'height'
                ]
            }
        }
    };
 static overrides = {
        scales: {
            _index_: {
                type: 'category',
                offset: true,
                grid: {
                    offset: true
                }
            },
            _value_: {
                type: 'linear',
                beginAtZero: true
            }
        }
    };
 parsePrimitiveData(meta, data, start, count) {
        return parseArrayOrPrimitive(meta, data, start, count);
    }
 parseArrayData(meta, data, start, count) {
        return parseArrayOrPrimitive(meta, data, start, count);
    }
 parseObjectData(meta, data, start, count) {
        const { iScale , vScale  } = meta;
        const { xAxisKey ='x' , yAxisKey ='y'  } = this._parsing;
        const iAxisKey = iScale.axis === 'x' ? xAxisKey : yAxisKey;
        const vAxisKey = vScale.axis === 'x' ? xAxisKey : yAxisKey;
        const parsed = [];
        let i, ilen, item, obj;
        for(i = start, ilen = start + count; i < ilen; ++i){
            obj = data[i];
            item = {};
            item[iScale.axis] = iScale.parse(helpers_dataset.resolveObjectKey(obj, iAxisKey), i);
            parsed.push(parseValue(helpers_dataset.resolveObjectKey(obj, vAxisKey), item, vScale, i));
        }
        return parsed;
    }
 updateRangeFromParsed(range, scale, parsed, stack) {
        super.updateRangeFromParsed(range, scale, parsed, stack);
        const custom = parsed._custom;
        if (custom && scale === this._cachedMeta.vScale) {
            range.min = Math.min(range.min, custom.min);
            range.max = Math.max(range.max, custom.max);
        }
    }
 getMaxOverflow() {
        return 0;
    }
 getLabelAndValue(index) {
        const meta = this._cachedMeta;
        const { iScale , vScale  } = meta;
        const parsed = this.getParsed(index);
        const custom = parsed._custom;
        const value = isFloatBar(custom) ? '[' + custom.start + ', ' + custom.end + ']' : '' + vScale.getLabelForValue(parsed[vScale.axis]);
        return {
            label: '' + iScale.getLabelForValue(parsed[iScale.axis]),
            value
        };
    }
    initialize() {
        this.enableOptionSharing = true;
        super.initialize();
        const meta = this._cachedMeta;
        meta.stack = this.getDataset().stack;
    }
    update(mode) {
        const meta = this._cachedMeta;
        this.updateElements(meta.data, 0, meta.data.length, mode);
    }
    updateElements(bars, start, count, mode) {
        const reset = mode === 'reset';
        const { index , _cachedMeta: { vScale  }  } = this;
        const base = vScale.getBasePixel();
        const horizontal = vScale.isHorizontal();
        const ruler = this._getRuler();
        const { sharedOptions , includeOptions  } = this._getSharedOptions(start, mode);
        for(let i = start; i < start + count; i++){
            const parsed = this.getParsed(i);
            const vpixels = reset || helpers_dataset.isNullOrUndef(parsed[vScale.axis]) ? {
                base,
                head: base
            } : this._calculateBarValuePixels(i);
            const ipixels = this._calculateBarIndexPixels(i, ruler);
            const stack = (parsed._stacks || {})[vScale.axis];
            const properties = {
                horizontal,
                base: vpixels.base,
                enableBorderRadius: !stack || isFloatBar(parsed._custom) || index === stack._top || index === stack._bottom,
                x: horizontal ? vpixels.head : ipixels.center,
                y: horizontal ? ipixels.center : vpixels.head,
                height: horizontal ? ipixels.size : Math.abs(vpixels.size),
                width: horizontal ? Math.abs(vpixels.size) : ipixels.size
            };
            if (includeOptions) {
                properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? 'active' : mode);
            }
            const options = properties.options || bars[i].options;
            setBorderSkipped(properties, options, stack, index);
            setInflateAmount(properties, options, ruler.ratio);
            this.updateElement(bars[i], i, properties, mode);
        }
    }
 _getStacks(last, dataIndex) {
        const { iScale  } = this._cachedMeta;
        const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta)=>meta.controller.options.grouped);
        const stacked = iScale.options.stacked;
        const stacks = [];
        const currentParsed = this._cachedMeta.controller.getParsed(dataIndex);
        const iScaleValue = currentParsed && currentParsed[iScale.axis];
        const skipNull = (meta)=>{
            const parsed = meta._parsed.find((item)=>item[iScale.axis] === iScaleValue);
            const val = parsed && parsed[meta.vScale.axis];
            if (helpers_dataset.isNullOrUndef(val) || isNaN(val)) {
                return true;
            }
        };
        for (const meta of metasets){
            if (dataIndex !== undefined && skipNull(meta)) {
                continue;
            }
            if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === undefined && meta.stack === undefined) {
                stacks.push(meta.stack);
            }
            if (meta.index === last) {
                break;
            }
        }
        if (!stacks.length) {
            stacks.push(undefined);
        }
        return stacks;
    }
 _getStackCount(index) {
        return this._getStacks(undefined, index).length;
    }
    _getAxisCount() {
        return this._getAxis().length;
    }
    getFirstScaleIdForIndexAxis() {
        const scales = this.chart.scales;
        const indexScaleId = this.chart.options.indexAxis;
        return Object.keys(scales).filter((key)=>scales[key].axis === indexScaleId).shift();
    }
    _getAxis() {
        const axis = {};
        const firstScaleAxisId = this.getFirstScaleIdForIndexAxis();
        for (const dataset of this.chart.data.datasets){
            axis[helpers_dataset.valueOrDefault(this.chart.options.indexAxis === 'x' ? dataset.xAxisID : dataset.yAxisID, firstScaleAxisId)] = true;
        }
        return Object.keys(axis);
    }
 _getStackIndex(datasetIndex, name, dataIndex) {
        const stacks = this._getStacks(datasetIndex, dataIndex);
        const index = name !== undefined ? stacks.indexOf(name) : -1;
        return index === -1 ? stacks.length - 1 : index;
    }
 _getRuler() {
        const opts = this.options;
        const meta = this._cachedMeta;
        const iScale = meta.iScale;
        const pixels = [];
        let i, ilen;
        for(i = 0, ilen = meta.data.length; i < ilen; ++i){
            pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));
        }
        const barThickness = opts.barThickness;
        const min = barThickness || computeMinSampleSize(meta);
        return {
            min,
            pixels,
            start: iScale._startPixel,
            end: iScale._endPixel,
            stackCount: this._getStackCount(),
            scale: iScale,
            grouped: opts.grouped,
            ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
        };
    }
 _calculateBarValuePixels(index) {
        const { _cachedMeta: { vScale , _stacked , index: datasetIndex  } , options: { base: baseValue , minBarLength  }  } = this;
        const actualBase = baseValue || 0;
        const parsed = this.getParsed(index);
        const custom = parsed._custom;
        const floating = isFloatBar(custom);
        let value = parsed[vScale.axis];
        let start = 0;
        let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
        let head, size;
        if (length !== value) {
            start = length - value;
            length = value;
        }
        if (floating) {
            value = custom.barStart;
            length = custom.barEnd - custom.barStart;
            if (value !== 0 && helpers_dataset.sign(value) !== helpers_dataset.sign(custom.barEnd)) {
                start = 0;
            }
            start += value;
        }
        const startValue = !helpers_dataset.isNullOrUndef(baseValue) && !floating ? baseValue : start;
        let base = vScale.getPixelForValue(startValue);
        if (this.chart.getDataVisibility(index)) {
            head = vScale.getPixelForValue(start + length);
        } else {
            head = base;
        }
        size = head - base;
        if (Math.abs(size) < minBarLength) {
            size = barSign(size, vScale, actualBase) * minBarLength;
            if (value === actualBase) {
                base -= size / 2;
            }
            const startPixel = vScale.getPixelForDecimal(0);
            const endPixel = vScale.getPixelForDecimal(1);
            const min = Math.min(startPixel, endPixel);
            const max = Math.max(startPixel, endPixel);
            base = Math.max(Math.min(base, max), min);
            head = base + size;
            if (_stacked && !floating) {
                parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);
            }
        }
        if (base === vScale.getPixelForValue(actualBase)) {
            const halfGrid = helpers_dataset.sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
            base += halfGrid;
            size -= halfGrid;
        }
        return {
            size,
            base,
            head,
            center: head + size / 2
        };
    }
 _calculateBarIndexPixels(index, ruler) {
        const scale = ruler.scale;
        const options = this.options;
        const skipNull = options.skipNull;
        const maxBarThickness = helpers_dataset.valueOrDefault(options.maxBarThickness, Infinity);
        let center, size;
        const axisCount = this._getAxisCount();
        if (ruler.grouped) {
            const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;
            const range = options.barThickness === 'flex' ? computeFlexCategoryTraits(index, ruler, options, stackCount * axisCount) : computeFitCategoryTraits(index, ruler, options, stackCount * axisCount);
            const axisID = this.chart.options.indexAxis === 'x' ? this.getDataset().xAxisID : this.getDataset().yAxisID;
            const axisNumber = this._getAxis().indexOf(helpers_dataset.valueOrDefault(axisID, this.getFirstScaleIdForIndexAxis()));
            const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : undefined) + axisNumber;
            center = range.start + range.chunk * stackIndex + range.chunk / 2;
            size = Math.min(maxBarThickness, range.chunk * range.ratio);
        } else {
            center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);
            size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
        }
        return {
            base: center - size / 2,
            head: center + size / 2,
            center,
            size
        };
    }
    draw() {
        const meta = this._cachedMeta;
        const vScale = meta.vScale;
        const rects = meta.data;
        const ilen = rects.length;
        let i = 0;
        for(; i < ilen; ++i){
            if (this.getParsed(i)[vScale.axis] !== null && !rects[i].hidden) {
                rects[i].draw(this._ctx);
            }
        }
    }
}

class BubbleController extends DatasetController {
    static id = 'bubble';
 static defaults = {
        datasetElementType: false,
        dataElementType: 'point',
        animations: {
            numbers: {
                type: 'number',
                properties: [
                    'x',
                    'y',
                    'borderWidth',
                    'radius'
                ]
            }
        }
    };
 static overrides = {
        scales: {
            x: {
                type: 'linear'
            },
            y: {
                type: 'linear'
            }
        }
    };
    initialize() {
        this.enableOptionSharing = true;
        super.initialize();
    }
 parsePrimitiveData(meta, data, start, count) {
        const parsed = super.parsePrimitiveData(meta, data, start, count);
        for(let i = 0; i < parsed.length; i++){
            parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;
        }
        return parsed;
    }
 parseArrayData(meta, data, start, count) {
        const parsed = super.parseArrayData(meta, data, start, count);
        for(let i = 0; i < parsed.length; i++){
            const item = data[start + i];
            parsed[i]._custom = helpers_dataset.valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);
        }
        return parsed;
    }
 parseObjectData(meta, data, start, count) {
        const parsed = super.parseObjectData(meta, data, start, count);
        for(let i = 0; i < parsed.length; i++){
            const item = data[start + i];
            parsed[i]._custom = helpers_dataset.valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);
        }
        return parsed;
    }
 getMaxOverflow() {
        const data = this._cachedMeta.data;
        let max = 0;
        for(let i = data.length - 1; i >= 0; --i){
            max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
        }
        return max > 0 && max;
    }
 getLabelAndValue(index) {
        const meta = this._cachedMeta;
        const labels = this.chart.data.labels || [];
        const { xScale , yScale  } = meta;
        const parsed = this.getParsed(index);
        const x = xScale.getLabelForValue(parsed.x);
        const y = yScale.getLabelForValue(parsed.y);
        const r = parsed._custom;
        return {
            label: labels[index] || '',
            value: '(' + x + ', ' + y + (r ? ', ' + r : '') + ')'
        };
    }
    update(mode) {
        const points = this._cachedMeta.data;
        this.updateElements(points, 0, points.length, mode);
    }
    updateElements(points, start, count, mode) {
        const reset = mode === 'reset';
        const { iScale , vScale  } = this._cachedMeta;
        const { sharedOptions , includeOptions  } = this._getSharedOptions(start, mode);
        const iAxis = iScale.axis;
        const vAxis = vScale.axis;
        for(let i = start; i < start + count; i++){
            const point = points[i];
            const parsed = !reset && this.getParsed(i);
            const properties = {};
            const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
            const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
            properties.skip = isNaN(iPixel) || isNaN(vPixel);
            if (includeOptions) {
                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);
                if (reset) {
                    properties.options.radius = 0;
                }
            }
            this.updateElement(point, i, properties, mode);
        }
    }
 resolveDataElementOptions(index, mode) {
        const parsed = this.getParsed(index);
        let values = super.resolveDataElementOptions(index, mode);
        if (values.$shared) {
            values = Object.assign({}, values, {
                $shared: false
            });
        }
        const radius = values.radius;
        if (mode !== 'active') {
            values.radius = 0;
        }
        values.radius += helpers_dataset.valueOrDefault(parsed && parsed._custom, radius);
        return values;
    }
}

function getRatioAndOffset(rotation, circumference, cutout) {
    let ratioX = 1;
    let ratioY = 1;
    let offsetX = 0;
    let offsetY = 0;
    if (circumference < helpers_dataset.TAU) {
        const startAngle = rotation;
        const endAngle = startAngle + circumference;
        const startX = Math.cos(startAngle);
        const startY = Math.sin(startAngle);
        const endX = Math.cos(endAngle);
        const endY = Math.sin(endAngle);
        const calcMax = (angle, a, b)=>helpers_dataset._angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);
        const calcMin = (angle, a, b)=>helpers_dataset._angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);
        const maxX = calcMax(0, startX, endX);
        const maxY = calcMax(helpers_dataset.HALF_PI, startY, endY);
        const minX = calcMin(helpers_dataset.PI, startX, endX);
        const minY = calcMin(helpers_dataset.PI + helpers_dataset.HALF_PI, startY, endY);
        ratioX = (maxX - minX) / 2;
        ratioY = (maxY - minY) / 2;
        offsetX = -(maxX + minX) / 2;
        offsetY = -(maxY + minY) / 2;
    }
    return {
        ratioX,
        ratioY,
        offsetX,
        offsetY
    };
}
class DoughnutController extends DatasetController {
    static id = 'doughnut';
 static defaults = {
        datasetElementType: false,
        dataElementType: 'arc',
        animation: {
            animateRotate: true,
            animateScale: false
        },
        animations: {
            numbers: {
                type: 'number',
                properties: [
                    'circumference',
                    'endAngle',
                    'innerRadius',
                    'outerRadius',
                    'startAngle',
                    'x',
                    'y',
                    'offset',
                    'borderWidth',
                    'spacing'
                ]
            }
        },
        cutout: '50%',
        rotation: 0,
        circumference: 360,
        radius: '100%',
        spacing: 0,
        indexAxis: 'r'
    };
    static descriptors = {
        _scriptable: (name)=>name !== 'spacing',
        _indexable: (name)=>name !== 'spacing' && !name.startsWith('borderDash') && !name.startsWith('hoverBorderDash')
    };
 static overrides = {
        aspectRatio: 1,
        plugins: {
            legend: {
                labels: {
                    generateLabels (chart) {
                        const data = chart.data;
                        if (data.labels.length && data.datasets.length) {
                            const { labels: { pointStyle , color  }  } = chart.legend.options;
                            return data.labels.map((label, i)=>{
                                const meta = chart.getDatasetMeta(0);
                                const style = meta.controller.getStyle(i);
                                return {
                                    text: label,
                                    fillStyle: style.backgroundColor,
                                    strokeStyle: style.borderColor,
                                    fontColor: color,
                                    lineWidth: style.borderWidth,
                                    pointStyle: pointStyle,
                                    hidden: !chart.getDataVisibility(i),
                                    index: i
                                };
                            });
                        }
                        return [];
                    }
                },
                onClick (e, legendItem, legend) {
                    legend.chart.toggleDataVisibility(legendItem.index);
                    legend.chart.update();
                }
            }
        }
    };
    constructor(chart, datasetIndex){
        super(chart, datasetIndex);
        this.enableOptionSharing = true;
        this.innerRadius = undefined;
        this.outerRadius = undefined;
        this.offsetX = undefined;
        this.offsetY = undefined;
    }
    linkScales() {}
 parse(start, count) {
        const data = this.getDataset().data;
        const meta = this._cachedMeta;
        if (this._parsing === false) {
            meta._parsed = data;
        } else {
            let getter = (i)=>+data[i];
            if (helpers_dataset.isObject(data[start])) {
                const { key ='value'  } = this._parsing;
                getter = (i)=>+helpers_dataset.resolveObjectKey(data[i], key);
            }
            let i, ilen;
            for(i = start, ilen = start + count; i < ilen; ++i){
                meta._parsed[i] = getter(i);
            }
        }
    }
 _getRotation() {
        return helpers_dataset.toRadians(this.options.rotation - 90);
    }
 _getCircumference() {
        return helpers_dataset.toRadians(this.options.circumference);
    }
 _getRotationExtents() {
        let min = helpers_dataset.TAU;
        let max = -helpers_dataset.TAU;
        for(let i = 0; i < this.chart.data.datasets.length; ++i){
            if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {
                const controller = this.chart.getDatasetMeta(i).controller;
                const rotation = controller._getRotation();
                const circumference = controller._getCircumference();
                min = Math.min(min, rotation);
                max = Math.max(max, rotation + circumference);
            }
        }
        return {
            rotation: min,
            circumference: max - min
        };
    }
 update(mode) {
        const chart = this.chart;
        const { chartArea  } = chart;
        const meta = this._cachedMeta;
        const arcs = meta.data;
        const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
        const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
        const cutout = Math.min(helpers_dataset.toPercentage(this.options.cutout, maxSize), 1);
        const chartWeight = this._getRingWeight(this.index);
        const { circumference , rotation  } = this._getRotationExtents();
        const { ratioX , ratioY , offsetX , offsetY  } = getRatioAndOffset(rotation, circumference, cutout);
        const maxWidth = (chartArea.width - spacing) / ratioX;
        const maxHeight = (chartArea.height - spacing) / ratioY;
        const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
        const outerRadius = helpers_dataset.toDimension(this.options.radius, maxRadius);
        const innerRadius = Math.max(outerRadius * cutout, 0);
        const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
        this.offsetX = offsetX * outerRadius;
        this.offsetY = offsetY * outerRadius;
        meta.total = this.calculateTotal();
        this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
        this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
        this.updateElements(arcs, 0, arcs.length, mode);
    }
 _circumference(i, reset) {
        const opts = this.options;
        const meta = this._cachedMeta;
        const circumference = this._getCircumference();
        if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {
            return 0;
        }
        return this.calculateCircumference(meta._parsed[i] * circumference / helpers_dataset.TAU);
    }
    updateElements(arcs, start, count, mode) {
        const reset = mode === 'reset';
        const chart = this.chart;
        const chartArea = chart.chartArea;
        const opts = chart.options;
        const animationOpts = opts.animation;
        const centerX = (chartArea.left + chartArea.right) / 2;
        const centerY = (chartArea.top + chartArea.bottom) / 2;
        const animateScale = reset && animationOpts.animateScale;
        const innerRadius = animateScale ? 0 : this.innerRadius;
        const outerRadius = animateScale ? 0 : this.outerRadius;
        const { sharedOptions , includeOptions  } = this._getSharedOptions(start, mode);
        let startAngle = this._getRotation();
        let i;
        for(i = 0; i < start; ++i){
            startAngle += this._circumference(i, reset);
        }
        for(i = start; i < start + count; ++i){
            const circumference = this._circumference(i, reset);
            const arc = arcs[i];
            const properties = {
                x: centerX + this.offsetX,
                y: centerY + this.offsetY,
                startAngle,
                endAngle: startAngle + circumference,
                circumference,
                outerRadius,
                innerRadius
            };
            if (includeOptions) {
                properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? 'active' : mode);
            }
            startAngle += circumference;
            this.updateElement(arc, i, properties, mode);
        }
    }
    calculateTotal() {
        const meta = this._cachedMeta;
        const metaData = meta.data;
        let total = 0;
        let i;
        for(i = 0; i < metaData.length; i++){
            const value = meta._parsed[i];
            if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {
                total += Math.abs(value);
            }
        }
        return total;
    }
    calculateCircumference(value) {
        const total = this._cachedMeta.total;
        if (total > 0 && !isNaN(value)) {
            return helpers_dataset.TAU * (Math.abs(value) / total);
        }
        return 0;
    }
    getLabelAndValue(index) {
        const meta = this._cachedMeta;
        const chart = this.chart;
        const labels = chart.data.labels || [];
        const value = helpers_dataset.formatNumber(meta._parsed[index], chart.options.locale);
        return {
            label: labels[index] || '',
            value
        };
    }
    getMaxBorderWidth(arcs) {
        let max = 0;
        const chart = this.chart;
        let i, ilen, meta, controller, options;
        if (!arcs) {
            for(i = 0, ilen = chart.data.datasets.length; i < ilen; ++i){
                if (chart.isDatasetVisible(i)) {
                    meta = chart.getDatasetMeta(i);
                    arcs = meta.data;
                    controller = meta.controller;
                    break;
                }
            }
        }
        if (!arcs) {
            return 0;
        }
        for(i = 0, ilen = arcs.length; i < ilen; ++i){
            options = controller.resolveDataElementOptions(i);
            if (options.borderAlign !== 'inner') {
                max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);
            }
        }
        return max;
    }
    getMaxOffset(arcs) {
        let max = 0;
        for(let i = 0, ilen = arcs.length; i < ilen; ++i){
            const options = this.resolveDataElementOptions(i);
            max = Math.max(max, options.offset || 0, options.hoverOffset || 0);
        }
        return max;
    }
 _getRingWeightOffset(datasetIndex) {
        let ringWeightOffset = 0;
        for(let i = 0; i < datasetIndex; ++i){
            if (this.chart.isDatasetVisible(i)) {
                ringWeightOffset += this._getRingWeight(i);
            }
        }
        return ringWeightOffset;
    }
 _getRingWeight(datasetIndex) {
        return Math.max(helpers_dataset.valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
    }
 _getVisibleDatasetWeightTotal() {
        return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
    }
}

class LineController extends DatasetController {
    static id = 'line';
 static defaults = {
        datasetElementType: 'line',
        dataElementType: 'point',
        showLine: true,
        spanGaps: false
    };
 static overrides = {
        scales: {
            _index_: {
                type: 'category'
            },
            _value_: {
                type: 'linear'
            }
        }
    };
    initialize() {
        this.enableOptionSharing = true;
        this.supportsDecimation = true;
        super.initialize();
    }
    update(mode) {
        const meta = this._cachedMeta;
        const { dataset: line , data: points = [] , _dataset  } = meta;
        const animationsDisabled = this.chart._animationsDisabled;
        let { start , count  } = helpers_dataset._getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
        this._drawStart = start;
        this._drawCount = count;
        if (helpers_dataset._scaleRangesChanged(meta)) {
            start = 0;
            count = points.length;
        }
        line._chart = this.chart;
        line._datasetIndex = this.index;
        line._decimated = !!_dataset._decimated;
        line.points = points;
        const options = this.resolveDatasetElementOptions(mode);
        if (!this.options.showLine) {
            options.borderWidth = 0;
        }
        options.segment = this.options.segment;
        this.updateElement(line, undefined, {
            animated: !animationsDisabled,
            options
        }, mode);
        this.updateElements(points, start, count, mode);
    }
    updateElements(points, start, count, mode) {
        const reset = mode === 'reset';
        const { iScale , vScale , _stacked , _dataset  } = this._cachedMeta;
        const { sharedOptions , includeOptions  } = this._getSharedOptions(start, mode);
        const iAxis = iScale.axis;
        const vAxis = vScale.axis;
        const { spanGaps , segment  } = this.options;
        const maxGapLength = helpers_dataset.isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
        const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';
        const end = start + count;
        const pointsCount = points.length;
        let prevParsed = start > 0 && this.getParsed(start - 1);
        for(let i = 0; i < pointsCount; ++i){
            const point = points[i];
            const properties = directUpdate ? point : {};
            if (i < start || i >= end) {
                properties.skip = true;
                continue;
            }
            const parsed = this.getParsed(i);
            const nullData = helpers_dataset.isNullOrUndef(parsed[vAxis]);
            const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
            const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
            properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
            properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
            if (segment) {
                properties.parsed = parsed;
                properties.raw = _dataset.data[i];
            }
            if (includeOptions) {
                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);
            }
            if (!directUpdate) {
                this.updateElement(point, i, properties, mode);
            }
            prevParsed = parsed;
        }
    }
 getMaxOverflow() {
        const meta = this._cachedMeta;
        const dataset = meta.dataset;
        const border = dataset.options && dataset.options.borderWidth || 0;
        const data = meta.data || [];
        if (!data.length) {
            return border;
        }
        const firstPoint = data[0].size(this.resolveDataElementOptions(0));
        const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
        return Math.max(border, firstPoint, lastPoint) / 2;
    }
    draw() {
        const meta = this._cachedMeta;
        meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
        super.draw();
    }
}

class PolarAreaController extends DatasetController {
    static id = 'polarArea';
 static defaults = {
        dataElementType: 'arc',
        animation: {
            animateRotate: true,
            animateScale: true
        },
        animations: {
            numbers: {
                type: 'number',
                properties: [
                    'x',
                    'y',
                    'startAngle',
                    'endAngle',
                    'innerRadius',
                    'outerRadius'
                ]
            }
        },
        indexAxis: 'r',
        startAngle: 0
    };
 static overrides = {
        aspectRatio: 1,
        plugins: {
            legend: {
                labels: {
                    generateLabels (chart) {
                        const data = chart.data;
                        if (data.labels.length && data.datasets.length) {
                            const { labels: { pointStyle , color  }  } = chart.legend.options;
                            return data.labels.map((label, i)=>{
                                const meta = chart.getDatasetMeta(0);
                                const style = meta.controller.getStyle(i);
                                return {
                                    text: label,
                                    fillStyle: style.backgroundColor,
                                    strokeStyle: style.borderColor,
                                    fontColor: color,
                                    lineWidth: style.borderWidth,
                                    pointStyle: pointStyle,
                                    hidden: !chart.getDataVisibility(i),
                                    index: i
                                };
                            });
                        }
                        return [];
                    }
                },
                onClick (e, legendItem, legend) {
                    legend.chart.toggleDataVisibility(legendItem.index);
                    legend.chart.update();
                }
            }
        },
        scales: {
            r: {
                type: 'radialLinear',
                angleLines: {
                    display: false
                },
                beginAtZero: true,
                grid: {
                    circular: true
                },
                pointLabels: {
                    display: false
                },
                startAngle: 0
            }
        }
    };
    constructor(chart, datasetIndex){
        super(chart, datasetIndex);
        this.innerRadius = undefined;
        this.outerRadius = undefined;
    }
    getLabelAndValue(index) {
        const meta = this._cachedMeta;
        const chart = this.chart;
        const labels = chart.data.labels || [];
        const value = helpers_dataset.formatNumber(meta._parsed[index].r, chart.options.locale);
        return {
            label: labels[index] || '',
            value
        };
    }
    parseObjectData(meta, data, start, count) {
        return helpers_dataset._parseObjectDataRadialScale.bind(this)(meta, data, start, count);
    }
    update(mode) {
        const arcs = this._cachedMeta.data;
        this._updateRadius();
        this.updateElements(arcs, 0, arcs.length, mode);
    }
 getMinMax() {
        const meta = this._cachedMeta;
        const range = {
            min: Number.POSITIVE_INFINITY,
            max: Number.NEGATIVE_INFINITY
        };
        meta.data.forEach((element, index)=>{
            const parsed = this.getParsed(index).r;
            if (!isNaN(parsed) && this.chart.getDataVisibility(index)) {
                if (parsed < range.min) {
                    range.min = parsed;
                }
                if (parsed > range.max) {
                    range.max = parsed;
                }
            }
        });
        return range;
    }
 _updateRadius() {
        const chart = this.chart;
        const chartArea = chart.chartArea;
        const opts = chart.options;
        const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
        const outerRadius = Math.max(minSize / 2, 0);
        const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
        const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
        this.outerRadius = outerRadius - radiusLength * this.index;
        this.innerRadius = this.outerRadius - radiusLength;
    }
    updateElements(arcs, start, count, mode) {
        const reset = mode === 'reset';
        const chart = this.chart;
        const opts = chart.options;
        const animationOpts = opts.animation;
        const scale = this._cachedMeta.rScale;
        const centerX = scale.xCenter;
        const centerY = scale.yCenter;
        const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * helpers_dataset.PI;
        let angle = datasetStartAngle;
        let i;
        const defaultAngle = 360 / this.countVisibleElements();
        for(i = 0; i < start; ++i){
            angle += this._computeAngle(i, mode, defaultAngle);
        }
        for(i = start; i < start + count; i++){
            const arc = arcs[i];
            let startAngle = angle;
            let endAngle = angle + this._computeAngle(i, mode, defaultAngle);
            let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;
            angle = endAngle;
            if (reset) {
                if (animationOpts.animateScale) {
                    outerRadius = 0;
                }
                if (animationOpts.animateRotate) {
                    startAngle = endAngle = datasetStartAngle;
                }
            }
            const properties = {
                x: centerX,
                y: centerY,
                innerRadius: 0,
                outerRadius,
                startAngle,
                endAngle,
                options: this.resolveDataElementOptions(i, arc.active ? 'active' : mode)
            };
            this.updateElement(arc, i, properties, mode);
        }
    }
    countVisibleElements() {
        const meta = this._cachedMeta;
        let count = 0;
        meta.data.forEach((element, index)=>{
            if (!isNaN(this.getParsed(index).r) && this.chart.getDataVisibility(index)) {
                count++;
            }
        });
        return count;
    }
 _computeAngle(index, mode, defaultAngle) {
        return this.chart.getDataVisibility(index) ? helpers_dataset.toRadians(this.resolveDataElementOptions(index, mode).angle || defaultAngle) : 0;
    }
}

class PieController extends DoughnutController {
    static id = 'pie';
 static defaults = {
        cutout: 0,
        rotation: 0,
        circumference: 360,
        radius: '100%'
    };
}

class RadarController extends DatasetController {
    static id = 'radar';
 static defaults = {
        datasetElementType: 'line',
        dataElementType: 'point',
        indexAxis: 'r',
        showLine: true,
        elements: {
            line: {
                fill: 'start'
            }
        }
    };
 static overrides = {
        aspectRatio: 1,
        scales: {
            r: {
                type: 'radialLinear'
            }
        }
    };
 getLabelAndValue(index) {
        const vScale = this._cachedMeta.vScale;
        const parsed = this.getParsed(index);
        return {
            label: vScale.getLabels()[index],
            value: '' + vScale.getLabelForValue(parsed[vScale.axis])
        };
    }
    parseObjectData(meta, data, start, count) {
        return helpers_dataset._parseObjectDataRadialScale.bind(this)(meta, data, start, count);
    }
    update(mode) {
        const meta = this._cachedMeta;
        const line = meta.dataset;
        const points = meta.data || [];
        const labels = meta.iScale.getLabels();
        line.points = points;
        if (mode !== 'resize') {
            const options = this.resolveDatasetElementOptions(mode);
            if (!this.options.showLine) {
                options.borderWidth = 0;
            }
            const properties = {
                _loop: true,
                _fullLoop: labels.length === points.length,
                options
            };
            this.updateElement(line, undefined, properties, mode);
        }
        this.updateElements(points, 0, points.length, mode);
    }
    updateElements(points, start, count, mode) {
        const scale = this._cachedMeta.rScale;
        const reset = mode === 'reset';
        for(let i = start; i < start + count; i++){
            const point = points[i];
            const options = this.resolveDataElementOptions(i, point.active ? 'active' : mode);
            const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);
            const x = reset ? scale.xCenter : pointPosition.x;
            const y = reset ? scale.yCenter : pointPosition.y;
            const properties = {
                x,
                y,
                angle: pointPosition.angle,
                skip: isNaN(x) || isNaN(y),
                options
            };
            this.updateElement(point, i, properties, mode);
        }
    }
}

class ScatterController extends DatasetController {
    static id = 'scatter';
 static defaults = {
        datasetElementType: false,
        dataElementType: 'point',
        showLine: false,
        fill: false
    };
 static overrides = {
        interaction: {
            mode: 'point'
        },
        scales: {
            x: {
                type: 'linear'
            },
            y: {
                type: 'linear'
            }
        }
    };
 getLabelAndValue(index) {
        const meta = this._cachedMeta;
        const labels = this.chart.data.labels || [];
        const { xScale , yScale  } = meta;
        const parsed = this.getParsed(index);
        const x = xScale.getLabelForValue(parsed.x);
        const y = yScale.getLabelForValue(parsed.y);
        return {
            label: labels[index] || '',
            value: '(' + x + ', ' + y + ')'
        };
    }
    update(mode) {
        const meta = this._cachedMeta;
        const { data: points = []  } = meta;
        const animationsDisabled = this.chart._animationsDisabled;
        let { start , count  } = helpers_dataset._getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
        this._drawStart = start;
        this._drawCount = count;
        if (helpers_dataset._scaleRangesChanged(meta)) {
            start = 0;
            count = points.length;
        }
        if (this.options.showLine) {
            if (!this.datasetElementType) {
                this.addElements();
            }
            const { dataset: line , _dataset  } = meta;
            line._chart = this.chart;
            line._datasetIndex = this.index;
            line._decimated = !!_dataset._decimated;
            line.points = points;
            const options = this.resolveDatasetElementOptions(mode);
            options.segment = this.options.segment;
            this.updateElement(line, undefined, {
                animated: !animationsDisabled,
                options
            }, mode);
        } else if (this.datasetElementType) {
            delete meta.dataset;
            this.datasetElementType = false;
        }
        this.updateElements(points, start, count, mode);
    }
    addElements() {
        const { showLine  } = this.options;
        if (!this.datasetElementType && showLine) {
            this.datasetElementType = this.chart.registry.getElement('line');
        }
        super.addElements();
    }
    updateElements(points, start, count, mode) {
        const reset = mode === 'reset';
        const { iScale , vScale , _stacked , _dataset  } = this._cachedMeta;
        const firstOpts = this.resolveDataElementOptions(start, mode);
        const sharedOptions = this.getSharedOptions(firstOpts);
        const includeOptions = this.includeOptions(mode, sharedOptions);
        const iAxis = iScale.axis;
        const vAxis = vScale.axis;
        const { spanGaps , segment  } = this.options;
        const maxGapLength = helpers_dataset.isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
        const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';
        let prevParsed = start > 0 && this.getParsed(start - 1);
        for(let i = start; i < start + count; ++i){
            const point = points[i];
            const parsed = this.getParsed(i);
            const properties = directUpdate ? point : {};
            const nullData = helpers_dataset.isNullOrUndef(parsed[vAxis]);
            const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
            const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
            properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
            properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
            if (segment) {
                properties.parsed = parsed;
                properties.raw = _dataset.data[i];
            }
            if (includeOptions) {
                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);
            }
            if (!directUpdate) {
                this.updateElement(point, i, properties, mode);
            }
            prevParsed = parsed;
        }
        this.updateSharedOptions(sharedOptions, mode, firstOpts);
    }
 getMaxOverflow() {
        const meta = this._cachedMeta;
        const data = meta.data || [];
        if (!this.options.showLine) {
            let max = 0;
            for(let i = data.length - 1; i >= 0; --i){
                max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
            }
            return max > 0 && max;
        }
        const dataset = meta.dataset;
        const border = dataset.options && dataset.options.borderWidth || 0;
        if (!data.length) {
            return border;
        }
        const firstPoint = data[0].size(this.resolveDataElementOptions(0));
        const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
        return Math.max(border, firstPoint, lastPoint) / 2;
    }
}

var controllers = /*#__PURE__*/Object.freeze({
__proto__: null,
BarController: BarController,
BubbleController: BubbleController,
DoughnutController: DoughnutController,
LineController: LineController,
PieController: PieController,
PolarAreaController: PolarAreaController,
RadarController: RadarController,
ScatterController: ScatterController
});

/**
 * @namespace Chart._adapters
 * @since 2.8.0
 * @private
 */ function abstract() {
    throw new Error('This method is not implemented: Check that a complete date adapter is provided.');
}
/**
 * Date adapter (current used by the time scale)
 * @namespace Chart._adapters._date
 * @memberof Chart._adapters
 * @private
 */ class DateAdapterBase {
    /**
   * Override default date adapter methods.
   * Accepts type parameter to define options type.
   * @example
   * Chart._adapters._date.override<{myAdapterOption: string}>({
   *   init() {
   *     console.log(this.options.myAdapterOption);
   *   }
   * })
   */ static override(members) {
        Object.assign(DateAdapterBase.prototype, members);
    }
    options;
    constructor(options){
        this.options = options || {};
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    init() {}
    formats() {
        return abstract();
    }
    parse() {
        return abstract();
    }
    format() {
        return abstract();
    }
    add() {
        return abstract();
    }
    diff() {
        return abstract();
    }
    startOf() {
        return abstract();
    }
    endOf() {
        return abstract();
    }
}
var adapters = {
    _date: DateAdapterBase
};

function binarySearch(metaset, axis, value, intersect) {
    const { controller , data , _sorted  } = metaset;
    const iScale = controller._cachedMeta.iScale;
    const spanGaps = metaset.dataset ? metaset.dataset.options ? metaset.dataset.options.spanGaps : null : null;
    if (iScale && axis === iScale.axis && axis !== 'r' && _sorted && data.length) {
        const lookupMethod = iScale._reversePixels ? helpers_dataset._rlookupByKey : helpers_dataset._lookupByKey;
        if (!intersect) {
            const result = lookupMethod(data, axis, value);
            if (spanGaps) {
                const { vScale  } = controller._cachedMeta;
                const { _parsed  } = metaset;
                const distanceToDefinedLo = _parsed.slice(0, result.lo + 1).reverse().findIndex((point)=>!helpers_dataset.isNullOrUndef(point[vScale.axis]));
                result.lo -= Math.max(0, distanceToDefinedLo);
                const distanceToDefinedHi = _parsed.slice(result.hi).findIndex((point)=>!helpers_dataset.isNullOrUndef(point[vScale.axis]));
                result.hi += Math.max(0, distanceToDefinedHi);
            }
            return result;
        } else if (controller._sharedOptions) {
            const el = data[0];
            const range = typeof el.getRange === 'function' && el.getRange(axis);
            if (range) {
                const start = lookupMethod(data, axis, value - range);
                const end = lookupMethod(data, axis, value + range);
                return {
                    lo: start.lo,
                    hi: end.hi
                };
            }
        }
    }
    return {
        lo: 0,
        hi: data.length - 1
    };
}
 function evaluateInteractionItems(chart, axis, position, handler, intersect) {
    const metasets = chart.getSortedVisibleDatasetMetas();
    const value = position[axis];
    for(let i = 0, ilen = metasets.length; i < ilen; ++i){
        const { index , data  } = metasets[i];
        const { lo , hi  } = binarySearch(metasets[i], axis, value, intersect);
        for(let j = lo; j <= hi; ++j){
            const element = data[j];
            if (!element.skip) {
                handler(element, index, j);
            }
        }
    }
}
 function getDistanceMetricForAxis(axis) {
    const useX = axis.indexOf('x') !== -1;
    const useY = axis.indexOf('y') !== -1;
    return function(pt1, pt2) {
        const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
        const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
        return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
    };
}
 function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {
    const items = [];
    if (!includeInvisible && !chart.isPointInArea(position)) {
        return items;
    }
    const evaluationFunc = function(element, datasetIndex, index) {
        if (!includeInvisible && !helpers_dataset._isPointInArea(element, chart.chartArea, 0)) {
            return;
        }
        if (element.inRange(position.x, position.y, useFinalPosition)) {
            items.push({
                element,
                datasetIndex,
                index
            });
        }
    };
    evaluateInteractionItems(chart, axis, position, evaluationFunc, true);
    return items;
}
 function getNearestRadialItems(chart, position, axis, useFinalPosition) {
    let items = [];
    function evaluationFunc(element, datasetIndex, index) {
        const { startAngle , endAngle  } = element.getProps([
            'startAngle',
            'endAngle'
        ], useFinalPosition);
        const { angle  } = helpers_dataset.getAngleFromPoint(element, {
            x: position.x,
            y: position.y
        });
        if (helpers_dataset._angleBetween(angle, startAngle, endAngle)) {
            items.push({
                element,
                datasetIndex,
                index
            });
        }
    }
    evaluateInteractionItems(chart, axis, position, evaluationFunc);
    return items;
}
 function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
    let items = [];
    const distanceMetric = getDistanceMetricForAxis(axis);
    let minDistance = Number.POSITIVE_INFINITY;
    function evaluationFunc(element, datasetIndex, index) {
        const inRange = element.inRange(position.x, position.y, useFinalPosition);
        if (intersect && !inRange) {
            return;
        }
        const center = element.getCenterPoint(useFinalPosition);
        const pointInArea = !!includeInvisible || chart.isPointInArea(center);
        if (!pointInArea && !inRange) {
            return;
        }
        const distance = distanceMetric(position, center);
        if (distance < minDistance) {
            items = [
                {
                    element,
                    datasetIndex,
                    index
                }
            ];
            minDistance = distance;
        } else if (distance === minDistance) {
            items.push({
                element,
                datasetIndex,
                index
            });
        }
    }
    evaluateInteractionItems(chart, axis, position, evaluationFunc);
    return items;
}
 function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
    if (!includeInvisible && !chart.isPointInArea(position)) {
        return [];
    }
    return axis === 'r' && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);
}
 function getAxisItems(chart, position, axis, intersect, useFinalPosition) {
    const items = [];
    const rangeMethod = axis === 'x' ? 'inXRange' : 'inYRange';
    let intersectsItem = false;
    evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index)=>{
        if (element[rangeMethod] && element[rangeMethod](position[axis], useFinalPosition)) {
            items.push({
                element,
                datasetIndex,
                index
            });
            intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
        }
    });
    if (intersect && !intersectsItem) {
        return [];
    }
    return items;
}
 var Interaction = {
    evaluateInteractionItems,
    modes: {
 index (chart, e, options, useFinalPosition) {
            const position = helpers_dataset.getRelativePosition(e, chart);
            const axis = options.axis || 'x';
            const includeInvisible = options.includeInvisible || false;
            const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
            const elements = [];
            if (!items.length) {
                return [];
            }
            chart.getSortedVisibleDatasetMetas().forEach((meta)=>{
                const index = items[0].index;
                const element = meta.data[index];
                if (element && !element.skip) {
                    elements.push({
                        element,
                        datasetIndex: meta.index,
                        index
                    });
                }
            });
            return elements;
        },
 dataset (chart, e, options, useFinalPosition) {
            const position = helpers_dataset.getRelativePosition(e, chart);
            const axis = options.axis || 'xy';
            const includeInvisible = options.includeInvisible || false;
            let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
            if (items.length > 0) {
                const datasetIndex = items[0].datasetIndex;
                const data = chart.getDatasetMeta(datasetIndex).data;
                items = [];
                for(let i = 0; i < data.length; ++i){
                    items.push({
                        element: data[i],
                        datasetIndex,
                        index: i
                    });
                }
            }
            return items;
        },
 point (chart, e, options, useFinalPosition) {
            const position = helpers_dataset.getRelativePosition(e, chart);
            const axis = options.axis || 'xy';
            const includeInvisible = options.includeInvisible || false;
            return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);
        },
 nearest (chart, e, options, useFinalPosition) {
            const position = helpers_dataset.getRelativePosition(e, chart);
            const axis = options.axis || 'xy';
            const includeInvisible = options.includeInvisible || false;
            return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);
        },
 x (chart, e, options, useFinalPosition) {
            const position = helpers_dataset.getRelativePosition(e, chart);
            return getAxisItems(chart, position, 'x', options.intersect, useFinalPosition);
        },
 y (chart, e, options, useFinalPosition) {
            const position = helpers_dataset.getRelativePosition(e, chart);
            return getAxisItems(chart, position, 'y', options.intersect, useFinalPosition);
        }
    }
};

const STATIC_POSITIONS = [
    'left',
    'top',
    'right',
    'bottom'
];
function filterByPosition(array, position) {
    return array.filter((v)=>v.pos === position);
}
function filterDynamicPositionByAxis(array, axis) {
    return array.filter((v)=>STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
}
function sortByWeight(array, reverse) {
    return array.sort((a, b)=>{
        const v0 = reverse ? b : a;
        const v1 = reverse ? a : b;
        return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
    });
}
function wrapBoxes(boxes) {
    const layoutBoxes = [];
    let i, ilen, box, pos, stack, stackWeight;
    for(i = 0, ilen = (boxes || []).length; i < ilen; ++i){
        box = boxes[i];
        ({ position: pos , options: { stack , stackWeight =1  }  } = box);
        layoutBoxes.push({
            index: i,
            box,
            pos,
            horizontal: box.isHorizontal(),
            weight: box.weight,
            stack: stack && pos + stack,
            stackWeight
        });
    }
    return layoutBoxes;
}
function buildStacks(layouts) {
    const stacks = {};
    for (const wrap of layouts){
        const { stack , pos , stackWeight  } = wrap;
        if (!stack || !STATIC_POSITIONS.includes(pos)) {
            continue;
        }
        const _stack = stacks[stack] || (stacks[stack] = {
            count: 0,
            placed: 0,
            weight: 0,
            size: 0
        });
        _stack.count++;
        _stack.weight += stackWeight;
    }
    return stacks;
}
 function setLayoutDims(layouts, params) {
    const stacks = buildStacks(layouts);
    const { vBoxMaxWidth , hBoxMaxHeight  } = params;
    let i, ilen, layout;
    for(i = 0, ilen = layouts.length; i < ilen; ++i){
        layout = layouts[i];
        const { fullSize  } = layout.box;
        const stack = stacks[layout.stack];
        const factor = stack && layout.stackWeight / stack.weight;
        if (layout.horizontal) {
            layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
            layout.height = hBoxMaxHeight;
        } else {
            layout.width = vBoxMaxWidth;
            layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
        }
    }
    return stacks;
}
function buildLayoutBoxes(boxes) {
    const layoutBoxes = wrapBoxes(boxes);
    const fullSize = sortByWeight(layoutBoxes.filter((wrap)=>wrap.box.fullSize), true);
    const left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);
    const right = sortByWeight(filterByPosition(layoutBoxes, 'right'));
    const top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);
    const bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));
    const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, 'x');
    const centerVertical = filterDynamicPositionByAxis(layoutBoxes, 'y');
    return {
        fullSize,
        leftAndTop: left.concat(top),
        rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
        chartArea: filterByPosition(layoutBoxes, 'chartArea'),
        vertical: left.concat(right).concat(centerVertical),
        horizontal: top.concat(bottom).concat(centerHorizontal)
    };
}
function getCombinedMax(maxPadding, chartArea, a, b) {
    return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
}
function updateMaxPadding(maxPadding, boxPadding) {
    maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
    maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
    maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
    maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
}
function updateDims(chartArea, params, layout, stacks) {
    const { pos , box  } = layout;
    const maxPadding = chartArea.maxPadding;
    if (!helpers_dataset.isObject(pos)) {
        if (layout.size) {
            chartArea[pos] -= layout.size;
        }
        const stack = stacks[layout.stack] || {
            size: 0,
            count: 1
        };
        stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
        layout.size = stack.size / stack.count;
        chartArea[pos] += layout.size;
    }
    if (box.getPadding) {
        updateMaxPadding(maxPadding, box.getPadding());
    }
    const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, 'left', 'right'));
    const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, 'top', 'bottom'));
    const widthChanged = newWidth !== chartArea.w;
    const heightChanged = newHeight !== chartArea.h;
    chartArea.w = newWidth;
    chartArea.h = newHeight;
    return layout.horizontal ? {
        same: widthChanged,
        other: heightChanged
    } : {
        same: heightChanged,
        other: widthChanged
    };
}
function handleMaxPadding(chartArea) {
    const maxPadding = chartArea.maxPadding;
    function updatePos(pos) {
        const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
        chartArea[pos] += change;
        return change;
    }
    chartArea.y += updatePos('top');
    chartArea.x += updatePos('left');
    updatePos('right');
    updatePos('bottom');
}
function getMargins(horizontal, chartArea) {
    const maxPadding = chartArea.maxPadding;
    function marginForPositions(positions) {
        const margin = {
            left: 0,
            top: 0,
            right: 0,
            bottom: 0
        };
        positions.forEach((pos)=>{
            margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
        });
        return margin;
    }
    return horizontal ? marginForPositions([
        'left',
        'right'
    ]) : marginForPositions([
        'top',
        'bottom'
    ]);
}
function fitBoxes(boxes, chartArea, params, stacks) {
    const refitBoxes = [];
    let i, ilen, layout, box, refit, changed;
    for(i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i){
        layout = boxes[i];
        box = layout.box;
        box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
        const { same , other  } = updateDims(chartArea, params, layout, stacks);
        refit |= same && refitBoxes.length;
        changed = changed || other;
        if (!box.fullSize) {
            refitBoxes.push(layout);
        }
    }
    return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
}
function setBoxDims(box, left, top, width, height) {
    box.top = top;
    box.left = left;
    box.right = left + width;
    box.bottom = top + height;
    box.width = width;
    box.height = height;
}
function placeBoxes(boxes, chartArea, params, stacks) {
    const userPadding = params.padding;
    let { x , y  } = chartArea;
    for (const layout of boxes){
        const box = layout.box;
        const stack = stacks[layout.stack] || {
            count: 1,
            placed: 0,
            weight: 1
        };
        const weight = layout.stackWeight / stack.weight || 1;
        if (layout.horizontal) {
            const width = chartArea.w * weight;
            const height = stack.size || box.height;
            if (helpers_dataset.defined(stack.start)) {
                y = stack.start;
            }
            if (box.fullSize) {
                setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);
            } else {
                setBoxDims(box, chartArea.left + stack.placed, y, width, height);
            }
            stack.start = y;
            stack.placed += width;
            y = box.bottom;
        } else {
            const height = chartArea.h * weight;
            const width = stack.size || box.width;
            if (helpers_dataset.defined(stack.start)) {
                x = stack.start;
            }
            if (box.fullSize) {
                setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
            } else {
                setBoxDims(box, x, chartArea.top + stack.placed, width, height);
            }
            stack.start = x;
            stack.placed += height;
            x = box.right;
        }
    }
    chartArea.x = x;
    chartArea.y = y;
}
var layouts = {
 addBox (chart, item) {
        if (!chart.boxes) {
            chart.boxes = [];
        }
        item.fullSize = item.fullSize || false;
        item.position = item.position || 'top';
        item.weight = item.weight || 0;
        item._layers = item._layers || function() {
            return [
                {
                    z: 0,
                    draw (chartArea) {
                        item.draw(chartArea);
                    }
                }
            ];
        };
        chart.boxes.push(item);
    },
 removeBox (chart, layoutItem) {
        const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
        if (index !== -1) {
            chart.boxes.splice(index, 1);
        }
    },
 configure (chart, item, options) {
        item.fullSize = options.fullSize;
        item.position = options.position;
        item.weight = options.weight;
    },
 update (chart, width, height, minPadding) {
        if (!chart) {
            return;
        }
        const padding = helpers_dataset.toPadding(chart.options.layout.padding);
        const availableWidth = Math.max(width - padding.width, 0);
        const availableHeight = Math.max(height - padding.height, 0);
        const boxes = buildLayoutBoxes(chart.boxes);
        const verticalBoxes = boxes.vertical;
        const horizontalBoxes = boxes.horizontal;
        helpers_dataset.each(chart.boxes, (box)=>{
            if (typeof box.beforeLayout === 'function') {
                box.beforeLayout();
            }
        });
        const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap)=>wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
        const params = Object.freeze({
            outerWidth: width,
            outerHeight: height,
            padding,
            availableWidth,
            availableHeight,
            vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
            hBoxMaxHeight: availableHeight / 2
        });
        const maxPadding = Object.assign({}, padding);
        updateMaxPadding(maxPadding, helpers_dataset.toPadding(minPadding));
        const chartArea = Object.assign({
            maxPadding,
            w: availableWidth,
            h: availableHeight,
            x: padding.left,
            y: padding.top
        }, padding);
        const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
        fitBoxes(boxes.fullSize, chartArea, params, stacks);
        fitBoxes(verticalBoxes, chartArea, params, stacks);
        if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
            fitBoxes(verticalBoxes, chartArea, params, stacks);
        }
        handleMaxPadding(chartArea);
        placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
        chartArea.x += chartArea.w;
        chartArea.y += chartArea.h;
        placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
        chart.chartArea = {
            left: chartArea.left,
            top: chartArea.top,
            right: chartArea.left + chartArea.w,
            bottom: chartArea.top + chartArea.h,
            height: chartArea.h,
            width: chartArea.w
        };
        helpers_dataset.each(boxes.chartArea, (layout)=>{
            const box = layout.box;
            Object.assign(box, chart.chartArea);
            box.update(chartArea.w, chartArea.h, {
                left: 0,
                top: 0,
                right: 0,
                bottom: 0
            });
        });
    }
};

class BasePlatform {
 acquireContext(canvas, aspectRatio) {}
 releaseContext(context) {
        return false;
    }
 addEventListener(chart, type, listener) {}
 removeEventListener(chart, type, listener) {}
 getDevicePixelRatio() {
        return 1;
    }
 getMaximumSize(element, width, height, aspectRatio) {
        width = Math.max(0, width || element.width);
        height = height || element.height;
        return {
            width,
            height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
        };
    }
 isAttached(canvas) {
        return true;
    }
 updateConfig(config) {
    }
}

class BasicPlatform extends BasePlatform {
    acquireContext(item) {
        return item && item.getContext && item.getContext('2d') || null;
    }
    updateConfig(config) {
        config.options.animation = false;
    }
}

const EXPANDO_KEY = '$chartjs';
 const EVENT_TYPES = {
    touchstart: 'mousedown',
    touchmove: 'mousemove',
    touchend: 'mouseup',
    pointerenter: 'mouseenter',
    pointerdown: 'mousedown',
    pointermove: 'mousemove',
    pointerup: 'mouseup',
    pointerleave: 'mouseout',
    pointerout: 'mouseout'
};
const isNullOrEmpty = (value)=>value === null || value === '';
 function initCanvas(canvas, aspectRatio) {
    const style = canvas.style;
    const renderHeight = canvas.getAttribute('height');
    const renderWidth = canvas.getAttribute('width');
    canvas[EXPANDO_KEY] = {
        initial: {
            height: renderHeight,
            width: renderWidth,
            style: {
                display: style.display,
                height: style.height,
                width: style.width
            }
        }
    };
    style.display = style.display || 'block';
    style.boxSizing = style.boxSizing || 'border-box';
    if (isNullOrEmpty(renderWidth)) {
        const displayWidth = helpers_dataset.readUsedSize(canvas, 'width');
        if (displayWidth !== undefined) {
            canvas.width = displayWidth;
        }
    }
    if (isNullOrEmpty(renderHeight)) {
        if (canvas.style.height === '') {
            canvas.height = canvas.width / (aspectRatio || 2);
        } else {
            const displayHeight = helpers_dataset.readUsedSize(canvas, 'height');
            if (displayHeight !== undefined) {
                canvas.height = displayHeight;
            }
        }
    }
    return canvas;
}
const eventListenerOptions = helpers_dataset.supportsEventListenerOptions ? {
    passive: true
} : false;
function addListener(node, type, listener) {
    if (node) {
        node.addEventListener(type, listener, eventListenerOptions);
    }
}
function removeListener(chart, type, listener) {
    if (chart && chart.canvas) {
        chart.canvas.removeEventListener(type, listener, eventListenerOptions);
    }
}
function fromNativeEvent(event, chart) {
    const type = EVENT_TYPES[event.type] || event.type;
    const { x , y  } = helpers_dataset.getRelativePosition(event, chart);
    return {
        type,
        chart,
        native: event,
        x: x !== undefined ? x : null,
        y: y !== undefined ? y : null
    };
}
function nodeListContains(nodeList, canvas) {
    for (const node of nodeList){
        if (node === canvas || node.contains(canvas)) {
            return true;
        }
    }
}
function createAttachObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const observer = new MutationObserver((entries)=>{
        let trigger = false;
        for (const entry of entries){
            trigger = trigger || nodeListContains(entry.addedNodes, canvas);
            trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
        }
        if (trigger) {
            listener();
        }
    });
    observer.observe(document, {
        childList: true,
        subtree: true
    });
    return observer;
}
function createDetachObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const observer = new MutationObserver((entries)=>{
        let trigger = false;
        for (const entry of entries){
            trigger = trigger || nodeListContains(entry.removedNodes, canvas);
            trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
        }
        if (trigger) {
            listener();
        }
    });
    observer.observe(document, {
        childList: true,
        subtree: true
    });
    return observer;
}
const drpListeningCharts = new Map();
let oldDevicePixelRatio = 0;
function onWindowResize() {
    const dpr = window.devicePixelRatio;
    if (dpr === oldDevicePixelRatio) {
        return;
    }
    oldDevicePixelRatio = dpr;
    drpListeningCharts.forEach((resize, chart)=>{
        if (chart.currentDevicePixelRatio !== dpr) {
            resize();
        }
    });
}
function listenDevicePixelRatioChanges(chart, resize) {
    if (!drpListeningCharts.size) {
        window.addEventListener('resize', onWindowResize);
    }
    drpListeningCharts.set(chart, resize);
}
function unlistenDevicePixelRatioChanges(chart) {
    drpListeningCharts.delete(chart);
    if (!drpListeningCharts.size) {
        window.removeEventListener('resize', onWindowResize);
    }
}
function createResizeObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const container = canvas && helpers_dataset._getParentNode(canvas);
    if (!container) {
        return;
    }
    const resize = helpers_dataset.throttled((width, height)=>{
        const w = container.clientWidth;
        listener(width, height);
        if (w < container.clientWidth) {
            listener();
        }
    }, window);
    const observer = new ResizeObserver((entries)=>{
        const entry = entries[0];
        const width = entry.contentRect.width;
        const height = entry.contentRect.height;
        if (width === 0 && height === 0) {
            return;
        }
        resize(width, height);
    });
    observer.observe(container);
    listenDevicePixelRatioChanges(chart, resize);
    return observer;
}
function releaseObserver(chart, type, observer) {
    if (observer) {
        observer.disconnect();
    }
    if (type === 'resize') {
        unlistenDevicePixelRatioChanges(chart);
    }
}
function createProxyAndListen(chart, type, listener) {
    const canvas = chart.canvas;
    const proxy = helpers_dataset.throttled((event)=>{
        if (chart.ctx !== null) {
            listener(fromNativeEvent(event, chart));
        }
    }, chart);
    addListener(canvas, type, proxy);
    return proxy;
}
 class DomPlatform extends BasePlatform {
 acquireContext(canvas, aspectRatio) {
        const context = canvas && canvas.getContext && canvas.getContext('2d');
        if (context && context.canvas === canvas) {
            initCanvas(canvas, aspectRatio);
            return context;
        }
        return null;
    }
 releaseContext(context) {
        const canvas = context.canvas;
        if (!canvas[EXPANDO_KEY]) {
            return false;
        }
        const initial = canvas[EXPANDO_KEY].initial;
        [
            'height',
            'width'
        ].forEach((prop)=>{
            const value = initial[prop];
            if (helpers_dataset.isNullOrUndef(value)) {
                canvas.removeAttribute(prop);
            } else {
                canvas.setAttribute(prop, value);
            }
        });
        const style = initial.style || {};
        Object.keys(style).forEach((key)=>{
            canvas.style[key] = style[key];
        });
        canvas.width = canvas.width;
        delete canvas[EXPANDO_KEY];
        return true;
    }
 addEventListener(chart, type, listener) {
        this.removeEventListener(chart, type);
        const proxies = chart.$proxies || (chart.$proxies = {});
        const handlers = {
            attach: createAttachObserver,
            detach: createDetachObserver,
            resize: createResizeObserver
        };
        const handler = handlers[type] || createProxyAndListen;
        proxies[type] = handler(chart, type, listener);
    }
 removeEventListener(chart, type) {
        const proxies = chart.$proxies || (chart.$proxies = {});
        const proxy = proxies[type];
        if (!proxy) {
            return;
        }
        const handlers = {
            attach: releaseObserver,
            detach: releaseObserver,
            resize: releaseObserver
        };
        const handler = handlers[type] || removeListener;
        handler(chart, type, proxy);
        proxies[type] = undefined;
    }
    getDevicePixelRatio() {
        return window.devicePixelRatio;
    }
 getMaximumSize(canvas, width, height, aspectRatio) {
        return helpers_dataset.getMaximumSize(canvas, width, height, aspectRatio);
    }
 isAttached(canvas) {
        const container = canvas && helpers_dataset._getParentNode(canvas);
        return !!(container && container.isConnected);
    }
}

function _detectPlatform(canvas) {
    if (!helpers_dataset._isDomSupported() || typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas) {
        return BasicPlatform;
    }
    return DomPlatform;
}

class Element {
    static defaults = {};
    static defaultRoutes = undefined;
    x;
    y;
    active = false;
    options;
    $animations;
    tooltipPosition(useFinalPosition) {
        const { x , y  } = this.getProps([
            'x',
            'y'
        ], useFinalPosition);
        return {
            x,
            y
        };
    }
    hasValue() {
        return helpers_dataset.isNumber(this.x) && helpers_dataset.isNumber(this.y);
    }
    getProps(props, final) {
        const anims = this.$animations;
        if (!final || !anims) {
            // let's not create an object, if not needed
            return this;
        }
        const ret = {};
        props.forEach((prop)=>{
            ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
        });
        return ret;
    }
}

function autoSkip(scale, ticks) {
    const tickOpts = scale.options.ticks;
    const determinedMaxTicks = determineMaxTicks(scale);
    const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);
    const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
    const numMajorIndices = majorIndices.length;
    const first = majorIndices[0];
    const last = majorIndices[numMajorIndices - 1];
    const newTicks = [];
    if (numMajorIndices > ticksLimit) {
        skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
        return newTicks;
    }
    const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
    if (numMajorIndices > 0) {
        let i, ilen;
        const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
        skip(ticks, newTicks, spacing, helpers_dataset.isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
        for(i = 0, ilen = numMajorIndices - 1; i < ilen; i++){
            skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
        }
        skip(ticks, newTicks, spacing, last, helpers_dataset.isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
        return newTicks;
    }
    skip(ticks, newTicks, spacing);
    return newTicks;
}
function determineMaxTicks(scale) {
    const offset = scale.options.offset;
    const tickLength = scale._tickSize();
    const maxScale = scale._length / tickLength + (offset ? 0 : 1);
    const maxChart = scale._maxLength / tickLength;
    return Math.floor(Math.min(maxScale, maxChart));
}
 function calculateSpacing(majorIndices, ticks, ticksLimit) {
    const evenMajorSpacing = getEvenSpacing(majorIndices);
    const spacing = ticks.length / ticksLimit;
    if (!evenMajorSpacing) {
        return Math.max(spacing, 1);
    }
    const factors = helpers_dataset._factorize(evenMajorSpacing);
    for(let i = 0, ilen = factors.length - 1; i < ilen; i++){
        const factor = factors[i];
        if (factor > spacing) {
            return factor;
        }
    }
    return Math.max(spacing, 1);
}
 function getMajorIndices(ticks) {
    const result = [];
    let i, ilen;
    for(i = 0, ilen = ticks.length; i < ilen; i++){
        if (ticks[i].major) {
            result.push(i);
        }
    }
    return result;
}
 function skipMajors(ticks, newTicks, majorIndices, spacing) {
    let count = 0;
    let next = majorIndices[0];
    let i;
    spacing = Math.ceil(spacing);
    for(i = 0; i < ticks.length; i++){
        if (i === next) {
            newTicks.push(ticks[i]);
            count++;
            next = majorIndices[count * spacing];
        }
    }
}
 function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
    const start = helpers_dataset.valueOrDefault(majorStart, 0);
    const end = Math.min(helpers_dataset.valueOrDefault(majorEnd, ticks.length), ticks.length);
    let count = 0;
    let length, i, next;
    spacing = Math.ceil(spacing);
    if (majorEnd) {
        length = majorEnd - majorStart;
        spacing = length / Math.floor(length / spacing);
    }
    next = start;
    while(next < 0){
        count++;
        next = Math.round(start + count * spacing);
    }
    for(i = Math.max(start, 0); i < end; i++){
        if (i === next) {
            newTicks.push(ticks[i]);
            count++;
            next = Math.round(start + count * spacing);
        }
    }
}
 function getEvenSpacing(arr) {
    const len = arr.length;
    let i, diff;
    if (len < 2) {
        return false;
    }
    for(diff = arr[0], i = 1; i < len; ++i){
        if (arr[i] - arr[i - 1] !== diff) {
            return false;
        }
    }
    return diff;
}

const reverseAlign = (align)=>align === 'left' ? 'right' : align === 'right' ? 'left' : align;
const offsetFromEdge = (scale, edge, offset)=>edge === 'top' || edge === 'left' ? scale[edge] + offset : scale[edge] - offset;
const getTicksLimit = (ticksLength, maxTicksLimit)=>Math.min(maxTicksLimit || ticksLength, ticksLength);
 function sample(arr, numItems) {
    const result = [];
    const increment = arr.length / numItems;
    const len = arr.length;
    let i = 0;
    for(; i < len; i += increment){
        result.push(arr[Math.floor(i)]);
    }
    return result;
}
 function getPixelForGridLine(scale, index, offsetGridLines) {
    const length = scale.ticks.length;
    const validIndex = Math.min(index, length - 1);
    const start = scale._startPixel;
    const end = scale._endPixel;
    const epsilon = 1e-6;
    let lineValue = scale.getPixelForTick(validIndex);
    let offset;
    if (offsetGridLines) {
        if (length === 1) {
            offset = Math.max(lineValue - start, end - lineValue);
        } else if (index === 0) {
            offset = (scale.getPixelForTick(1) - lineValue) / 2;
        } else {
            offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;
        }
        lineValue += validIndex < index ? offset : -offset;
        if (lineValue < start - epsilon || lineValue > end + epsilon) {
            return;
        }
    }
    return lineValue;
}
 function garbageCollect(caches, length) {
    helpers_dataset.each(caches, (cache)=>{
        const gc = cache.gc;
        const gcLen = gc.length / 2;
        let i;
        if (gcLen > length) {
            for(i = 0; i < gcLen; ++i){
                delete cache.data[gc[i]];
            }
            gc.splice(0, gcLen);
        }
    });
}
 function getTickMarkLength(options) {
    return options.drawTicks ? options.tickLength : 0;
}
 function getTitleHeight(options, fallback) {
    if (!options.display) {
        return 0;
    }
    const font = helpers_dataset.toFont(options.font, fallback);
    const padding = helpers_dataset.toPadding(options.padding);
    const lines = helpers_dataset.isArray(options.text) ? options.text.length : 1;
    return lines * font.lineHeight + padding.height;
}
function createScaleContext(parent, scale) {
    return helpers_dataset.createContext(parent, {
        scale,
        type: 'scale'
    });
}
function createTickContext(parent, index, tick) {
    return helpers_dataset.createContext(parent, {
        tick,
        index,
        type: 'tick'
    });
}
function titleAlign(align, position, reverse) {
     let ret = helpers_dataset._toLeftRightCenter(align);
    if (reverse && position !== 'right' || !reverse && position === 'right') {
        ret = reverseAlign(ret);
    }
    return ret;
}
function titleArgs(scale, offset, position, align) {
    const { top , left , bottom , right , chart  } = scale;
    const { chartArea , scales  } = chart;
    let rotation = 0;
    let maxWidth, titleX, titleY;
    const height = bottom - top;
    const width = right - left;
    if (scale.isHorizontal()) {
        titleX = helpers_dataset._alignStartEnd(align, left, right);
        if (helpers_dataset.isObject(position)) {
            const positionAxisID = Object.keys(position)[0];
            const value = position[positionAxisID];
            titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;
        } else if (position === 'center') {
            titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
        } else {
            titleY = offsetFromEdge(scale, position, offset);
        }
        maxWidth = right - left;
    } else {
        if (helpers_dataset.isObject(position)) {
            const positionAxisID = Object.keys(position)[0];
            const value = position[positionAxisID];
            titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;
        } else if (position === 'center') {
            titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
        } else {
            titleX = offsetFromEdge(scale, position, offset);
        }
        titleY = helpers_dataset._alignStartEnd(align, bottom, top);
        rotation = position === 'left' ? -helpers_dataset.HALF_PI : helpers_dataset.HALF_PI;
    }
    return {
        titleX,
        titleY,
        maxWidth,
        rotation
    };
}
class Scale extends Element {
    constructor(cfg){
        super();
         this.id = cfg.id;
         this.type = cfg.type;
         this.options = undefined;
         this.ctx = cfg.ctx;
         this.chart = cfg.chart;
         this.top = undefined;
         this.bottom = undefined;
         this.left = undefined;
         this.right = undefined;
         this.width = undefined;
         this.height = undefined;
        this._margins = {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
        };
         this.maxWidth = undefined;
         this.maxHeight = undefined;
         this.paddingTop = undefined;
         this.paddingBottom = undefined;
         this.paddingLeft = undefined;
         this.paddingRight = undefined;
         this.axis = undefined;
         this.labelRotation = undefined;
        this.min = undefined;
        this.max = undefined;
        this._range = undefined;
         this.ticks = [];
         this._gridLineItems = null;
         this._labelItems = null;
         this._labelSizes = null;
        this._length = 0;
        this._maxLength = 0;
        this._longestTextCache = {};
         this._startPixel = undefined;
         this._endPixel = undefined;
        this._reversePixels = false;
        this._userMax = undefined;
        this._userMin = undefined;
        this._suggestedMax = undefined;
        this._suggestedMin = undefined;
        this._ticksLength = 0;
        this._borderValue = 0;
        this._cache = {};
        this._dataLimitsCached = false;
        this.$context = undefined;
    }
 init(options) {
        this.options = options.setContext(this.getContext());
        this.axis = options.axis;
        this._userMin = this.parse(options.min);
        this._userMax = this.parse(options.max);
        this._suggestedMin = this.parse(options.suggestedMin);
        this._suggestedMax = this.parse(options.suggestedMax);
    }
 parse(raw, index) {
        return raw;
    }
 getUserBounds() {
        let { _userMin , _userMax , _suggestedMin , _suggestedMax  } = this;
        _userMin = helpers_dataset.finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
        _userMax = helpers_dataset.finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
        _suggestedMin = helpers_dataset.finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
        _suggestedMax = helpers_dataset.finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
        return {
            min: helpers_dataset.finiteOrDefault(_userMin, _suggestedMin),
            max: helpers_dataset.finiteOrDefault(_userMax, _suggestedMax),
            minDefined: helpers_dataset.isNumberFinite(_userMin),
            maxDefined: helpers_dataset.isNumberFinite(_userMax)
        };
    }
 getMinMax(canStack) {
        let { min , max , minDefined , maxDefined  } = this.getUserBounds();
        let range;
        if (minDefined && maxDefined) {
            return {
                min,
                max
            };
        }
        const metas = this.getMatchingVisibleMetas();
        for(let i = 0, ilen = metas.length; i < ilen; ++i){
            range = metas[i].controller.getMinMax(this, canStack);
            if (!minDefined) {
                min = Math.min(min, range.min);
            }
            if (!maxDefined) {
                max = Math.max(max, range.max);
            }
        }
        min = maxDefined && min > max ? max : min;
        max = minDefined && min > max ? min : max;
        return {
            min: helpers_dataset.finiteOrDefault(min, helpers_dataset.finiteOrDefault(max, min)),
            max: helpers_dataset.finiteOrDefault(max, helpers_dataset.finiteOrDefault(min, max))
        };
    }
 getPadding() {
        return {
            left: this.paddingLeft || 0,
            top: this.paddingTop || 0,
            right: this.paddingRight || 0,
            bottom: this.paddingBottom || 0
        };
    }
 getTicks() {
        return this.ticks;
    }
 getLabels() {
        const data = this.chart.data;
        return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
    }
 getLabelItems(chartArea = this.chart.chartArea) {
        const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
        return items;
    }
    beforeLayout() {
        this._cache = {};
        this._dataLimitsCached = false;
    }
    beforeUpdate() {
        helpers_dataset.callback(this.options.beforeUpdate, [
            this
        ]);
    }
 update(maxWidth, maxHeight, margins) {
        const { beginAtZero , grace , ticks: tickOpts  } = this.options;
        const sampleSize = tickOpts.sampleSize;
        this.beforeUpdate();
        this.maxWidth = maxWidth;
        this.maxHeight = maxHeight;
        this._margins = margins = Object.assign({
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
        }, margins);
        this.ticks = null;
        this._labelSizes = null;
        this._gridLineItems = null;
        this._labelItems = null;
        this.beforeSetDimensions();
        this.setDimensions();
        this.afterSetDimensions();
        this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
        if (!this._dataLimitsCached) {
            this.beforeDataLimits();
            this.determineDataLimits();
            this.afterDataLimits();
            this._range = helpers_dataset._addGrace(this, grace, beginAtZero);
            this._dataLimitsCached = true;
        }
        this.beforeBuildTicks();
        this.ticks = this.buildTicks() || [];
        this.afterBuildTicks();
        const samplingEnabled = sampleSize < this.ticks.length;
        this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
        this.configure();
        this.beforeCalculateLabelRotation();
        this.calculateLabelRotation();
        this.afterCalculateLabelRotation();
        if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === 'auto')) {
            this.ticks = autoSkip(this, this.ticks);
            this._labelSizes = null;
            this.afterAutoSkip();
        }
        if (samplingEnabled) {
            this._convertTicksToLabels(this.ticks);
        }
        this.beforeFit();
        this.fit();
        this.afterFit();
        this.afterUpdate();
    }
 configure() {
        let reversePixels = this.options.reverse;
        let startPixel, endPixel;
        if (this.isHorizontal()) {
            startPixel = this.left;
            endPixel = this.right;
        } else {
            startPixel = this.top;
            endPixel = this.bottom;
            reversePixels = !reversePixels;
        }
        this._startPixel = startPixel;
        this._endPixel = endPixel;
        this._reversePixels = reversePixels;
        this._length = endPixel - startPixel;
        this._alignToPixels = this.options.alignToPixels;
    }
    afterUpdate() {
        helpers_dataset.callback(this.options.afterUpdate, [
            this
        ]);
    }
    beforeSetDimensions() {
        helpers_dataset.callback(this.options.beforeSetDimensions, [
            this
        ]);
    }
    setDimensions() {
        if (this.isHorizontal()) {
            this.width = this.maxWidth;
            this.left = 0;
            this.right = this.width;
        } else {
            this.height = this.maxHeight;
            this.top = 0;
            this.bottom = this.height;
        }
        this.paddingLeft = 0;
        this.paddingTop = 0;
        this.paddingRight = 0;
        this.paddingBottom = 0;
    }
    afterSetDimensions() {
        helpers_dataset.callback(this.options.afterSetDimensions, [
            this
        ]);
    }
    _callHooks(name) {
        this.chart.notifyPlugins(name, this.getContext());
        helpers_dataset.callback(this.options[name], [
            this
        ]);
    }
    beforeDataLimits() {
        this._callHooks('beforeDataLimits');
    }
    determineDataLimits() {}
    afterDataLimits() {
        this._callHooks('afterDataLimits');
    }
    beforeBuildTicks() {
        this._callHooks('beforeBuildTicks');
    }
 buildTicks() {
        return [];
    }
    afterBuildTicks() {
        this._callHooks('afterBuildTicks');
    }
    beforeTickToLabelConversion() {
        helpers_dataset.callback(this.options.beforeTickToLabelConversion, [
            this
        ]);
    }
 generateTickLabels(ticks) {
        const tickOpts = this.options.ticks;
        let i, ilen, tick;
        for(i = 0, ilen = ticks.length; i < ilen; i++){
            tick = ticks[i];
            tick.label = helpers_dataset.callback(tickOpts.callback, [
                tick.value,
                i,
                ticks
            ], this);
        }
    }
    afterTickToLabelConversion() {
        helpers_dataset.callback(this.options.afterTickToLabelConversion, [
            this
        ]);
    }
    beforeCalculateLabelRotation() {
        helpers_dataset.callback(this.options.beforeCalculateLabelRotation, [
            this
        ]);
    }
    calculateLabelRotation() {
        const options = this.options;
        const tickOpts = options.ticks;
        const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);
        const minRotation = tickOpts.minRotation || 0;
        const maxRotation = tickOpts.maxRotation;
        let labelRotation = minRotation;
        let tickWidth, maxHeight, maxLabelDiagonal;
        if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
            this.labelRotation = minRotation;
            return;
        }
        const labelSizes = this._getLabelSizes();
        const maxLabelWidth = labelSizes.widest.width;
        const maxLabelHeight = labelSizes.highest.height;
        const maxWidth = helpers_dataset._limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
        tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
        if (maxLabelWidth + 6 > tickWidth) {
            tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
            maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
            maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
            labelRotation = helpers_dataset.toDegrees(Math.min(Math.asin(helpers_dataset._limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(helpers_dataset._limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(helpers_dataset._limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
            labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
        }
        this.labelRotation = labelRotation;
    }
    afterCalculateLabelRotation() {
        helpers_dataset.callback(this.options.afterCalculateLabelRotation, [
            this
        ]);
    }
    afterAutoSkip() {}
    beforeFit() {
        helpers_dataset.callback(this.options.beforeFit, [
            this
        ]);
    }
    fit() {
        const minSize = {
            width: 0,
            height: 0
        };
        const { chart , options: { ticks: tickOpts , title: titleOpts , grid: gridOpts  }  } = this;
        const display = this._isVisible();
        const isHorizontal = this.isHorizontal();
        if (display) {
            const titleHeight = getTitleHeight(titleOpts, chart.options.font);
            if (isHorizontal) {
                minSize.width = this.maxWidth;
                minSize.height = getTickMarkLength(gridOpts) + titleHeight;
            } else {
                minSize.height = this.maxHeight;
                minSize.width = getTickMarkLength(gridOpts) + titleHeight;
            }
            if (tickOpts.display && this.ticks.length) {
                const { first , last , widest , highest  } = this._getLabelSizes();
                const tickPadding = tickOpts.padding * 2;
                const angleRadians = helpers_dataset.toRadians(this.labelRotation);
                const cos = Math.cos(angleRadians);
                const sin = Math.sin(angleRadians);
                if (isHorizontal) {
                    const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
                    minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
                } else {
                    const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
                    minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
                }
                this._calculatePadding(first, last, sin, cos);
            }
        }
        this._handleMargins();
        if (isHorizontal) {
            this.width = this._length = chart.width - this._margins.left - this._margins.right;
            this.height = minSize.height;
        } else {
            this.width = minSize.width;
            this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
        }
    }
    _calculatePadding(first, last, sin, cos) {
        const { ticks: { align , padding  } , position  } = this.options;
        const isRotated = this.labelRotation !== 0;
        const labelsBelowTicks = position !== 'top' && this.axis === 'x';
        if (this.isHorizontal()) {
            const offsetLeft = this.getPixelForTick(0) - this.left;
            const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
            let paddingLeft = 0;
            let paddingRight = 0;
            if (isRotated) {
                if (labelsBelowTicks) {
                    paddingLeft = cos * first.width;
                    paddingRight = sin * last.height;
                } else {
                    paddingLeft = sin * first.height;
                    paddingRight = cos * last.width;
                }
            } else if (align === 'start') {
                paddingRight = last.width;
            } else if (align === 'end') {
                paddingLeft = first.width;
            } else if (align !== 'inner') {
                paddingLeft = first.width / 2;
                paddingRight = last.width / 2;
            }
            this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
            this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
        } else {
            let paddingTop = last.height / 2;
            let paddingBottom = first.height / 2;
            if (align === 'start') {
                paddingTop = 0;
                paddingBottom = first.height;
            } else if (align === 'end') {
                paddingTop = last.height;
                paddingBottom = 0;
            }
            this.paddingTop = paddingTop + padding;
            this.paddingBottom = paddingBottom + padding;
        }
    }
 _handleMargins() {
        if (this._margins) {
            this._margins.left = Math.max(this.paddingLeft, this._margins.left);
            this._margins.top = Math.max(this.paddingTop, this._margins.top);
            this._margins.right = Math.max(this.paddingRight, this._margins.right);
            this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
        }
    }
    afterFit() {
        helpers_dataset.callback(this.options.afterFit, [
            this
        ]);
    }
 isHorizontal() {
        const { axis , position  } = this.options;
        return position === 'top' || position === 'bottom' || axis === 'x';
    }
 isFullSize() {
        return this.options.fullSize;
    }
 _convertTicksToLabels(ticks) {
        this.beforeTickToLabelConversion();
        this.generateTickLabels(ticks);
        let i, ilen;
        for(i = 0, ilen = ticks.length; i < ilen; i++){
            if (helpers_dataset.isNullOrUndef(ticks[i].label)) {
                ticks.splice(i, 1);
                ilen--;
                i--;
            }
        }
        this.afterTickToLabelConversion();
    }
 _getLabelSizes() {
        let labelSizes = this._labelSizes;
        if (!labelSizes) {
            const sampleSize = this.options.ticks.sampleSize;
            let ticks = this.ticks;
            if (sampleSize < ticks.length) {
                ticks = sample(ticks, sampleSize);
            }
            this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);
        }
        return labelSizes;
    }
 _computeLabelSizes(ticks, length, maxTicksLimit) {
        const { ctx , _longestTextCache: caches  } = this;
        const widths = [];
        const heights = [];
        const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));
        let widestLabelSize = 0;
        let highestLabelSize = 0;
        let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;
        for(i = 0; i < length; i += increment){
            label = ticks[i].label;
            tickFont = this._resolveTickFontOptions(i);
            ctx.font = fontString = tickFont.string;
            cache = caches[fontString] = caches[fontString] || {
                data: {},
                gc: []
            };
            lineHeight = tickFont.lineHeight;
            width = height = 0;
            if (!helpers_dataset.isNullOrUndef(label) && !helpers_dataset.isArray(label)) {
                width = helpers_dataset._measureText(ctx, cache.data, cache.gc, width, label);
                height = lineHeight;
            } else if (helpers_dataset.isArray(label)) {
                for(j = 0, jlen = label.length; j < jlen; ++j){
                    nestedLabel =  label[j];
                    if (!helpers_dataset.isNullOrUndef(nestedLabel) && !helpers_dataset.isArray(nestedLabel)) {
                        width = helpers_dataset._measureText(ctx, cache.data, cache.gc, width, nestedLabel);
                        height += lineHeight;
                    }
                }
            }
            widths.push(width);
            heights.push(height);
            widestLabelSize = Math.max(width, widestLabelSize);
            highestLabelSize = Math.max(height, highestLabelSize);
        }
        garbageCollect(caches, length);
        const widest = widths.indexOf(widestLabelSize);
        const highest = heights.indexOf(highestLabelSize);
        const valueAt = (idx)=>({
                width: widths[idx] || 0,
                height: heights[idx] || 0
            });
        return {
            first: valueAt(0),
            last: valueAt(length - 1),
            widest: valueAt(widest),
            highest: valueAt(highest),
            widths,
            heights
        };
    }
 getLabelForValue(value) {
        return value;
    }
 getPixelForValue(value, index) {
        return NaN;
    }
 getValueForPixel(pixel) {}
 getPixelForTick(index) {
        const ticks = this.ticks;
        if (index < 0 || index > ticks.length - 1) {
            return null;
        }
        return this.getPixelForValue(ticks[index].value);
    }
 getPixelForDecimal(decimal) {
        if (this._reversePixels) {
            decimal = 1 - decimal;
        }
        const pixel = this._startPixel + decimal * this._length;
        return helpers_dataset._int16Range(this._alignToPixels ? helpers_dataset._alignPixel(this.chart, pixel, 0) : pixel);
    }
 getDecimalForPixel(pixel) {
        const decimal = (pixel - this._startPixel) / this._length;
        return this._reversePixels ? 1 - decimal : decimal;
    }
 getBasePixel() {
        return this.getPixelForValue(this.getBaseValue());
    }
 getBaseValue() {
        const { min , max  } = this;
        return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
    }
 getContext(index) {
        const ticks = this.ticks || [];
        if (index >= 0 && index < ticks.length) {
            const tick = ticks[index];
            return tick.$context || (tick.$context = createTickContext(this.getContext(), index, tick));
        }
        return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
    }
 _tickSize() {
        const optionTicks = this.options.ticks;
        const rot = helpers_dataset.toRadians(this.labelRotation);
        const cos = Math.abs(Math.cos(rot));
        const sin = Math.abs(Math.sin(rot));
        const labelSizes = this._getLabelSizes();
        const padding = optionTicks.autoSkipPadding || 0;
        const w = labelSizes ? labelSizes.widest.width + padding : 0;
        const h = labelSizes ? labelSizes.highest.height + padding : 0;
        return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
    }
 _isVisible() {
        const display = this.options.display;
        if (display !== 'auto') {
            return !!display;
        }
        return this.getMatchingVisibleMetas().length > 0;
    }
 _computeGridLineItems(chartArea) {
        const axis = this.axis;
        const chart = this.chart;
        const options = this.options;
        const { grid , position , border  } = options;
        const offset = grid.offset;
        const isHorizontal = this.isHorizontal();
        const ticks = this.ticks;
        const ticksLength = ticks.length + (offset ? 1 : 0);
        const tl = getTickMarkLength(grid);
        const items = [];
        const borderOpts = border.setContext(this.getContext());
        const axisWidth = borderOpts.display ? borderOpts.width : 0;
        const axisHalfWidth = axisWidth / 2;
        const alignBorderValue = function(pixel) {
            return helpers_dataset._alignPixel(chart, pixel, axisWidth);
        };
        let borderValue, i, lineValue, alignedLineValue;
        let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
        if (position === 'top') {
            borderValue = alignBorderValue(this.bottom);
            ty1 = this.bottom - tl;
            ty2 = borderValue - axisHalfWidth;
            y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
            y2 = chartArea.bottom;
        } else if (position === 'bottom') {
            borderValue = alignBorderValue(this.top);
            y1 = chartArea.top;
            y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
            ty1 = borderValue + axisHalfWidth;
            ty2 = this.top + tl;
        } else if (position === 'left') {
            borderValue = alignBorderValue(this.right);
            tx1 = this.right - tl;
            tx2 = borderValue - axisHalfWidth;
            x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
            x2 = chartArea.right;
        } else if (position === 'right') {
            borderValue = alignBorderValue(this.left);
            x1 = chartArea.left;
            x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
            tx1 = borderValue + axisHalfWidth;
            tx2 = this.left + tl;
        } else if (axis === 'x') {
            if (position === 'center') {
                borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
            } else if (helpers_dataset.isObject(position)) {
                const positionAxisID = Object.keys(position)[0];
                const value = position[positionAxisID];
                borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
            }
            y1 = chartArea.top;
            y2 = chartArea.bottom;
            ty1 = borderValue + axisHalfWidth;
            ty2 = ty1 + tl;
        } else if (axis === 'y') {
            if (position === 'center') {
                borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
            } else if (helpers_dataset.isObject(position)) {
                const positionAxisID = Object.keys(position)[0];
                const value = position[positionAxisID];
                borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
            }
            tx1 = borderValue - axisHalfWidth;
            tx2 = tx1 - tl;
            x1 = chartArea.left;
            x2 = chartArea.right;
        }
        const limit = helpers_dataset.valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
        const step = Math.max(1, Math.ceil(ticksLength / limit));
        for(i = 0; i < ticksLength; i += step){
            const context = this.getContext(i);
            const optsAtIndex = grid.setContext(context);
            const optsAtIndexBorder = border.setContext(context);
            const lineWidth = optsAtIndex.lineWidth;
            const lineColor = optsAtIndex.color;
            const borderDash = optsAtIndexBorder.dash || [];
            const borderDashOffset = optsAtIndexBorder.dashOffset;
            const tickWidth = optsAtIndex.tickWidth;
            const tickColor = optsAtIndex.tickColor;
            const tickBorderDash = optsAtIndex.tickBorderDash || [];
            const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
            lineValue = getPixelForGridLine(this, i, offset);
            if (lineValue === undefined) {
                continue;
            }
            alignedLineValue = helpers_dataset._alignPixel(chart, lineValue, lineWidth);
            if (isHorizontal) {
                tx1 = tx2 = x1 = x2 = alignedLineValue;
            } else {
                ty1 = ty2 = y1 = y2 = alignedLineValue;
            }
            items.push({
                tx1,
                ty1,
                tx2,
                ty2,
                x1,
                y1,
                x2,
                y2,
                width: lineWidth,
                color: lineColor,
                borderDash,
                borderDashOffset,
                tickWidth,
                tickColor,
                tickBorderDash,
                tickBorderDashOffset
            });
        }
        this._ticksLength = ticksLength;
        this._borderValue = borderValue;
        return items;
    }
 _computeLabelItems(chartArea) {
        const axis = this.axis;
        const options = this.options;
        const { position , ticks: optionTicks  } = options;
        const isHorizontal = this.isHorizontal();
        const ticks = this.ticks;
        const { align , crossAlign , padding , mirror  } = optionTicks;
        const tl = getTickMarkLength(options.grid);
        const tickAndPadding = tl + padding;
        const hTickAndPadding = mirror ? -padding : tickAndPadding;
        const rotation = -helpers_dataset.toRadians(this.labelRotation);
        const items = [];
        let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
        let textBaseline = 'middle';
        if (position === 'top') {
            y = this.bottom - hTickAndPadding;
            textAlign = this._getXAxisLabelAlignment();
        } else if (position === 'bottom') {
            y = this.top + hTickAndPadding;
            textAlign = this._getXAxisLabelAlignment();
        } else if (position === 'left') {
            const ret = this._getYAxisLabelAlignment(tl);
            textAlign = ret.textAlign;
            x = ret.x;
        } else if (position === 'right') {
            const ret = this._getYAxisLabelAlignment(tl);
            textAlign = ret.textAlign;
            x = ret.x;
        } else if (axis === 'x') {
            if (position === 'center') {
                y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
            } else if (helpers_dataset.isObject(position)) {
                const positionAxisID = Object.keys(position)[0];
                const value = position[positionAxisID];
                y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
            }
            textAlign = this._getXAxisLabelAlignment();
        } else if (axis === 'y') {
            if (position === 'center') {
                x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
            } else if (helpers_dataset.isObject(position)) {
                const positionAxisID = Object.keys(position)[0];
                const value = position[positionAxisID];
                x = this.chart.scales[positionAxisID].getPixelForValue(value);
            }
            textAlign = this._getYAxisLabelAlignment(tl).textAlign;
        }
        if (axis === 'y') {
            if (align === 'start') {
                textBaseline = 'top';
            } else if (align === 'end') {
                textBaseline = 'bottom';
            }
        }
        const labelSizes = this._getLabelSizes();
        for(i = 0, ilen = ticks.length; i < ilen; ++i){
            tick = ticks[i];
            label = tick.label;
            const optsAtIndex = optionTicks.setContext(this.getContext(i));
            pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
            font = this._resolveTickFontOptions(i);
            lineHeight = font.lineHeight;
            lineCount = helpers_dataset.isArray(label) ? label.length : 1;
            const halfCount = lineCount / 2;
            const color = optsAtIndex.color;
            const strokeColor = optsAtIndex.textStrokeColor;
            const strokeWidth = optsAtIndex.textStrokeWidth;
            let tickTextAlign = textAlign;
            if (isHorizontal) {
                x = pixel;
                if (textAlign === 'inner') {
                    if (i === ilen - 1) {
                        tickTextAlign = !this.options.reverse ? 'right' : 'left';
                    } else if (i === 0) {
                        tickTextAlign = !this.options.reverse ? 'left' : 'right';
                    } else {
                        tickTextAlign = 'center';
                    }
                }
                if (position === 'top') {
                    if (crossAlign === 'near' || rotation !== 0) {
                        textOffset = -lineCount * lineHeight + lineHeight / 2;
                    } else if (crossAlign === 'center') {
                        textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
                    } else {
                        textOffset = -labelSizes.highest.height + lineHeight / 2;
                    }
                } else {
                    if (crossAlign === 'near' || rotation !== 0) {
                        textOffset = lineHeight / 2;
                    } else if (crossAlign === 'center') {
                        textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
                    } else {
                        textOffset = labelSizes.highest.height - lineCount * lineHeight;
                    }
                }
                if (mirror) {
                    textOffset *= -1;
                }
                if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {
                    x += lineHeight / 2 * Math.sin(rotation);
                }
            } else {
                y = pixel;
                textOffset = (1 - lineCount) * lineHeight / 2;
            }
            let backdrop;
            if (optsAtIndex.showLabelBackdrop) {
                const labelPadding = helpers_dataset.toPadding(optsAtIndex.backdropPadding);
                const height = labelSizes.heights[i];
                const width = labelSizes.widths[i];
                let top = textOffset - labelPadding.top;
                let left = 0 - labelPadding.left;
                switch(textBaseline){
                    case 'middle':
                        top -= height / 2;
                        break;
                    case 'bottom':
                        top -= height;
                        break;
                }
                switch(textAlign){
                    case 'center':
                        left -= width / 2;
                        break;
                    case 'right':
                        left -= width;
                        break;
                    case 'inner':
                        if (i === ilen - 1) {
                            left -= width;
                        } else if (i > 0) {
                            left -= width / 2;
                        }
                        break;
                }
                backdrop = {
                    left,
                    top,
                    width: width + labelPadding.width,
                    height: height + labelPadding.height,
                    color: optsAtIndex.backdropColor
                };
            }
            items.push({
                label,
                font,
                textOffset,
                options: {
                    rotation,
                    color,
                    strokeColor,
                    strokeWidth,
                    textAlign: tickTextAlign,
                    textBaseline,
                    translation: [
                        x,
                        y
                    ],
                    backdrop
                }
            });
        }
        return items;
    }
    _getXAxisLabelAlignment() {
        const { position , ticks  } = this.options;
        const rotation = -helpers_dataset.toRadians(this.labelRotation);
        if (rotation) {
            return position === 'top' ? 'left' : 'right';
        }
        let align = 'center';
        if (ticks.align === 'start') {
            align = 'left';
        } else if (ticks.align === 'end') {
            align = 'right';
        } else if (ticks.align === 'inner') {
            align = 'inner';
        }
        return align;
    }
    _getYAxisLabelAlignment(tl) {
        const { position , ticks: { crossAlign , mirror , padding  }  } = this.options;
        const labelSizes = this._getLabelSizes();
        const tickAndPadding = tl + padding;
        const widest = labelSizes.widest.width;
        let textAlign;
        let x;
        if (position === 'left') {
            if (mirror) {
                x = this.right + padding;
                if (crossAlign === 'near') {
                    textAlign = 'left';
                } else if (crossAlign === 'center') {
                    textAlign = 'center';
                    x += widest / 2;
                } else {
                    textAlign = 'right';
                    x += widest;
                }
            } else {
                x = this.right - tickAndPadding;
                if (crossAlign === 'near') {
                    textAlign = 'right';
                } else if (crossAlign === 'center') {
                    textAlign = 'center';
                    x -= widest / 2;
                } else {
                    textAlign = 'left';
                    x = this.left;
                }
            }
        } else if (position === 'right') {
            if (mirror) {
                x = this.left + padding;
                if (crossAlign === 'near') {
                    textAlign = 'right';
                } else if (crossAlign === 'center') {
                    textAlign = 'center';
                    x -= widest / 2;
                } else {
                    textAlign = 'left';
                    x -= widest;
                }
            } else {
                x = this.left + tickAndPadding;
                if (crossAlign === 'near') {
                    textAlign = 'left';
                } else if (crossAlign === 'center') {
                    textAlign = 'center';
                    x += widest / 2;
                } else {
                    textAlign = 'right';
                    x = this.right;
                }
            }
        } else {
            textAlign = 'right';
        }
        return {
            textAlign,
            x
        };
    }
 _computeLabelArea() {
        if (this.options.ticks.mirror) {
            return;
        }
        const chart = this.chart;
        const position = this.options.position;
        if (position === 'left' || position === 'right') {
            return {
                top: 0,
                left: this.left,
                bottom: chart.height,
                right: this.right
            };
        }
        if (position === 'top' || position === 'bottom') {
            return {
                top: this.top,
                left: 0,
                bottom: this.bottom,
                right: chart.width
            };
        }
    }
 drawBackground() {
        const { ctx , options: { backgroundColor  } , left , top , width , height  } = this;
        if (backgroundColor) {
            ctx.save();
            ctx.fillStyle = backgroundColor;
            ctx.fillRect(left, top, width, height);
            ctx.restore();
        }
    }
    getLineWidthForValue(value) {
        const grid = this.options.grid;
        if (!this._isVisible() || !grid.display) {
            return 0;
        }
        const ticks = this.ticks;
        const index = ticks.findIndex((t)=>t.value === value);
        if (index >= 0) {
            const opts = grid.setContext(this.getContext(index));
            return opts.lineWidth;
        }
        return 0;
    }
 drawGrid(chartArea) {
        const grid = this.options.grid;
        const ctx = this.ctx;
        const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
        let i, ilen;
        const drawLine = (p1, p2, style)=>{
            if (!style.width || !style.color) {
                return;
            }
            ctx.save();
            ctx.lineWidth = style.width;
            ctx.strokeStyle = style.color;
            ctx.setLineDash(style.borderDash || []);
            ctx.lineDashOffset = style.borderDashOffset;
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
            ctx.restore();
        };
        if (grid.display) {
            for(i = 0, ilen = items.length; i < ilen; ++i){
                const item = items[i];
                if (grid.drawOnChartArea) {
                    drawLine({
                        x: item.x1,
                        y: item.y1
                    }, {
                        x: item.x2,
                        y: item.y2
                    }, item);
                }
                if (grid.drawTicks) {
                    drawLine({
                        x: item.tx1,
                        y: item.ty1
                    }, {
                        x: item.tx2,
                        y: item.ty2
                    }, {
                        color: item.tickColor,
                        width: item.tickWidth,
                        borderDash: item.tickBorderDash,
                        borderDashOffset: item.tickBorderDashOffset
                    });
                }
            }
        }
    }
 drawBorder() {
        const { chart , ctx , options: { border , grid  }  } = this;
        const borderOpts = border.setContext(this.getContext());
        const axisWidth = border.display ? borderOpts.width : 0;
        if (!axisWidth) {
            return;
        }
        const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
        const borderValue = this._borderValue;
        let x1, x2, y1, y2;
        if (this.isHorizontal()) {
            x1 = helpers_dataset._alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
            x2 = helpers_dataset._alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
            y1 = y2 = borderValue;
        } else {
            y1 = helpers_dataset._alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
            y2 = helpers_dataset._alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
            x1 = x2 = borderValue;
        }
        ctx.save();
        ctx.lineWidth = borderOpts.width;
        ctx.strokeStyle = borderOpts.color;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
        ctx.restore();
    }
 drawLabels(chartArea) {
        const optionTicks = this.options.ticks;
        if (!optionTicks.display) {
            return;
        }
        const ctx = this.ctx;
        const area = this._computeLabelArea();
        if (area) {
            helpers_dataset.clipArea(ctx, area);
        }
        const items = this.getLabelItems(chartArea);
        for (const item of items){
            const renderTextOptions = item.options;
            const tickFont = item.font;
            const label = item.label;
            const y = item.textOffset;
            helpers_dataset.renderText(ctx, label, 0, y, tickFont, renderTextOptions);
        }
        if (area) {
            helpers_dataset.unclipArea(ctx);
        }
    }
 drawTitle() {
        const { ctx , options: { position , title , reverse  }  } = this;
        if (!title.display) {
            return;
        }
        const font = helpers_dataset.toFont(title.font);
        const padding = helpers_dataset.toPadding(title.padding);
        const align = title.align;
        let offset = font.lineHeight / 2;
        if (position === 'bottom' || position === 'center' || helpers_dataset.isObject(position)) {
            offset += padding.bottom;
            if (helpers_dataset.isArray(title.text)) {
                offset += font.lineHeight * (title.text.length - 1);
            }
        } else {
            offset += padding.top;
        }
        const { titleX , titleY , maxWidth , rotation  } = titleArgs(this, offset, position, align);
        helpers_dataset.renderText(ctx, title.text, 0, 0, font, {
            color: title.color,
            maxWidth,
            rotation,
            textAlign: titleAlign(align, position, reverse),
            textBaseline: 'middle',
            translation: [
                titleX,
                titleY
            ]
        });
    }
    draw(chartArea) {
        if (!this._isVisible()) {
            return;
        }
        this.drawBackground();
        this.drawGrid(chartArea);
        this.drawBorder();
        this.drawTitle();
        this.drawLabels(chartArea);
    }
 _layers() {
        const opts = this.options;
        const tz = opts.ticks && opts.ticks.z || 0;
        const gz = helpers_dataset.valueOrDefault(opts.grid && opts.grid.z, -1);
        const bz = helpers_dataset.valueOrDefault(opts.border && opts.border.z, 0);
        if (!this._isVisible() || this.draw !== Scale.prototype.draw) {
            return [
                {
                    z: tz,
                    draw: (chartArea)=>{
                        this.draw(chartArea);
                    }
                }
            ];
        }
        return [
            {
                z: gz,
                draw: (chartArea)=>{
                    this.drawBackground();
                    this.drawGrid(chartArea);
                    this.drawTitle();
                }
            },
            {
                z: bz,
                draw: ()=>{
                    this.drawBorder();
                }
            },
            {
                z: tz,
                draw: (chartArea)=>{
                    this.drawLabels(chartArea);
                }
            }
        ];
    }
 getMatchingVisibleMetas(type) {
        const metas = this.chart.getSortedVisibleDatasetMetas();
        const axisID = this.axis + 'AxisID';
        const result = [];
        let i, ilen;
        for(i = 0, ilen = metas.length; i < ilen; ++i){
            const meta = metas[i];
            if (meta[axisID] === this.id && (!type || meta.type === type)) {
                result.push(meta);
            }
        }
        return result;
    }
 _resolveTickFontOptions(index) {
        const opts = this.options.ticks.setContext(this.getContext(index));
        return helpers_dataset.toFont(opts.font);
    }
 _maxDigits() {
        const fontSize = this._resolveTickFontOptions(0).lineHeight;
        return (this.isHorizontal() ? this.width : this.height) / fontSize;
    }
}

class TypedRegistry {
    constructor(type, scope, override){
        this.type = type;
        this.scope = scope;
        this.override = override;
        this.items = Object.create(null);
    }
    isForType(type) {
        return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
    }
 register(item) {
        const proto = Object.getPrototypeOf(item);
        let parentScope;
        if (isIChartComponent(proto)) {
            parentScope = this.register(proto);
        }
        const items = this.items;
        const id = item.id;
        const scope = this.scope + '.' + id;
        if (!id) {
            throw new Error('class does not have id: ' + item);
        }
        if (id in items) {
            return scope;
        }
        items[id] = item;
        registerDefaults(item, scope, parentScope);
        if (this.override) {
            helpers_dataset.defaults.override(item.id, item.overrides);
        }
        return scope;
    }
 get(id) {
        return this.items[id];
    }
 unregister(item) {
        const items = this.items;
        const id = item.id;
        const scope = this.scope;
        if (id in items) {
            delete items[id];
        }
        if (scope && id in helpers_dataset.defaults[scope]) {
            delete helpers_dataset.defaults[scope][id];
            if (this.override) {
                delete helpers_dataset.overrides[id];
            }
        }
    }
}
function registerDefaults(item, scope, parentScope) {
    const itemDefaults = helpers_dataset.merge(Object.create(null), [
        parentScope ? helpers_dataset.defaults.get(parentScope) : {},
        helpers_dataset.defaults.get(scope),
        item.defaults
    ]);
    helpers_dataset.defaults.set(scope, itemDefaults);
    if (item.defaultRoutes) {
        routeDefaults(scope, item.defaultRoutes);
    }
    if (item.descriptors) {
        helpers_dataset.defaults.describe(scope, item.descriptors);
    }
}
function routeDefaults(scope, routes) {
    Object.keys(routes).forEach((property)=>{
        const propertyParts = property.split('.');
        const sourceName = propertyParts.pop();
        const sourceScope = [
            scope
        ].concat(propertyParts).join('.');
        const parts = routes[property].split('.');
        const targetName = parts.pop();
        const targetScope = parts.join('.');
        helpers_dataset.defaults.route(sourceScope, sourceName, targetScope, targetName);
    });
}
function isIChartComponent(proto) {
    return 'id' in proto && 'defaults' in proto;
}

class Registry {
    constructor(){
        this.controllers = new TypedRegistry(DatasetController, 'datasets', true);
        this.elements = new TypedRegistry(Element, 'elements');
        this.plugins = new TypedRegistry(Object, 'plugins');
        this.scales = new TypedRegistry(Scale, 'scales');
        this._typedRegistries = [
            this.controllers,
            this.scales,
            this.elements
        ];
    }
 add(...args) {
        this._each('register', args);
    }
    remove(...args) {
        this._each('unregister', args);
    }
 addControllers(...args) {
        this._each('register', args, this.controllers);
    }
 addElements(...args) {
        this._each('register', args, this.elements);
    }
 addPlugins(...args) {
        this._each('register', args, this.plugins);
    }
 addScales(...args) {
        this._each('register', args, this.scales);
    }
 getController(id) {
        return this._get(id, this.controllers, 'controller');
    }
 getElement(id) {
        return this._get(id, this.elements, 'element');
    }
 getPlugin(id) {
        return this._get(id, this.plugins, 'plugin');
    }
 getScale(id) {
        return this._get(id, this.scales, 'scale');
    }
 removeControllers(...args) {
        this._each('unregister', args, this.controllers);
    }
 removeElements(...args) {
        this._each('unregister', args, this.elements);
    }
 removePlugins(...args) {
        this._each('unregister', args, this.plugins);
    }
 removeScales(...args) {
        this._each('unregister', args, this.scales);
    }
 _each(method, args, typedRegistry) {
        [
            ...args
        ].forEach((arg)=>{
            const reg = typedRegistry || this._getRegistryForType(arg);
            if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
                this._exec(method, reg, arg);
            } else {
                helpers_dataset.each(arg, (item)=>{
                    const itemReg = typedRegistry || this._getRegistryForType(item);
                    this._exec(method, itemReg, item);
                });
            }
        });
    }
 _exec(method, registry, component) {
        const camelMethod = helpers_dataset._capitalize(method);
        helpers_dataset.callback(component['before' + camelMethod], [], component);
        registry[method](component);
        helpers_dataset.callback(component['after' + camelMethod], [], component);
    }
 _getRegistryForType(type) {
        for(let i = 0; i < this._typedRegistries.length; i++){
            const reg = this._typedRegistries[i];
            if (reg.isForType(type)) {
                return reg;
            }
        }
        return this.plugins;
    }
 _get(id, typedRegistry, type) {
        const item = typedRegistry.get(id);
        if (item === undefined) {
            throw new Error('"' + id + '" is not a registered ' + type + '.');
        }
        return item;
    }
}
var registry = /* #__PURE__ */ new Registry();

class PluginService {
    constructor(){
        this._init = [];
    }
 notify(chart, hook, args, filter) {
        if (hook === 'beforeInit') {
            this._init = this._createDescriptors(chart, true);
            this._notify(this._init, chart, 'install');
        }
        const descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
        const result = this._notify(descriptors, chart, hook, args);
        if (hook === 'afterDestroy') {
            this._notify(descriptors, chart, 'stop');
            this._notify(this._init, chart, 'uninstall');
        }
        return result;
    }
 _notify(descriptors, chart, hook, args) {
        args = args || {};
        for (const descriptor of descriptors){
            const plugin = descriptor.plugin;
            const method = plugin[hook];
            const params = [
                chart,
                args,
                descriptor.options
            ];
            if (helpers_dataset.callback(method, params, plugin) === false && args.cancelable) {
                return false;
            }
        }
        return true;
    }
    invalidate() {
        if (!helpers_dataset.isNullOrUndef(this._cache)) {
            this._oldCache = this._cache;
            this._cache = undefined;
        }
    }
 _descriptors(chart) {
        if (this._cache) {
            return this._cache;
        }
        const descriptors = this._cache = this._createDescriptors(chart);
        this._notifyStateChanges(chart);
        return descriptors;
    }
    _createDescriptors(chart, all) {
        const config = chart && chart.config;
        const options = helpers_dataset.valueOrDefault(config.options && config.options.plugins, {});
        const plugins = allPlugins(config);
        return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);
    }
 _notifyStateChanges(chart) {
        const previousDescriptors = this._oldCache || [];
        const descriptors = this._cache;
        const diff = (a, b)=>a.filter((x)=>!b.some((y)=>x.plugin.id === y.plugin.id));
        this._notify(diff(previousDescriptors, descriptors), chart, 'stop');
        this._notify(diff(descriptors, previousDescriptors), chart, 'start');
    }
}
 function allPlugins(config) {
    const localIds = {};
    const plugins = [];
    const keys = Object.keys(registry.plugins.items);
    for(let i = 0; i < keys.length; i++){
        plugins.push(registry.getPlugin(keys[i]));
    }
    const local = config.plugins || [];
    for(let i = 0; i < local.length; i++){
        const plugin = local[i];
        if (plugins.indexOf(plugin) === -1) {
            plugins.push(plugin);
            localIds[plugin.id] = true;
        }
    }
    return {
        plugins,
        localIds
    };
}
function getOpts(options, all) {
    if (!all && options === false) {
        return null;
    }
    if (options === true) {
        return {};
    }
    return options;
}
function createDescriptors(chart, { plugins , localIds  }, options, all) {
    const result = [];
    const context = chart.getContext();
    for (const plugin of plugins){
        const id = plugin.id;
        const opts = getOpts(options[id], all);
        if (opts === null) {
            continue;
        }
        result.push({
            plugin,
            options: pluginOpts(chart.config, {
                plugin,
                local: localIds[id]
            }, opts, context)
        });
    }
    return result;
}
function pluginOpts(config, { plugin , local  }, opts, context) {
    const keys = config.pluginScopeKeys(plugin);
    const scopes = config.getOptionScopes(opts, keys);
    if (local && plugin.defaults) {
        scopes.push(plugin.defaults);
    }
    return config.createResolver(scopes, context, [
        ''
    ], {
        scriptable: false,
        indexable: false,
        allKeys: true
    });
}

function getIndexAxis(type, options) {
    const datasetDefaults = helpers_dataset.defaults.datasets[type] || {};
    const datasetOptions = (options.datasets || {})[type] || {};
    return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || 'x';
}
function getAxisFromDefaultScaleID(id, indexAxis) {
    let axis = id;
    if (id === '_index_') {
        axis = indexAxis;
    } else if (id === '_value_') {
        axis = indexAxis === 'x' ? 'y' : 'x';
    }
    return axis;
}
function getDefaultScaleIDFromAxis(axis, indexAxis) {
    return axis === indexAxis ? '_index_' : '_value_';
}
function idMatchesAxis(id) {
    if (id === 'x' || id === 'y' || id === 'r') {
        return id;
    }
}
function axisFromPosition(position) {
    if (position === 'top' || position === 'bottom') {
        return 'x';
    }
    if (position === 'left' || position === 'right') {
        return 'y';
    }
}
function determineAxis(id, ...scaleOptions) {
    if (idMatchesAxis(id)) {
        return id;
    }
    for (const opts of scaleOptions){
        const axis = opts.axis || axisFromPosition(opts.position) || id.length > 1 && idMatchesAxis(id[0].toLowerCase());
        if (axis) {
            return axis;
        }
    }
    throw new Error(`Cannot determine type of '${id}' axis. Please provide 'axis' or 'position' option.`);
}
function getAxisFromDataset(id, axis, dataset) {
    if (dataset[axis + 'AxisID'] === id) {
        return {
            axis
        };
    }
}
function retrieveAxisFromDatasets(id, config) {
    if (config.data && config.data.datasets) {
        const boundDs = config.data.datasets.filter((d)=>d.xAxisID === id || d.yAxisID === id);
        if (boundDs.length) {
            return getAxisFromDataset(id, 'x', boundDs[0]) || getAxisFromDataset(id, 'y', boundDs[0]);
        }
    }
    return {};
}
function mergeScaleConfig(config, options) {
    const chartDefaults = helpers_dataset.overrides[config.type] || {
        scales: {}
    };
    const configScales = options.scales || {};
    const chartIndexAxis = getIndexAxis(config.type, options);
    const scales = Object.create(null);
    Object.keys(configScales).forEach((id)=>{
        const scaleConf = configScales[id];
        if (!helpers_dataset.isObject(scaleConf)) {
            return console.error(`Invalid scale configuration for scale: ${id}`);
        }
        if (scaleConf._proxy) {
            return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
        }
        const axis = determineAxis(id, scaleConf, retrieveAxisFromDatasets(id, config), helpers_dataset.defaults.scales[scaleConf.type]);
        const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
        const defaultScaleOptions = chartDefaults.scales || {};
        scales[id] = helpers_dataset.mergeIf(Object.create(null), [
            {
                axis
            },
            scaleConf,
            defaultScaleOptions[axis],
            defaultScaleOptions[defaultId]
        ]);
    });
    config.data.datasets.forEach((dataset)=>{
        const type = dataset.type || config.type;
        const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
        const datasetDefaults = helpers_dataset.overrides[type] || {};
        const defaultScaleOptions = datasetDefaults.scales || {};
        Object.keys(defaultScaleOptions).forEach((defaultID)=>{
            const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
            const id = dataset[axis + 'AxisID'] || axis;
            scales[id] = scales[id] || Object.create(null);
            helpers_dataset.mergeIf(scales[id], [
                {
                    axis
                },
                configScales[id],
                defaultScaleOptions[defaultID]
            ]);
        });
    });
    Object.keys(scales).forEach((key)=>{
        const scale = scales[key];
        helpers_dataset.mergeIf(scale, [
            helpers_dataset.defaults.scales[scale.type],
            helpers_dataset.defaults.scale
        ]);
    });
    return scales;
}
function initOptions(config) {
    const options = config.options || (config.options = {});
    options.plugins = helpers_dataset.valueOrDefault(options.plugins, {});
    options.scales = mergeScaleConfig(config, options);
}
function initData(data) {
    data = data || {};
    data.datasets = data.datasets || [];
    data.labels = data.labels || [];
    return data;
}
function initConfig(config) {
    config = config || {};
    config.data = initData(config.data);
    initOptions(config);
    return config;
}
const keyCache = new Map();
const keysCached = new Set();
function cachedKeys(cacheKey, generate) {
    let keys = keyCache.get(cacheKey);
    if (!keys) {
        keys = generate();
        keyCache.set(cacheKey, keys);
        keysCached.add(keys);
    }
    return keys;
}
const addIfFound = (set, obj, key)=>{
    const opts = helpers_dataset.resolveObjectKey(obj, key);
    if (opts !== undefined) {
        set.add(opts);
    }
};
class Config {
    constructor(config){
        this._config = initConfig(config);
        this._scopeCache = new Map();
        this._resolverCache = new Map();
    }
    get platform() {
        return this._config.platform;
    }
    get type() {
        return this._config.type;
    }
    set type(type) {
        this._config.type = type;
    }
    get data() {
        return this._config.data;
    }
    set data(data) {
        this._config.data = initData(data);
    }
    get options() {
        return this._config.options;
    }
    set options(options) {
        this._config.options = options;
    }
    get plugins() {
        return this._config.plugins;
    }
    update() {
        const config = this._config;
        this.clearCache();
        initOptions(config);
    }
    clearCache() {
        this._scopeCache.clear();
        this._resolverCache.clear();
    }
 datasetScopeKeys(datasetType) {
        return cachedKeys(datasetType, ()=>[
                [
                    `datasets.${datasetType}`,
                    ''
                ]
            ]);
    }
 datasetAnimationScopeKeys(datasetType, transition) {
        return cachedKeys(`${datasetType}.transition.${transition}`, ()=>[
                [
                    `datasets.${datasetType}.transitions.${transition}`,
                    `transitions.${transition}`
                ],
                [
                    `datasets.${datasetType}`,
                    ''
                ]
            ]);
    }
 datasetElementScopeKeys(datasetType, elementType) {
        return cachedKeys(`${datasetType}-${elementType}`, ()=>[
                [
                    `datasets.${datasetType}.elements.${elementType}`,
                    `datasets.${datasetType}`,
                    `elements.${elementType}`,
                    ''
                ]
            ]);
    }
 pluginScopeKeys(plugin) {
        const id = plugin.id;
        const type = this.type;
        return cachedKeys(`${type}-plugin-${id}`, ()=>[
                [
                    `plugins.${id}`,
                    ...plugin.additionalOptionScopes || []
                ]
            ]);
    }
 _cachedScopes(mainScope, resetCache) {
        const _scopeCache = this._scopeCache;
        let cache = _scopeCache.get(mainScope);
        if (!cache || resetCache) {
            cache = new Map();
            _scopeCache.set(mainScope, cache);
        }
        return cache;
    }
 getOptionScopes(mainScope, keyLists, resetCache) {
        const { options , type  } = this;
        const cache = this._cachedScopes(mainScope, resetCache);
        const cached = cache.get(keyLists);
        if (cached) {
            return cached;
        }
        const scopes = new Set();
        keyLists.forEach((keys)=>{
            if (mainScope) {
                scopes.add(mainScope);
                keys.forEach((key)=>addIfFound(scopes, mainScope, key));
            }
            keys.forEach((key)=>addIfFound(scopes, options, key));
            keys.forEach((key)=>addIfFound(scopes, helpers_dataset.overrides[type] || {}, key));
            keys.forEach((key)=>addIfFound(scopes, helpers_dataset.defaults, key));
            keys.forEach((key)=>addIfFound(scopes, helpers_dataset.descriptors, key));
        });
        const array = Array.from(scopes);
        if (array.length === 0) {
            array.push(Object.create(null));
        }
        if (keysCached.has(keyLists)) {
            cache.set(keyLists, array);
        }
        return array;
    }
 chartOptionScopes() {
        const { options , type  } = this;
        return [
            options,
            helpers_dataset.overrides[type] || {},
            helpers_dataset.defaults.datasets[type] || {},
            {
                type
            },
            helpers_dataset.defaults,
            helpers_dataset.descriptors
        ];
    }
 resolveNamedOptions(scopes, names, context, prefixes = [
        ''
    ]) {
        const result = {
            $shared: true
        };
        const { resolver , subPrefixes  } = getResolver(this._resolverCache, scopes, prefixes);
        let options = resolver;
        if (needContext(resolver, names)) {
            result.$shared = false;
            context = helpers_dataset.isFunction(context) ? context() : context;
            const subResolver = this.createResolver(scopes, context, subPrefixes);
            options = helpers_dataset._attachContext(resolver, context, subResolver);
        }
        for (const prop of names){
            result[prop] = options[prop];
        }
        return result;
    }
 createResolver(scopes, context, prefixes = [
        ''
    ], descriptorDefaults) {
        const { resolver  } = getResolver(this._resolverCache, scopes, prefixes);
        return helpers_dataset.isObject(context) ? helpers_dataset._attachContext(resolver, context, undefined, descriptorDefaults) : resolver;
    }
}
function getResolver(resolverCache, scopes, prefixes) {
    let cache = resolverCache.get(scopes);
    if (!cache) {
        cache = new Map();
        resolverCache.set(scopes, cache);
    }
    const cacheKey = prefixes.join();
    let cached = cache.get(cacheKey);
    if (!cached) {
        const resolver = helpers_dataset._createResolver(scopes, prefixes);
        cached = {
            resolver,
            subPrefixes: prefixes.filter((p)=>!p.toLowerCase().includes('hover'))
        };
        cache.set(cacheKey, cached);
    }
    return cached;
}
const hasFunction = (value)=>helpers_dataset.isObject(value) && Object.getOwnPropertyNames(value).some((key)=>helpers_dataset.isFunction(value[key]));
function needContext(proxy, names) {
    const { isScriptable , isIndexable  } = helpers_dataset._descriptors(proxy);
    for (const prop of names){
        const scriptable = isScriptable(prop);
        const indexable = isIndexable(prop);
        const value = (indexable || scriptable) && proxy[prop];
        if (scriptable && (helpers_dataset.isFunction(value) || hasFunction(value)) || indexable && helpers_dataset.isArray(value)) {
            return true;
        }
    }
    return false;
}

var version = "4.5.0";

const KNOWN_POSITIONS = [
    'top',
    'bottom',
    'left',
    'right',
    'chartArea'
];
function positionIsHorizontal(position, axis) {
    return position === 'top' || position === 'bottom' || KNOWN_POSITIONS.indexOf(position) === -1 && axis === 'x';
}
function compare2Level(l1, l2) {
    return function(a, b) {
        return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
    };
}
function onAnimationsComplete(context) {
    const chart = context.chart;
    const animationOptions = chart.options.animation;
    chart.notifyPlugins('afterRender');
    helpers_dataset.callback(animationOptions && animationOptions.onComplete, [
        context
    ], chart);
}
function onAnimationProgress(context) {
    const chart = context.chart;
    const animationOptions = chart.options.animation;
    helpers_dataset.callback(animationOptions && animationOptions.onProgress, [
        context
    ], chart);
}
 function getCanvas(item) {
    if (helpers_dataset._isDomSupported() && typeof item === 'string') {
        item = document.getElementById(item);
    } else if (item && item.length) {
        item = item[0];
    }
    if (item && item.canvas) {
        item = item.canvas;
    }
    return item;
}
const instances = {};
const getChart = (key)=>{
    const canvas = getCanvas(key);
    return Object.values(instances).filter((c)=>c.canvas === canvas).pop();
};
function moveNumericKeys(obj, start, move) {
    const keys = Object.keys(obj);
    for (const key of keys){
        const intKey = +key;
        if (intKey >= start) {
            const value = obj[key];
            delete obj[key];
            if (move > 0 || intKey > start) {
                obj[intKey + move] = value;
            }
        }
    }
}
 function determineLastEvent(e, lastEvent, inChartArea, isClick) {
    if (!inChartArea || e.type === 'mouseout') {
        return null;
    }
    if (isClick) {
        return lastEvent;
    }
    return e;
}
class Chart {
    static defaults = helpers_dataset.defaults;
    static instances = instances;
    static overrides = helpers_dataset.overrides;
    static registry = registry;
    static version = version;
    static getChart = getChart;
    static register(...items) {
        registry.add(...items);
        invalidatePlugins();
    }
    static unregister(...items) {
        registry.remove(...items);
        invalidatePlugins();
    }
    constructor(item, userConfig){
        const config = this.config = new Config(userConfig);
        const initialCanvas = getCanvas(item);
        const existingChart = getChart(initialCanvas);
        if (existingChart) {
            throw new Error('Canvas is already in use. Chart with ID \'' + existingChart.id + '\'' + ' must be destroyed before the canvas with ID \'' + existingChart.canvas.id + '\' can be reused.');
        }
        const options = config.createResolver(config.chartOptionScopes(), this.getContext());
        this.platform = new (config.platform || _detectPlatform(initialCanvas))();
        this.platform.updateConfig(config);
        const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
        const canvas = context && context.canvas;
        const height = canvas && canvas.height;
        const width = canvas && canvas.width;
        this.id = helpers_dataset.uid();
        this.ctx = context;
        this.canvas = canvas;
        this.width = width;
        this.height = height;
        this._options = options;
        this._aspectRatio = this.aspectRatio;
        this._layers = [];
        this._metasets = [];
        this._stacks = undefined;
        this.boxes = [];
        this.currentDevicePixelRatio = undefined;
        this.chartArea = undefined;
        this._active = [];
        this._lastEvent = undefined;
        this._listeners = {};
         this._responsiveListeners = undefined;
        this._sortedMetasets = [];
        this.scales = {};
        this._plugins = new PluginService();
        this.$proxies = {};
        this._hiddenIndices = {};
        this.attached = false;
        this._animationsDisabled = undefined;
        this.$context = undefined;
        this._doResize = helpers_dataset.debounce((mode)=>this.update(mode), options.resizeDelay || 0);
        this._dataChanges = [];
        instances[this.id] = this;
        if (!context || !canvas) {
            console.error("Failed to create chart: can't acquire context from the given item");
            return;
        }
        animator.listen(this, 'complete', onAnimationsComplete);
        animator.listen(this, 'progress', onAnimationProgress);
        this._initialize();
        if (this.attached) {
            this.update();
        }
    }
    get aspectRatio() {
        const { options: { aspectRatio , maintainAspectRatio  } , width , height , _aspectRatio  } = this;
        if (!helpers_dataset.isNullOrUndef(aspectRatio)) {
            return aspectRatio;
        }
        if (maintainAspectRatio && _aspectRatio) {
            return _aspectRatio;
        }
        return height ? width / height : null;
    }
    get data() {
        return this.config.data;
    }
    set data(data) {
        this.config.data = data;
    }
    get options() {
        return this._options;
    }
    set options(options) {
        this.config.options = options;
    }
    get registry() {
        return registry;
    }
 _initialize() {
        this.notifyPlugins('beforeInit');
        if (this.options.responsive) {
            this.resize();
        } else {
            helpers_dataset.retinaScale(this, this.options.devicePixelRatio);
        }
        this.bindEvents();
        this.notifyPlugins('afterInit');
        return this;
    }
    clear() {
        helpers_dataset.clearCanvas(this.canvas, this.ctx);
        return this;
    }
    stop() {
        animator.stop(this);
        return this;
    }
 resize(width, height) {
        if (!animator.running(this)) {
            this._resize(width, height);
        } else {
            this._resizeBeforeDraw = {
                width,
                height
            };
        }
    }
    _resize(width, height) {
        const options = this.options;
        const canvas = this.canvas;
        const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
        const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
        const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
        const mode = this.width ? 'resize' : 'attach';
        this.width = newSize.width;
        this.height = newSize.height;
        this._aspectRatio = this.aspectRatio;
        if (!helpers_dataset.retinaScale(this, newRatio, true)) {
            return;
        }
        this.notifyPlugins('resize', {
            size: newSize
        });
        helpers_dataset.callback(options.onResize, [
            this,
            newSize
        ], this);
        if (this.attached) {
            if (this._doResize(mode)) {
                this.render();
            }
        }
    }
    ensureScalesHaveIDs() {
        const options = this.options;
        const scalesOptions = options.scales || {};
        helpers_dataset.each(scalesOptions, (axisOptions, axisID)=>{
            axisOptions.id = axisID;
        });
    }
 buildOrUpdateScales() {
        const options = this.options;
        const scaleOpts = options.scales;
        const scales = this.scales;
        const updated = Object.keys(scales).reduce((obj, id)=>{
            obj[id] = false;
            return obj;
        }, {});
        let items = [];
        if (scaleOpts) {
            items = items.concat(Object.keys(scaleOpts).map((id)=>{
                const scaleOptions = scaleOpts[id];
                const axis = determineAxis(id, scaleOptions);
                const isRadial = axis === 'r';
                const isHorizontal = axis === 'x';
                return {
                    options: scaleOptions,
                    dposition: isRadial ? 'chartArea' : isHorizontal ? 'bottom' : 'left',
                    dtype: isRadial ? 'radialLinear' : isHorizontal ? 'category' : 'linear'
                };
            }));
        }
        helpers_dataset.each(items, (item)=>{
            const scaleOptions = item.options;
            const id = scaleOptions.id;
            const axis = determineAxis(id, scaleOptions);
            const scaleType = helpers_dataset.valueOrDefault(scaleOptions.type, item.dtype);
            if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
                scaleOptions.position = item.dposition;
            }
            updated[id] = true;
            let scale = null;
            if (id in scales && scales[id].type === scaleType) {
                scale = scales[id];
            } else {
                const scaleClass = registry.getScale(scaleType);
                scale = new scaleClass({
                    id,
                    type: scaleType,
                    ctx: this.ctx,
                    chart: this
                });
                scales[scale.id] = scale;
            }
            scale.init(scaleOptions, options);
        });
        helpers_dataset.each(updated, (hasUpdated, id)=>{
            if (!hasUpdated) {
                delete scales[id];
            }
        });
        helpers_dataset.each(scales, (scale)=>{
            layouts.configure(this, scale, scale.options);
            layouts.addBox(this, scale);
        });
    }
 _updateMetasets() {
        const metasets = this._metasets;
        const numData = this.data.datasets.length;
        const numMeta = metasets.length;
        metasets.sort((a, b)=>a.index - b.index);
        if (numMeta > numData) {
            for(let i = numData; i < numMeta; ++i){
                this._destroyDatasetMeta(i);
            }
            metasets.splice(numData, numMeta - numData);
        }
        this._sortedMetasets = metasets.slice(0).sort(compare2Level('order', 'index'));
    }
 _removeUnreferencedMetasets() {
        const { _metasets: metasets , data: { datasets  }  } = this;
        if (metasets.length > datasets.length) {
            delete this._stacks;
        }
        metasets.forEach((meta, index)=>{
            if (datasets.filter((x)=>x === meta._dataset).length === 0) {
                this._destroyDatasetMeta(index);
            }
        });
    }
    buildOrUpdateControllers() {
        const newControllers = [];
        const datasets = this.data.datasets;
        let i, ilen;
        this._removeUnreferencedMetasets();
        for(i = 0, ilen = datasets.length; i < ilen; i++){
            const dataset = datasets[i];
            let meta = this.getDatasetMeta(i);
            const type = dataset.type || this.config.type;
            if (meta.type && meta.type !== type) {
                this._destroyDatasetMeta(i);
                meta = this.getDatasetMeta(i);
            }
            meta.type = type;
            meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
            meta.order = dataset.order || 0;
            meta.index = i;
            meta.label = '' + dataset.label;
            meta.visible = this.isDatasetVisible(i);
            if (meta.controller) {
                meta.controller.updateIndex(i);
                meta.controller.linkScales();
            } else {
                const ControllerClass = registry.getController(type);
                const { datasetElementType , dataElementType  } = helpers_dataset.defaults.datasets[type];
                Object.assign(ControllerClass, {
                    dataElementType: registry.getElement(dataElementType),
                    datasetElementType: datasetElementType && registry.getElement(datasetElementType)
                });
                meta.controller = new ControllerClass(this, i);
                newControllers.push(meta.controller);
            }
        }
        this._updateMetasets();
        return newControllers;
    }
 _resetElements() {
        helpers_dataset.each(this.data.datasets, (dataset, datasetIndex)=>{
            this.getDatasetMeta(datasetIndex).controller.reset();
        }, this);
    }
 reset() {
        this._resetElements();
        this.notifyPlugins('reset');
    }
    update(mode) {
        const config = this.config;
        config.update();
        const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
        const animsDisabled = this._animationsDisabled = !options.animation;
        this._updateScales();
        this._checkEventBindings();
        this._updateHiddenIndices();
        this._plugins.invalidate();
        if (this.notifyPlugins('beforeUpdate', {
            mode,
            cancelable: true
        }) === false) {
            return;
        }
        const newControllers = this.buildOrUpdateControllers();
        this.notifyPlugins('beforeElementsUpdate');
        let minPadding = 0;
        for(let i = 0, ilen = this.data.datasets.length; i < ilen; i++){
            const { controller  } = this.getDatasetMeta(i);
            const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
            controller.buildOrUpdateElements(reset);
            minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
        }
        minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
        this._updateLayout(minPadding);
        if (!animsDisabled) {
            helpers_dataset.each(newControllers, (controller)=>{
                controller.reset();
            });
        }
        this._updateDatasets(mode);
        this.notifyPlugins('afterUpdate', {
            mode
        });
        this._layers.sort(compare2Level('z', '_idx'));
        const { _active , _lastEvent  } = this;
        if (_lastEvent) {
            this._eventHandler(_lastEvent, true);
        } else if (_active.length) {
            this._updateHoverStyles(_active, _active, true);
        }
        this.render();
    }
 _updateScales() {
        helpers_dataset.each(this.scales, (scale)=>{
            layouts.removeBox(this, scale);
        });
        this.ensureScalesHaveIDs();
        this.buildOrUpdateScales();
    }
 _checkEventBindings() {
        const options = this.options;
        const existingEvents = new Set(Object.keys(this._listeners));
        const newEvents = new Set(options.events);
        if (!helpers_dataset.setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
            this.unbindEvents();
            this.bindEvents();
        }
    }
 _updateHiddenIndices() {
        const { _hiddenIndices  } = this;
        const changes = this._getUniformDataChanges() || [];
        for (const { method , start , count  } of changes){
            const move = method === '_removeElements' ? -count : count;
            moveNumericKeys(_hiddenIndices, start, move);
        }
    }
 _getUniformDataChanges() {
        const _dataChanges = this._dataChanges;
        if (!_dataChanges || !_dataChanges.length) {
            return;
        }
        this._dataChanges = [];
        const datasetCount = this.data.datasets.length;
        const makeSet = (idx)=>new Set(_dataChanges.filter((c)=>c[0] === idx).map((c, i)=>i + ',' + c.splice(1).join(',')));
        const changeSet = makeSet(0);
        for(let i = 1; i < datasetCount; i++){
            if (!helpers_dataset.setsEqual(changeSet, makeSet(i))) {
                return;
            }
        }
        return Array.from(changeSet).map((c)=>c.split(',')).map((a)=>({
                method: a[1],
                start: +a[2],
                count: +a[3]
            }));
    }
 _updateLayout(minPadding) {
        if (this.notifyPlugins('beforeLayout', {
            cancelable: true
        }) === false) {
            return;
        }
        layouts.update(this, this.width, this.height, minPadding);
        const area = this.chartArea;
        const noArea = area.width <= 0 || area.height <= 0;
        this._layers = [];
        helpers_dataset.each(this.boxes, (box)=>{
            if (noArea && box.position === 'chartArea') {
                return;
            }
            if (box.configure) {
                box.configure();
            }
            this._layers.push(...box._layers());
        }, this);
        this._layers.forEach((item, index)=>{
            item._idx = index;
        });
        this.notifyPlugins('afterLayout');
    }
 _updateDatasets(mode) {
        if (this.notifyPlugins('beforeDatasetsUpdate', {
            mode,
            cancelable: true
        }) === false) {
            return;
        }
        for(let i = 0, ilen = this.data.datasets.length; i < ilen; ++i){
            this.getDatasetMeta(i).controller.configure();
        }
        for(let i = 0, ilen = this.data.datasets.length; i < ilen; ++i){
            this._updateDataset(i, helpers_dataset.isFunction(mode) ? mode({
                datasetIndex: i
            }) : mode);
        }
        this.notifyPlugins('afterDatasetsUpdate', {
            mode
        });
    }
 _updateDataset(index, mode) {
        const meta = this.getDatasetMeta(index);
        const args = {
            meta,
            index,
            mode,
            cancelable: true
        };
        if (this.notifyPlugins('beforeDatasetUpdate', args) === false) {
            return;
        }
        meta.controller._update(mode);
        args.cancelable = false;
        this.notifyPlugins('afterDatasetUpdate', args);
    }
    render() {
        if (this.notifyPlugins('beforeRender', {
            cancelable: true
        }) === false) {
            return;
        }
        if (animator.has(this)) {
            if (this.attached && !animator.running(this)) {
                animator.start(this);
            }
        } else {
            this.draw();
            onAnimationsComplete({
                chart: this
            });
        }
    }
    draw() {
        let i;
        if (this._resizeBeforeDraw) {
            const { width , height  } = this._resizeBeforeDraw;
            this._resizeBeforeDraw = null;
            this._resize(width, height);
        }
        this.clear();
        if (this.width <= 0 || this.height <= 0) {
            return;
        }
        if (this.notifyPlugins('beforeDraw', {
            cancelable: true
        }) === false) {
            return;
        }
        const layers = this._layers;
        for(i = 0; i < layers.length && layers[i].z <= 0; ++i){
            layers[i].draw(this.chartArea);
        }
        this._drawDatasets();
        for(; i < layers.length; ++i){
            layers[i].draw(this.chartArea);
        }
        this.notifyPlugins('afterDraw');
    }
 _getSortedDatasetMetas(filterVisible) {
        const metasets = this._sortedMetasets;
        const result = [];
        let i, ilen;
        for(i = 0, ilen = metasets.length; i < ilen; ++i){
            const meta = metasets[i];
            if (!filterVisible || meta.visible) {
                result.push(meta);
            }
        }
        return result;
    }
 getSortedVisibleDatasetMetas() {
        return this._getSortedDatasetMetas(true);
    }
 _drawDatasets() {
        if (this.notifyPlugins('beforeDatasetsDraw', {
            cancelable: true
        }) === false) {
            return;
        }
        const metasets = this.getSortedVisibleDatasetMetas();
        for(let i = metasets.length - 1; i >= 0; --i){
            this._drawDataset(metasets[i]);
        }
        this.notifyPlugins('afterDatasetsDraw');
    }
 _drawDataset(meta) {
        const ctx = this.ctx;
        const args = {
            meta,
            index: meta.index,
            cancelable: true
        };
        const clip = helpers_dataset.getDatasetClipArea(this, meta);
        if (this.notifyPlugins('beforeDatasetDraw', args) === false) {
            return;
        }
        if (clip) {
            helpers_dataset.clipArea(ctx, clip);
        }
        meta.controller.draw();
        if (clip) {
            helpers_dataset.unclipArea(ctx);
        }
        args.cancelable = false;
        this.notifyPlugins('afterDatasetDraw', args);
    }
 isPointInArea(point) {
        return helpers_dataset._isPointInArea(point, this.chartArea, this._minPadding);
    }
    getElementsAtEventForMode(e, mode, options, useFinalPosition) {
        const method = Interaction.modes[mode];
        if (typeof method === 'function') {
            return method(this, e, options, useFinalPosition);
        }
        return [];
    }
    getDatasetMeta(datasetIndex) {
        const dataset = this.data.datasets[datasetIndex];
        const metasets = this._metasets;
        let meta = metasets.filter((x)=>x && x._dataset === dataset).pop();
        if (!meta) {
            meta = {
                type: null,
                data: [],
                dataset: null,
                controller: null,
                hidden: null,
                xAxisID: null,
                yAxisID: null,
                order: dataset && dataset.order || 0,
                index: datasetIndex,
                _dataset: dataset,
                _parsed: [],
                _sorted: false
            };
            metasets.push(meta);
        }
        return meta;
    }
    getContext() {
        return this.$context || (this.$context = helpers_dataset.createContext(null, {
            chart: this,
            type: 'chart'
        }));
    }
    getVisibleDatasetCount() {
        return this.getSortedVisibleDatasetMetas().length;
    }
    isDatasetVisible(datasetIndex) {
        const dataset = this.data.datasets[datasetIndex];
        if (!dataset) {
            return false;
        }
        const meta = this.getDatasetMeta(datasetIndex);
        return typeof meta.hidden === 'boolean' ? !meta.hidden : !dataset.hidden;
    }
    setDatasetVisibility(datasetIndex, visible) {
        const meta = this.getDatasetMeta(datasetIndex);
        meta.hidden = !visible;
    }
    toggleDataVisibility(index) {
        this._hiddenIndices[index] = !this._hiddenIndices[index];
    }
    getDataVisibility(index) {
        return !this._hiddenIndices[index];
    }
 _updateVisibility(datasetIndex, dataIndex, visible) {
        const mode = visible ? 'show' : 'hide';
        const meta = this.getDatasetMeta(datasetIndex);
        const anims = meta.controller._resolveAnimations(undefined, mode);
        if (helpers_dataset.defined(dataIndex)) {
            meta.data[dataIndex].hidden = !visible;
            this.update();
        } else {
            this.setDatasetVisibility(datasetIndex, visible);
            anims.update(meta, {
                visible
            });
            this.update((ctx)=>ctx.datasetIndex === datasetIndex ? mode : undefined);
        }
    }
    hide(datasetIndex, dataIndex) {
        this._updateVisibility(datasetIndex, dataIndex, false);
    }
    show(datasetIndex, dataIndex) {
        this._updateVisibility(datasetIndex, dataIndex, true);
    }
 _destroyDatasetMeta(datasetIndex) {
        const meta = this._metasets[datasetIndex];
        if (meta && meta.controller) {
            meta.controller._destroy();
        }
        delete this._metasets[datasetIndex];
    }
    _stop() {
        let i, ilen;
        this.stop();
        animator.remove(this);
        for(i = 0, ilen = this.data.datasets.length; i < ilen; ++i){
            this._destroyDatasetMeta(i);
        }
    }
    destroy() {
        this.notifyPlugins('beforeDestroy');
        const { canvas , ctx  } = this;
        this._stop();
        this.config.clearCache();
        if (canvas) {
            this.unbindEvents();
            helpers_dataset.clearCanvas(canvas, ctx);
            this.platform.releaseContext(ctx);
            this.canvas = null;
            this.ctx = null;
        }
        delete instances[this.id];
        this.notifyPlugins('afterDestroy');
    }
    toBase64Image(...args) {
        return this.canvas.toDataURL(...args);
    }
 bindEvents() {
        this.bindUserEvents();
        if (this.options.responsive) {
            this.bindResponsiveEvents();
        } else {
            this.attached = true;
        }
    }
 bindUserEvents() {
        const listeners = this._listeners;
        const platform = this.platform;
        const _add = (type, listener)=>{
            platform.addEventListener(this, type, listener);
            listeners[type] = listener;
        };
        const listener = (e, x, y)=>{
            e.offsetX = x;
            e.offsetY = y;
            this._eventHandler(e);
        };
        helpers_dataset.each(this.options.events, (type)=>_add(type, listener));
    }
 bindResponsiveEvents() {
        if (!this._responsiveListeners) {
            this._responsiveListeners = {};
        }
        const listeners = this._responsiveListeners;
        const platform = this.platform;
        const _add = (type, listener)=>{
            platform.addEventListener(this, type, listener);
            listeners[type] = listener;
        };
        const _remove = (type, listener)=>{
            if (listeners[type]) {
                platform.removeEventListener(this, type, listener);
                delete listeners[type];
            }
        };
        const listener = (width, height)=>{
            if (this.canvas) {
                this.resize(width, height);
            }
        };
        let detached;
        const attached = ()=>{
            _remove('attach', attached);
            this.attached = true;
            this.resize();
            _add('resize', listener);
            _add('detach', detached);
        };
        detached = ()=>{
            this.attached = false;
            _remove('resize', listener);
            this._stop();
            this._resize(0, 0);
            _add('attach', attached);
        };
        if (platform.isAttached(this.canvas)) {
            attached();
        } else {
            detached();
        }
    }
 unbindEvents() {
        helpers_dataset.each(this._listeners, (listener, type)=>{
            this.platform.removeEventListener(this, type, listener);
        });
        this._listeners = {};
        helpers_dataset.each(this._responsiveListeners, (listener, type)=>{
            this.platform.removeEventListener(this, type, listener);
        });
        this._responsiveListeners = undefined;
    }
    updateHoverStyle(items, mode, enabled) {
        const prefix = enabled ? 'set' : 'remove';
        let meta, item, i, ilen;
        if (mode === 'dataset') {
            meta = this.getDatasetMeta(items[0].datasetIndex);
            meta.controller['_' + prefix + 'DatasetHoverStyle']();
        }
        for(i = 0, ilen = items.length; i < ilen; ++i){
            item = items[i];
            const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
            if (controller) {
                controller[prefix + 'HoverStyle'](item.element, item.datasetIndex, item.index);
            }
        }
    }
 getActiveElements() {
        return this._active || [];
    }
 setActiveElements(activeElements) {
        const lastActive = this._active || [];
        const active = activeElements.map(({ datasetIndex , index  })=>{
            const meta = this.getDatasetMeta(datasetIndex);
            if (!meta) {
                throw new Error('No dataset found at index ' + datasetIndex);
            }
            return {
                datasetIndex,
                element: meta.data[index],
                index
            };
        });
        const changed = !helpers_dataset._elementsEqual(active, lastActive);
        if (changed) {
            this._active = active;
            this._lastEvent = null;
            this._updateHoverStyles(active, lastActive);
        }
    }
 notifyPlugins(hook, args, filter) {
        return this._plugins.notify(this, hook, args, filter);
    }
 isPluginEnabled(pluginId) {
        return this._plugins._cache.filter((p)=>p.plugin.id === pluginId).length === 1;
    }
 _updateHoverStyles(active, lastActive, replay) {
        const hoverOptions = this.options.hover;
        const diff = (a, b)=>a.filter((x)=>!b.some((y)=>x.datasetIndex === y.datasetIndex && x.index === y.index));
        const deactivated = diff(lastActive, active);
        const activated = replay ? active : diff(active, lastActive);
        if (deactivated.length) {
            this.updateHoverStyle(deactivated, hoverOptions.mode, false);
        }
        if (activated.length && hoverOptions.mode) {
            this.updateHoverStyle(activated, hoverOptions.mode, true);
        }
    }
 _eventHandler(e, replay) {
        const args = {
            event: e,
            replay,
            cancelable: true,
            inChartArea: this.isPointInArea(e)
        };
        const eventFilter = (plugin)=>(plugin.options.events || this.options.events).includes(e.native.type);
        if (this.notifyPlugins('beforeEvent', args, eventFilter) === false) {
            return;
        }
        const changed = this._handleEvent(e, replay, args.inChartArea);
        args.cancelable = false;
        this.notifyPlugins('afterEvent', args, eventFilter);
        if (changed || args.changed) {
            this.render();
        }
        return this;
    }
 _handleEvent(e, replay, inChartArea) {
        const { _active: lastActive = [] , options  } = this;
        const useFinalPosition = replay;
        const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
        const isClick = helpers_dataset._isClickEvent(e);
        const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
        if (inChartArea) {
            this._lastEvent = null;
            helpers_dataset.callback(options.onHover, [
                e,
                active,
                this
            ], this);
            if (isClick) {
                helpers_dataset.callback(options.onClick, [
                    e,
                    active,
                    this
                ], this);
            }
        }
        const changed = !helpers_dataset._elementsEqual(active, lastActive);
        if (changed || replay) {
            this._active = active;
            this._updateHoverStyles(active, lastActive, replay);
        }
        this._lastEvent = lastEvent;
        return changed;
    }
 _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
        if (e.type === 'mouseout') {
            return [];
        }
        if (!inChartArea) {
            return lastActive;
        }
        const hoverOptions = this.options.hover;
        return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
    }
}
function invalidatePlugins() {
    return helpers_dataset.each(Chart.instances, (chart)=>chart._plugins.invalidate());
}

function clipSelf(ctx, element, endAngle) {
    const { startAngle , x , y , outerRadius , innerRadius , options  } = element;
    const { borderWidth , borderJoinStyle  } = options;
    const outerAngleClip = Math.min(borderWidth / outerRadius, helpers_dataset._normalizeAngle(startAngle - endAngle));
    ctx.beginPath();
    ctx.arc(x, y, outerRadius - borderWidth / 2, startAngle + outerAngleClip / 2, endAngle - outerAngleClip / 2);
    if (innerRadius > 0) {
        const innerAngleClip = Math.min(borderWidth / innerRadius, helpers_dataset._normalizeAngle(startAngle - endAngle));
        ctx.arc(x, y, innerRadius + borderWidth / 2, endAngle - innerAngleClip / 2, startAngle + innerAngleClip / 2, true);
    } else {
        const clipWidth = Math.min(borderWidth / 2, outerRadius * helpers_dataset._normalizeAngle(startAngle - endAngle));
        if (borderJoinStyle === 'round') {
            ctx.arc(x, y, clipWidth, endAngle - helpers_dataset.PI / 2, startAngle + helpers_dataset.PI / 2, true);
        } else if (borderJoinStyle === 'bevel') {
            const r = 2 * clipWidth * clipWidth;
            const endX = -r * Math.cos(endAngle + helpers_dataset.PI / 2) + x;
            const endY = -r * Math.sin(endAngle + helpers_dataset.PI / 2) + y;
            const startX = r * Math.cos(startAngle + helpers_dataset.PI / 2) + x;
            const startY = r * Math.sin(startAngle + helpers_dataset.PI / 2) + y;
            ctx.lineTo(endX, endY);
            ctx.lineTo(startX, startY);
        }
    }
    ctx.closePath();
    ctx.moveTo(0, 0);
    ctx.rect(0, 0, ctx.canvas.width, ctx.canvas.height);
    ctx.clip('evenodd');
}
function clipArc(ctx, element, endAngle) {
    const { startAngle , pixelMargin , x , y , outerRadius , innerRadius  } = element;
    let angleMargin = pixelMargin / outerRadius;
    // Draw an inner border by clipping the arc and drawing a double-width border
    // Enlarge the clipping arc by 0.33 pixels to eliminate glitches between borders
    ctx.beginPath();
    ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
    if (innerRadius > pixelMargin) {
        angleMargin = pixelMargin / innerRadius;
        ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
    } else {
        ctx.arc(x, y, pixelMargin, endAngle + helpers_dataset.HALF_PI, startAngle - helpers_dataset.HALF_PI);
    }
    ctx.closePath();
    ctx.clip();
}
function toRadiusCorners(value) {
    return helpers_dataset._readValueToProps(value, [
        'outerStart',
        'outerEnd',
        'innerStart',
        'innerEnd'
    ]);
}
/**
 * Parse border radius from the provided options
 */ function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
    const o = toRadiusCorners(arc.options.borderRadius);
    const halfThickness = (outerRadius - innerRadius) / 2;
    const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
    // Outer limits are complicated. We want to compute the available angular distance at
    // a radius of outerRadius - borderRadius because for small angular distances, this term limits.
    // We compute at r = outerRadius - borderRadius because this circle defines the center of the border corners.
    //
    // If the borderRadius is large, that value can become negative.
    // This causes the outer borders to lose their radius entirely, which is rather unexpected. To solve that, if borderRadius > outerRadius
    // we know that the thickness term will dominate and compute the limits at that point
    const computeOuterLimit = (val)=>{
        const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
        return helpers_dataset._limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
    };
    return {
        outerStart: computeOuterLimit(o.outerStart),
        outerEnd: computeOuterLimit(o.outerEnd),
        innerStart: helpers_dataset._limitValue(o.innerStart, 0, innerLimit),
        innerEnd: helpers_dataset._limitValue(o.innerEnd, 0, innerLimit)
    };
}
/**
 * Convert (r, 𝜃) to (x, y)
 */ function rThetaToXY(r, theta, x, y) {
    return {
        x: x + r * Math.cos(theta),
        y: y + r * Math.sin(theta)
    };
}
/**
 * Path the arc, respecting border radius by separating into left and right halves.
 *
 *   Start      End
 *
 *    1--->a--->2    Outer
 *   /           \
 *   8           3
 *   |           |
 *   |           |
 *   7           4
 *   \           /
 *    6<---b<---5    Inner
 */ function pathArc(ctx, element, offset, spacing, end, circular) {
    const { x , y , startAngle: start , pixelMargin , innerRadius: innerR  } = element;
    const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);
    const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
    let spacingOffset = 0;
    const alpha = end - start;
    if (spacing) {
        // When spacing is present, it is the same for all items
        // So we adjust the start and end angle of the arc such that
        // the distance is the same as it would be without the spacing
        const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
        const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
        const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
        const adjustedAngle = avNogSpacingRadius !== 0 ? alpha * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha;
        spacingOffset = (alpha - adjustedAngle) / 2;
    }
    const beta = Math.max(0.001, alpha * outerRadius - offset / helpers_dataset.PI) / outerRadius;
    const angleOffset = (alpha - beta) / 2;
    const startAngle = start + angleOffset + spacingOffset;
    const endAngle = end - angleOffset - spacingOffset;
    const { outerStart , outerEnd , innerStart , innerEnd  } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
    const outerStartAdjustedRadius = outerRadius - outerStart;
    const outerEndAdjustedRadius = outerRadius - outerEnd;
    const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
    const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
    const innerStartAdjustedRadius = innerRadius + innerStart;
    const innerEndAdjustedRadius = innerRadius + innerEnd;
    const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
    const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
    ctx.beginPath();
    if (circular) {
        // The first arc segments from point 1 to point a to point 2
        const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;
        ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);
        ctx.arc(x, y, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);
        // The corner segment from point 2 to point 3
        if (outerEnd > 0) {
            const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
            ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + helpers_dataset.HALF_PI);
        }
        // The line from point 3 to point 4
        const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
        ctx.lineTo(p4.x, p4.y);
        // The corner segment from point 4 to point 5
        if (innerEnd > 0) {
            const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
            ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + helpers_dataset.HALF_PI, innerEndAdjustedAngle + Math.PI);
        }
        // The inner arc from point 5 to point b to point 6
        const innerMidAdjustedAngle = (endAngle - innerEnd / innerRadius + (startAngle + innerStart / innerRadius)) / 2;
        ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, innerMidAdjustedAngle, true);
        ctx.arc(x, y, innerRadius, innerMidAdjustedAngle, startAngle + innerStart / innerRadius, true);
        // The corner segment from point 6 to point 7
        if (innerStart > 0) {
            const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
            ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - helpers_dataset.HALF_PI);
        }
        // The line from point 7 to point 8
        const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
        ctx.lineTo(p8.x, p8.y);
        // The corner segment from point 8 to point 1
        if (outerStart > 0) {
            const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
            ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - helpers_dataset.HALF_PI, outerStartAdjustedAngle);
        }
    } else {
        ctx.moveTo(x, y);
        const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;
        const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;
        ctx.lineTo(outerStartX, outerStartY);
        const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;
        const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;
        ctx.lineTo(outerEndX, outerEndY);
    }
    ctx.closePath();
}
function drawArc(ctx, element, offset, spacing, circular) {
    const { fullCircles , startAngle , circumference  } = element;
    let endAngle = element.endAngle;
    if (fullCircles) {
        pathArc(ctx, element, offset, spacing, endAngle, circular);
        for(let i = 0; i < fullCircles; ++i){
            ctx.fill();
        }
        if (!isNaN(circumference)) {
            endAngle = startAngle + (circumference % helpers_dataset.TAU || helpers_dataset.TAU);
        }
    }
    pathArc(ctx, element, offset, spacing, endAngle, circular);
    ctx.fill();
    return endAngle;
}
function drawBorder(ctx, element, offset, spacing, circular) {
    const { fullCircles , startAngle , circumference , options  } = element;
    const { borderWidth , borderJoinStyle , borderDash , borderDashOffset , borderRadius  } = options;
    const inner = options.borderAlign === 'inner';
    if (!borderWidth) {
        return;
    }
    ctx.setLineDash(borderDash || []);
    ctx.lineDashOffset = borderDashOffset;
    if (inner) {
        ctx.lineWidth = borderWidth * 2;
        ctx.lineJoin = borderJoinStyle || 'round';
    } else {
        ctx.lineWidth = borderWidth;
        ctx.lineJoin = borderJoinStyle || 'bevel';
    }
    let endAngle = element.endAngle;
    if (fullCircles) {
        pathArc(ctx, element, offset, spacing, endAngle, circular);
        for(let i = 0; i < fullCircles; ++i){
            ctx.stroke();
        }
        if (!isNaN(circumference)) {
            endAngle = startAngle + (circumference % helpers_dataset.TAU || helpers_dataset.TAU);
        }
    }
    if (inner) {
        clipArc(ctx, element, endAngle);
    }
    if (options.selfJoin && endAngle - startAngle >= helpers_dataset.PI && borderRadius === 0 && borderJoinStyle !== 'miter') {
        clipSelf(ctx, element, endAngle);
    }
    if (!fullCircles) {
        pathArc(ctx, element, offset, spacing, endAngle, circular);
        ctx.stroke();
    }
}
class ArcElement extends Element {
    static id = 'arc';
    static defaults = {
        borderAlign: 'center',
        borderColor: '#fff',
        borderDash: [],
        borderDashOffset: 0,
        borderJoinStyle: undefined,
        borderRadius: 0,
        borderWidth: 2,
        offset: 0,
        spacing: 0,
        angle: undefined,
        circular: true,
        selfJoin: false
    };
    static defaultRoutes = {
        backgroundColor: 'backgroundColor'
    };
    static descriptors = {
        _scriptable: true,
        _indexable: (name)=>name !== 'borderDash'
    };
    circumference;
    endAngle;
    fullCircles;
    innerRadius;
    outerRadius;
    pixelMargin;
    startAngle;
    constructor(cfg){
        super();
        this.options = undefined;
        this.circumference = undefined;
        this.startAngle = undefined;
        this.endAngle = undefined;
        this.innerRadius = undefined;
        this.outerRadius = undefined;
        this.pixelMargin = 0;
        this.fullCircles = 0;
        if (cfg) {
            Object.assign(this, cfg);
        }
    }
    inRange(chartX, chartY, useFinalPosition) {
        const point = this.getProps([
            'x',
            'y'
        ], useFinalPosition);
        const { angle , distance  } = helpers_dataset.getAngleFromPoint(point, {
            x: chartX,
            y: chartY
        });
        const { startAngle , endAngle , innerRadius , outerRadius , circumference  } = this.getProps([
            'startAngle',
            'endAngle',
            'innerRadius',
            'outerRadius',
            'circumference'
        ], useFinalPosition);
        const rAdjust = (this.options.spacing + this.options.borderWidth) / 2;
        const _circumference = helpers_dataset.valueOrDefault(circumference, endAngle - startAngle);
        const nonZeroBetween = helpers_dataset._angleBetween(angle, startAngle, endAngle) && startAngle !== endAngle;
        const betweenAngles = _circumference >= helpers_dataset.TAU || nonZeroBetween;
        const withinRadius = helpers_dataset._isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
        return betweenAngles && withinRadius;
    }
    getCenterPoint(useFinalPosition) {
        const { x , y , startAngle , endAngle , innerRadius , outerRadius  } = this.getProps([
            'x',
            'y',
            'startAngle',
            'endAngle',
            'innerRadius',
            'outerRadius'
        ], useFinalPosition);
        const { offset , spacing  } = this.options;
        const halfAngle = (startAngle + endAngle) / 2;
        const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
        return {
            x: x + Math.cos(halfAngle) * halfRadius,
            y: y + Math.sin(halfAngle) * halfRadius
        };
    }
    tooltipPosition(useFinalPosition) {
        return this.getCenterPoint(useFinalPosition);
    }
    draw(ctx) {
        const { options , circumference  } = this;
        const offset = (options.offset || 0) / 4;
        const spacing = (options.spacing || 0) / 2;
        const circular = options.circular;
        this.pixelMargin = options.borderAlign === 'inner' ? 0.33 : 0;
        this.fullCircles = circumference > helpers_dataset.TAU ? Math.floor(circumference / helpers_dataset.TAU) : 0;
        if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
            return;
        }
        ctx.save();
        const halfAngle = (this.startAngle + this.endAngle) / 2;
        ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);
        const fix = 1 - Math.sin(Math.min(helpers_dataset.PI, circumference || 0));
        const radiusOffset = offset * fix;
        ctx.fillStyle = options.backgroundColor;
        ctx.strokeStyle = options.borderColor;
        drawArc(ctx, this, radiusOffset, spacing, circular);
        drawBorder(ctx, this, radiusOffset, spacing, circular);
        ctx.restore();
    }
}

function setStyle(ctx, options, style = options) {
    ctx.lineCap = helpers_dataset.valueOrDefault(style.borderCapStyle, options.borderCapStyle);
    ctx.setLineDash(helpers_dataset.valueOrDefault(style.borderDash, options.borderDash));
    ctx.lineDashOffset = helpers_dataset.valueOrDefault(style.borderDashOffset, options.borderDashOffset);
    ctx.lineJoin = helpers_dataset.valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);
    ctx.lineWidth = helpers_dataset.valueOrDefault(style.borderWidth, options.borderWidth);
    ctx.strokeStyle = helpers_dataset.valueOrDefault(style.borderColor, options.borderColor);
}
function lineTo(ctx, previous, target) {
    ctx.lineTo(target.x, target.y);
}
 function getLineMethod(options) {
    if (options.stepped) {
        return helpers_dataset._steppedLineTo;
    }
    if (options.tension || options.cubicInterpolationMode === 'monotone') {
        return helpers_dataset._bezierCurveTo;
    }
    return lineTo;
}
function pathVars(points, segment, params = {}) {
    const count = points.length;
    const { start: paramsStart = 0 , end: paramsEnd = count - 1  } = params;
    const { start: segmentStart , end: segmentEnd  } = segment;
    const start = Math.max(paramsStart, segmentStart);
    const end = Math.min(paramsEnd, segmentEnd);
    const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
    return {
        count,
        start,
        loop: segment.loop,
        ilen: end < start && !outside ? count + end - start : end - start
    };
}
 function pathSegment(ctx, line, segment, params) {
    const { points , options  } = line;
    const { count , start , loop , ilen  } = pathVars(points, segment, params);
    const lineMethod = getLineMethod(options);
    let { move =true , reverse  } = params || {};
    let i, point, prev;
    for(i = 0; i <= ilen; ++i){
        point = points[(start + (reverse ? ilen - i : i)) % count];
        if (point.skip) {
            continue;
        } else if (move) {
            ctx.moveTo(point.x, point.y);
            move = false;
        } else {
            lineMethod(ctx, prev, point, reverse, options.stepped);
        }
        prev = point;
    }
    if (loop) {
        point = points[(start + (reverse ? ilen : 0)) % count];
        lineMethod(ctx, prev, point, reverse, options.stepped);
    }
    return !!loop;
}
 function fastPathSegment(ctx, line, segment, params) {
    const points = line.points;
    const { count , start , ilen  } = pathVars(points, segment, params);
    const { move =true , reverse  } = params || {};
    let avgX = 0;
    let countX = 0;
    let i, point, prevX, minY, maxY, lastY;
    const pointIndex = (index)=>(start + (reverse ? ilen - index : index)) % count;
    const drawX = ()=>{
        if (minY !== maxY) {
            ctx.lineTo(avgX, maxY);
            ctx.lineTo(avgX, minY);
            ctx.lineTo(avgX, lastY);
        }
    };
    if (move) {
        point = points[pointIndex(0)];
        ctx.moveTo(point.x, point.y);
    }
    for(i = 0; i <= ilen; ++i){
        point = points[pointIndex(i)];
        if (point.skip) {
            continue;
        }
        const x = point.x;
        const y = point.y;
        const truncX = x | 0;
        if (truncX === prevX) {
            if (y < minY) {
                minY = y;
            } else if (y > maxY) {
                maxY = y;
            }
            avgX = (countX * avgX + x) / ++countX;
        } else {
            drawX();
            ctx.lineTo(x, y);
            prevX = truncX;
            countX = 0;
            minY = maxY = y;
        }
        lastY = y;
    }
    drawX();
}
 function _getSegmentMethod(line) {
    const opts = line.options;
    const borderDash = opts.borderDash && opts.borderDash.length;
    const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== 'monotone' && !opts.stepped && !borderDash;
    return useFastPath ? fastPathSegment : pathSegment;
}
 function _getInterpolationMethod(options) {
    if (options.stepped) {
        return helpers_dataset._steppedInterpolation;
    }
    if (options.tension || options.cubicInterpolationMode === 'monotone') {
        return helpers_dataset._bezierInterpolation;
    }
    return helpers_dataset._pointInLine;
}
function strokePathWithCache(ctx, line, start, count) {
    let path = line._path;
    if (!path) {
        path = line._path = new Path2D();
        if (line.path(path, start, count)) {
            path.closePath();
        }
    }
    setStyle(ctx, line.options);
    ctx.stroke(path);
}
function strokePathDirect(ctx, line, start, count) {
    const { segments , options  } = line;
    const segmentMethod = _getSegmentMethod(line);
    for (const segment of segments){
        setStyle(ctx, options, segment.style);
        ctx.beginPath();
        if (segmentMethod(ctx, line, segment, {
            start,
            end: start + count - 1
        })) {
            ctx.closePath();
        }
        ctx.stroke();
    }
}
const usePath2D = typeof Path2D === 'function';
function draw(ctx, line, start, count) {
    if (usePath2D && !line.options.segment) {
        strokePathWithCache(ctx, line, start, count);
    } else {
        strokePathDirect(ctx, line, start, count);
    }
}
class LineElement extends Element {
    static id = 'line';
 static defaults = {
        borderCapStyle: 'butt',
        borderDash: [],
        borderDashOffset: 0,
        borderJoinStyle: 'miter',
        borderWidth: 3,
        capBezierPoints: true,
        cubicInterpolationMode: 'default',
        fill: false,
        spanGaps: false,
        stepped: false,
        tension: 0
    };
 static defaultRoutes = {
        backgroundColor: 'backgroundColor',
        borderColor: 'borderColor'
    };
    static descriptors = {
        _scriptable: true,
        _indexable: (name)=>name !== 'borderDash' && name !== 'fill'
    };
    constructor(cfg){
        super();
        this.animated = true;
        this.options = undefined;
        this._chart = undefined;
        this._loop = undefined;
        this._fullLoop = undefined;
        this._path = undefined;
        this._points = undefined;
        this._segments = undefined;
        this._decimated = false;
        this._pointsUpdated = false;
        this._datasetIndex = undefined;
        if (cfg) {
            Object.assign(this, cfg);
        }
    }
    updateControlPoints(chartArea, indexAxis) {
        const options = this.options;
        if ((options.tension || options.cubicInterpolationMode === 'monotone') && !options.stepped && !this._pointsUpdated) {
            const loop = options.spanGaps ? this._loop : this._fullLoop;
            helpers_dataset._updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);
            this._pointsUpdated = true;
        }
    }
    set points(points) {
        this._points = points;
        delete this._segments;
        delete this._path;
        this._pointsUpdated = false;
    }
    get points() {
        return this._points;
    }
    get segments() {
        return this._segments || (this._segments = helpers_dataset._computeSegments(this, this.options.segment));
    }
 first() {
        const segments = this.segments;
        const points = this.points;
        return segments.length && points[segments[0].start];
    }
 last() {
        const segments = this.segments;
        const points = this.points;
        const count = segments.length;
        return count && points[segments[count - 1].end];
    }
 interpolate(point, property) {
        const options = this.options;
        const value = point[property];
        const points = this.points;
        const segments = helpers_dataset._boundSegments(this, {
            property,
            start: value,
            end: value
        });
        if (!segments.length) {
            return;
        }
        const result = [];
        const _interpolate = _getInterpolationMethod(options);
        let i, ilen;
        for(i = 0, ilen = segments.length; i < ilen; ++i){
            const { start , end  } = segments[i];
            const p1 = points[start];
            const p2 = points[end];
            if (p1 === p2) {
                result.push(p1);
                continue;
            }
            const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
            const interpolated = _interpolate(p1, p2, t, options.stepped);
            interpolated[property] = point[property];
            result.push(interpolated);
        }
        return result.length === 1 ? result[0] : result;
    }
 pathSegment(ctx, segment, params) {
        const segmentMethod = _getSegmentMethod(this);
        return segmentMethod(ctx, this, segment, params);
    }
 path(ctx, start, count) {
        const segments = this.segments;
        const segmentMethod = _getSegmentMethod(this);
        let loop = this._loop;
        start = start || 0;
        count = count || this.points.length - start;
        for (const segment of segments){
            loop &= segmentMethod(ctx, this, segment, {
                start,
                end: start + count - 1
            });
        }
        return !!loop;
    }
 draw(ctx, chartArea, start, count) {
        const options = this.options || {};
        const points = this.points || [];
        if (points.length && options.borderWidth) {
            ctx.save();
            draw(ctx, this, start, count);
            ctx.restore();
        }
        if (this.animated) {
            this._pointsUpdated = false;
            this._path = undefined;
        }
    }
}

function inRange$1(el, pos, axis, useFinalPosition) {
    const options = el.options;
    const { [axis]: value  } = el.getProps([
        axis
    ], useFinalPosition);
    return Math.abs(pos - value) < options.radius + options.hitRadius;
}
class PointElement extends Element {
    static id = 'point';
    parsed;
    skip;
    stop;
    /**
   * @type {any}
   */ static defaults = {
        borderWidth: 1,
        hitRadius: 1,
        hoverBorderWidth: 1,
        hoverRadius: 4,
        pointStyle: 'circle',
        radius: 3,
        rotation: 0
    };
    /**
   * @type {any}
   */ static defaultRoutes = {
        backgroundColor: 'backgroundColor',
        borderColor: 'borderColor'
    };
    constructor(cfg){
        super();
        this.options = undefined;
        this.parsed = undefined;
        this.skip = undefined;
        this.stop = undefined;
        if (cfg) {
            Object.assign(this, cfg);
        }
    }
    inRange(mouseX, mouseY, useFinalPosition) {
        const options = this.options;
        const { x , y  } = this.getProps([
            'x',
            'y'
        ], useFinalPosition);
        return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);
    }
    inXRange(mouseX, useFinalPosition) {
        return inRange$1(this, mouseX, 'x', useFinalPosition);
    }
    inYRange(mouseY, useFinalPosition) {
        return inRange$1(this, mouseY, 'y', useFinalPosition);
    }
    getCenterPoint(useFinalPosition) {
        const { x , y  } = this.getProps([
            'x',
            'y'
        ], useFinalPosition);
        return {
            x,
            y
        };
    }
    size(options) {
        options = options || this.options || {};
        let radius = options.radius || 0;
        radius = Math.max(radius, radius && options.hoverRadius || 0);
        const borderWidth = radius && options.borderWidth || 0;
        return (radius + borderWidth) * 2;
    }
    draw(ctx, area) {
        const options = this.options;
        if (this.skip || options.radius < 0.1 || !helpers_dataset._isPointInArea(this, area, this.size(options) / 2)) {
            return;
        }
        ctx.strokeStyle = options.borderColor;
        ctx.lineWidth = options.borderWidth;
        ctx.fillStyle = options.backgroundColor;
        helpers_dataset.drawPoint(ctx, options, this.x, this.y);
    }
    getRange() {
        const options = this.options || {};
        // @ts-expect-error Fallbacks should never be hit in practice
        return options.radius + options.hitRadius;
    }
}

function getBarBounds(bar, useFinalPosition) {
    const { x , y , base , width , height  } =  bar.getProps([
        'x',
        'y',
        'base',
        'width',
        'height'
    ], useFinalPosition);
    let left, right, top, bottom, half;
    if (bar.horizontal) {
        half = height / 2;
        left = Math.min(x, base);
        right = Math.max(x, base);
        top = y - half;
        bottom = y + half;
    } else {
        half = width / 2;
        left = x - half;
        right = x + half;
        top = Math.min(y, base);
        bottom = Math.max(y, base);
    }
    return {
        left,
        top,
        right,
        bottom
    };
}
function skipOrLimit(skip, value, min, max) {
    return skip ? 0 : helpers_dataset._limitValue(value, min, max);
}
function parseBorderWidth(bar, maxW, maxH) {
    const value = bar.options.borderWidth;
    const skip = bar.borderSkipped;
    const o = helpers_dataset.toTRBL(value);
    return {
        t: skipOrLimit(skip.top, o.top, 0, maxH),
        r: skipOrLimit(skip.right, o.right, 0, maxW),
        b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),
        l: skipOrLimit(skip.left, o.left, 0, maxW)
    };
}
function parseBorderRadius(bar, maxW, maxH) {
    const { enableBorderRadius  } = bar.getProps([
        'enableBorderRadius'
    ]);
    const value = bar.options.borderRadius;
    const o = helpers_dataset.toTRBLCorners(value);
    const maxR = Math.min(maxW, maxH);
    const skip = bar.borderSkipped;
    const enableBorder = enableBorderRadius || helpers_dataset.isObject(value);
    return {
        topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),
        topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),
        bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),
        bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)
    };
}
function boundingRects(bar) {
    const bounds = getBarBounds(bar);
    const width = bounds.right - bounds.left;
    const height = bounds.bottom - bounds.top;
    const border = parseBorderWidth(bar, width / 2, height / 2);
    const radius = parseBorderRadius(bar, width / 2, height / 2);
    return {
        outer: {
            x: bounds.left,
            y: bounds.top,
            w: width,
            h: height,
            radius
        },
        inner: {
            x: bounds.left + border.l,
            y: bounds.top + border.t,
            w: width - border.l - border.r,
            h: height - border.t - border.b,
            radius: {
                topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
                topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
                bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
                bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
            }
        }
    };
}
function inRange(bar, x, y, useFinalPosition) {
    const skipX = x === null;
    const skipY = y === null;
    const skipBoth = skipX && skipY;
    const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
    return bounds && (skipX || helpers_dataset._isBetween(x, bounds.left, bounds.right)) && (skipY || helpers_dataset._isBetween(y, bounds.top, bounds.bottom));
}
function hasRadius(radius) {
    return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
}
 function addNormalRectPath(ctx, rect) {
    ctx.rect(rect.x, rect.y, rect.w, rect.h);
}
function inflateRect(rect, amount, refRect = {}) {
    const x = rect.x !== refRect.x ? -amount : 0;
    const y = rect.y !== refRect.y ? -amount : 0;
    const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
    const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
    return {
        x: rect.x + x,
        y: rect.y + y,
        w: rect.w + w,
        h: rect.h + h,
        radius: rect.radius
    };
}
class BarElement extends Element {
    static id = 'bar';
 static defaults = {
        borderSkipped: 'start',
        borderWidth: 0,
        borderRadius: 0,
        inflateAmount: 'auto',
        pointStyle: undefined
    };
 static defaultRoutes = {
        backgroundColor: 'backgroundColor',
        borderColor: 'borderColor'
    };
    constructor(cfg){
        super();
        this.options = undefined;
        this.horizontal = undefined;
        this.base = undefined;
        this.width = undefined;
        this.height = undefined;
        this.inflateAmount = undefined;
        if (cfg) {
            Object.assign(this, cfg);
        }
    }
    draw(ctx) {
        const { inflateAmount , options: { borderColor , backgroundColor  }  } = this;
        const { inner , outer  } = boundingRects(this);
        const addRectPath = hasRadius(outer.radius) ? helpers_dataset.addRoundedRectPath : addNormalRectPath;
        ctx.save();
        if (outer.w !== inner.w || outer.h !== inner.h) {
            ctx.beginPath();
            addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
            ctx.clip();
            addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
            ctx.fillStyle = borderColor;
            ctx.fill('evenodd');
        }
        ctx.beginPath();
        addRectPath(ctx, inflateRect(inner, inflateAmount));
        ctx.fillStyle = backgroundColor;
        ctx.fill();
        ctx.restore();
    }
    inRange(mouseX, mouseY, useFinalPosition) {
        return inRange(this, mouseX, mouseY, useFinalPosition);
    }
    inXRange(mouseX, useFinalPosition) {
        return inRange(this, mouseX, null, useFinalPosition);
    }
    inYRange(mouseY, useFinalPosition) {
        return inRange(this, null, mouseY, useFinalPosition);
    }
    getCenterPoint(useFinalPosition) {
        const { x , y , base , horizontal  } =  this.getProps([
            'x',
            'y',
            'base',
            'horizontal'
        ], useFinalPosition);
        return {
            x: horizontal ? (x + base) / 2 : x,
            y: horizontal ? y : (y + base) / 2
        };
    }
    getRange(axis) {
        return axis === 'x' ? this.width / 2 : this.height / 2;
    }
}

var elements = /*#__PURE__*/Object.freeze({
__proto__: null,
ArcElement: ArcElement,
BarElement: BarElement,
LineElement: LineElement,
PointElement: PointElement
});

const BORDER_COLORS = [
    'rgb(54, 162, 235)',
    'rgb(255, 99, 132)',
    'rgb(255, 159, 64)',
    'rgb(255, 205, 86)',
    'rgb(75, 192, 192)',
    'rgb(153, 102, 255)',
    'rgb(201, 203, 207)' // grey
];
// Border colors with 50% transparency
const BACKGROUND_COLORS = /* #__PURE__ */ BORDER_COLORS.map((color)=>color.replace('rgb(', 'rgba(').replace(')', ', 0.5)'));
function getBorderColor(i) {
    return BORDER_COLORS[i % BORDER_COLORS.length];
}
function getBackgroundColor(i) {
    return BACKGROUND_COLORS[i % BACKGROUND_COLORS.length];
}
function colorizeDefaultDataset(dataset, i) {
    dataset.borderColor = getBorderColor(i);
    dataset.backgroundColor = getBackgroundColor(i);
    return ++i;
}
function colorizeDoughnutDataset(dataset, i) {
    dataset.backgroundColor = dataset.data.map(()=>getBorderColor(i++));
    return i;
}
function colorizePolarAreaDataset(dataset, i) {
    dataset.backgroundColor = dataset.data.map(()=>getBackgroundColor(i++));
    return i;
}
function getColorizer(chart) {
    let i = 0;
    return (dataset, datasetIndex)=>{
        const controller = chart.getDatasetMeta(datasetIndex).controller;
        if (controller instanceof DoughnutController) {
            i = colorizeDoughnutDataset(dataset, i);
        } else if (controller instanceof PolarAreaController) {
            i = colorizePolarAreaDataset(dataset, i);
        } else if (controller) {
            i = colorizeDefaultDataset(dataset, i);
        }
    };
}
function containsColorsDefinitions(descriptors) {
    let k;
    for(k in descriptors){
        if (descriptors[k].borderColor || descriptors[k].backgroundColor) {
            return true;
        }
    }
    return false;
}
function containsColorsDefinition(descriptor) {
    return descriptor && (descriptor.borderColor || descriptor.backgroundColor);
}
function containsDefaultColorsDefenitions() {
    return helpers_dataset.defaults.borderColor !== 'rgba(0,0,0,0.1)' || helpers_dataset.defaults.backgroundColor !== 'rgba(0,0,0,0.1)';
}
var plugin_colors = {
    id: 'colors',
    defaults: {
        enabled: true,
        forceOverride: false
    },
    beforeLayout (chart, _args, options) {
        if (!options.enabled) {
            return;
        }
        const { data: { datasets  } , options: chartOptions  } = chart.config;
        const { elements  } = chartOptions;
        const containsColorDefenition = containsColorsDefinitions(datasets) || containsColorsDefinition(chartOptions) || elements && containsColorsDefinitions(elements) || containsDefaultColorsDefenitions();
        if (!options.forceOverride && containsColorDefenition) {
            return;
        }
        const colorizer = getColorizer(chart);
        datasets.forEach(colorizer);
    }
};

function lttbDecimation(data, start, count, availableWidth, options) {
 const samples = options.samples || availableWidth;
    if (samples >= count) {
        return data.slice(start, start + count);
    }
    const decimated = [];
    const bucketWidth = (count - 2) / (samples - 2);
    let sampledIndex = 0;
    const endIndex = start + count - 1;
    let a = start;
    let i, maxAreaPoint, maxArea, area, nextA;
    decimated[sampledIndex++] = data[a];
    for(i = 0; i < samples - 2; i++){
        let avgX = 0;
        let avgY = 0;
        let j;
        const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;
        const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;
        const avgRangeLength = avgRangeEnd - avgRangeStart;
        for(j = avgRangeStart; j < avgRangeEnd; j++){
            avgX += data[j].x;
            avgY += data[j].y;
        }
        avgX /= avgRangeLength;
        avgY /= avgRangeLength;
        const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;
        const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;
        const { x: pointAx , y: pointAy  } = data[a];
        maxArea = area = -1;
        for(j = rangeOffs; j < rangeTo; j++){
            area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));
            if (area > maxArea) {
                maxArea = area;
                maxAreaPoint = data[j];
                nextA = j;
            }
        }
        decimated[sampledIndex++] = maxAreaPoint;
        a = nextA;
    }
    decimated[sampledIndex++] = data[endIndex];
    return decimated;
}
function minMaxDecimation(data, start, count, availableWidth) {
    let avgX = 0;
    let countX = 0;
    let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;
    const decimated = [];
    const endIndex = start + count - 1;
    const xMin = data[start].x;
    const xMax = data[endIndex].x;
    const dx = xMax - xMin;
    for(i = start; i < start + count; ++i){
        point = data[i];
        x = (point.x - xMin) / dx * availableWidth;
        y = point.y;
        const truncX = x | 0;
        if (truncX === prevX) {
            if (y < minY) {
                minY = y;
                minIndex = i;
            } else if (y > maxY) {
                maxY = y;
                maxIndex = i;
            }
            avgX = (countX * avgX + point.x) / ++countX;
        } else {
            const lastIndex = i - 1;
            if (!helpers_dataset.isNullOrUndef(minIndex) && !helpers_dataset.isNullOrUndef(maxIndex)) {
                const intermediateIndex1 = Math.min(minIndex, maxIndex);
                const intermediateIndex2 = Math.max(minIndex, maxIndex);
                if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {
                    decimated.push({
                        ...data[intermediateIndex1],
                        x: avgX
                    });
                }
                if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {
                    decimated.push({
                        ...data[intermediateIndex2],
                        x: avgX
                    });
                }
            }
            if (i > 0 && lastIndex !== startIndex) {
                decimated.push(data[lastIndex]);
            }
            decimated.push(point);
            prevX = truncX;
            countX = 0;
            minY = maxY = y;
            minIndex = maxIndex = startIndex = i;
        }
    }
    return decimated;
}
function cleanDecimatedDataset(dataset) {
    if (dataset._decimated) {
        const data = dataset._data;
        delete dataset._decimated;
        delete dataset._data;
        Object.defineProperty(dataset, 'data', {
            configurable: true,
            enumerable: true,
            writable: true,
            value: data
        });
    }
}
function cleanDecimatedData(chart) {
    chart.data.datasets.forEach((dataset)=>{
        cleanDecimatedDataset(dataset);
    });
}
function getStartAndCountOfVisiblePointsSimplified(meta, points) {
    const pointCount = points.length;
    let start = 0;
    let count;
    const { iScale  } = meta;
    const { min , max , minDefined , maxDefined  } = iScale.getUserBounds();
    if (minDefined) {
        start = helpers_dataset._limitValue(helpers_dataset._lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);
    }
    if (maxDefined) {
        count = helpers_dataset._limitValue(helpers_dataset._lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;
    } else {
        count = pointCount - start;
    }
    return {
        start,
        count
    };
}
var plugin_decimation = {
    id: 'decimation',
    defaults: {
        algorithm: 'min-max',
        enabled: false
    },
    beforeElementsUpdate: (chart, args, options)=>{
        if (!options.enabled) {
            cleanDecimatedData(chart);
            return;
        }
        const availableWidth = chart.width;
        chart.data.datasets.forEach((dataset, datasetIndex)=>{
            const { _data , indexAxis  } = dataset;
            const meta = chart.getDatasetMeta(datasetIndex);
            const data = _data || dataset.data;
            if (helpers_dataset.resolve([
                indexAxis,
                chart.options.indexAxis
            ]) === 'y') {
                return;
            }
            if (!meta.controller.supportsDecimation) {
                return;
            }
            const xAxis = chart.scales[meta.xAxisID];
            if (xAxis.type !== 'linear' && xAxis.type !== 'time') {
                return;
            }
            if (chart.options.parsing) {
                return;
            }
            let { start , count  } = getStartAndCountOfVisiblePointsSimplified(meta, data);
            const threshold = options.threshold || 4 * availableWidth;
            if (count <= threshold) {
                cleanDecimatedDataset(dataset);
                return;
            }
            if (helpers_dataset.isNullOrUndef(_data)) {
                dataset._data = data;
                delete dataset.data;
                Object.defineProperty(dataset, 'data', {
                    configurable: true,
                    enumerable: true,
                    get: function() {
                        return this._decimated;
                    },
                    set: function(d) {
                        this._data = d;
                    }
                });
            }
            let decimated;
            switch(options.algorithm){
                case 'lttb':
                    decimated = lttbDecimation(data, start, count, availableWidth, options);
                    break;
                case 'min-max':
                    decimated = minMaxDecimation(data, start, count, availableWidth);
                    break;
                default:
                    throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);
            }
            dataset._decimated = decimated;
        });
    },
    destroy (chart) {
        cleanDecimatedData(chart);
    }
};

function _segments(line, target, property) {
    const segments = line.segments;
    const points = line.points;
    const tpoints = target.points;
    const parts = [];
    for (const segment of segments){
        let { start , end  } = segment;
        end = _findSegmentEnd(start, end, points);
        const bounds = _getBounds(property, points[start], points[end], segment.loop);
        if (!target.segments) {
            parts.push({
                source: segment,
                target: bounds,
                start: points[start],
                end: points[end]
            });
            continue;
        }
        const targetSegments = helpers_dataset._boundSegments(target, bounds);
        for (const tgt of targetSegments){
            const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
            const fillSources = helpers_dataset._boundSegment(segment, points, subBounds);
            for (const fillSource of fillSources){
                parts.push({
                    source: fillSource,
                    target: tgt,
                    start: {
                        [property]: _getEdge(bounds, subBounds, 'start', Math.max)
                    },
                    end: {
                        [property]: _getEdge(bounds, subBounds, 'end', Math.min)
                    }
                });
            }
        }
    }
    return parts;
}
function _getBounds(property, first, last, loop) {
    if (loop) {
        return;
    }
    let start = first[property];
    let end = last[property];
    if (property === 'angle') {
        start = helpers_dataset._normalizeAngle(start);
        end = helpers_dataset._normalizeAngle(end);
    }
    return {
        property,
        start,
        end
    };
}
function _pointsFromSegments(boundary, line) {
    const { x =null , y =null  } = boundary || {};
    const linePoints = line.points;
    const points = [];
    line.segments.forEach(({ start , end  })=>{
        end = _findSegmentEnd(start, end, linePoints);
        const first = linePoints[start];
        const last = linePoints[end];
        if (y !== null) {
            points.push({
                x: first.x,
                y
            });
            points.push({
                x: last.x,
                y
            });
        } else if (x !== null) {
            points.push({
                x,
                y: first.y
            });
            points.push({
                x,
                y: last.y
            });
        }
    });
    return points;
}
function _findSegmentEnd(start, end, points) {
    for(; end > start; end--){
        const point = points[end];
        if (!isNaN(point.x) && !isNaN(point.y)) {
            break;
        }
    }
    return end;
}
function _getEdge(a, b, prop, fn) {
    if (a && b) {
        return fn(a[prop], b[prop]);
    }
    return a ? a[prop] : b ? b[prop] : 0;
}

function _createBoundaryLine(boundary, line) {
    let points = [];
    let _loop = false;
    if (helpers_dataset.isArray(boundary)) {
        _loop = true;
        points = boundary;
    } else {
        points = _pointsFromSegments(boundary, line);
    }
    return points.length ? new LineElement({
        points,
        options: {
            tension: 0
        },
        _loop,
        _fullLoop: _loop
    }) : null;
}
function _shouldApplyFill(source) {
    return source && source.fill !== false;
}

function _resolveTarget(sources, index, propagate) {
    const source = sources[index];
    let fill = source.fill;
    const visited = [
        index
    ];
    let target;
    if (!propagate) {
        return fill;
    }
    while(fill !== false && visited.indexOf(fill) === -1){
        if (!helpers_dataset.isNumberFinite(fill)) {
            return fill;
        }
        target = sources[fill];
        if (!target) {
            return false;
        }
        if (target.visible) {
            return fill;
        }
        visited.push(fill);
        fill = target.fill;
    }
    return false;
}
 function _decodeFill(line, index, count) {
     const fill = parseFillOption(line);
    if (helpers_dataset.isObject(fill)) {
        return isNaN(fill.value) ? false : fill;
    }
    let target = parseFloat(fill);
    if (helpers_dataset.isNumberFinite(target) && Math.floor(target) === target) {
        return decodeTargetIndex(fill[0], index, target, count);
    }
    return [
        'origin',
        'start',
        'end',
        'stack',
        'shape'
    ].indexOf(fill) >= 0 && fill;
}
function decodeTargetIndex(firstCh, index, target, count) {
    if (firstCh === '-' || firstCh === '+') {
        target = index + target;
    }
    if (target === index || target < 0 || target >= count) {
        return false;
    }
    return target;
}
 function _getTargetPixel(fill, scale) {
    let pixel = null;
    if (fill === 'start') {
        pixel = scale.bottom;
    } else if (fill === 'end') {
        pixel = scale.top;
    } else if (helpers_dataset.isObject(fill)) {
        pixel = scale.getPixelForValue(fill.value);
    } else if (scale.getBasePixel) {
        pixel = scale.getBasePixel();
    }
    return pixel;
}
 function _getTargetValue(fill, scale, startValue) {
    let value;
    if (fill === 'start') {
        value = startValue;
    } else if (fill === 'end') {
        value = scale.options.reverse ? scale.min : scale.max;
    } else if (helpers_dataset.isObject(fill)) {
        value = fill.value;
    } else {
        value = scale.getBaseValue();
    }
    return value;
}
 function parseFillOption(line) {
    const options = line.options;
    const fillOption = options.fill;
    let fill = helpers_dataset.valueOrDefault(fillOption && fillOption.target, fillOption);
    if (fill === undefined) {
        fill = !!options.backgroundColor;
    }
    if (fill === false || fill === null) {
        return false;
    }
    if (fill === true) {
        return 'origin';
    }
    return fill;
}

function _buildStackLine(source) {
    const { scale , index , line  } = source;
    const points = [];
    const segments = line.segments;
    const sourcePoints = line.points;
    const linesBelow = getLinesBelow(scale, index);
    linesBelow.push(_createBoundaryLine({
        x: null,
        y: scale.bottom
    }, line));
    for(let i = 0; i < segments.length; i++){
        const segment = segments[i];
        for(let j = segment.start; j <= segment.end; j++){
            addPointsBelow(points, sourcePoints[j], linesBelow);
        }
    }
    return new LineElement({
        points,
        options: {}
    });
}
 function getLinesBelow(scale, index) {
    const below = [];
    const metas = scale.getMatchingVisibleMetas('line');
    for(let i = 0; i < metas.length; i++){
        const meta = metas[i];
        if (meta.index === index) {
            break;
        }
        if (!meta.hidden) {
            below.unshift(meta.dataset);
        }
    }
    return below;
}
 function addPointsBelow(points, sourcePoint, linesBelow) {
    const postponed = [];
    for(let j = 0; j < linesBelow.length; j++){
        const line = linesBelow[j];
        const { first , last , point  } = findPoint(line, sourcePoint, 'x');
        if (!point || first && last) {
            continue;
        }
        if (first) {
            postponed.unshift(point);
        } else {
            points.push(point);
            if (!last) {
                break;
            }
        }
    }
    points.push(...postponed);
}
 function findPoint(line, sourcePoint, property) {
    const point = line.interpolate(sourcePoint, property);
    if (!point) {
        return {};
    }
    const pointValue = point[property];
    const segments = line.segments;
    const linePoints = line.points;
    let first = false;
    let last = false;
    for(let i = 0; i < segments.length; i++){
        const segment = segments[i];
        const firstValue = linePoints[segment.start][property];
        const lastValue = linePoints[segment.end][property];
        if (helpers_dataset._isBetween(pointValue, firstValue, lastValue)) {
            first = pointValue === firstValue;
            last = pointValue === lastValue;
            break;
        }
    }
    return {
        first,
        last,
        point
    };
}

class simpleArc {
    constructor(opts){
        this.x = opts.x;
        this.y = opts.y;
        this.radius = opts.radius;
    }
    pathSegment(ctx, bounds, opts) {
        const { x , y , radius  } = this;
        bounds = bounds || {
            start: 0,
            end: helpers_dataset.TAU
        };
        ctx.arc(x, y, radius, bounds.end, bounds.start, true);
        return !opts.bounds;
    }
    interpolate(point) {
        const { x , y , radius  } = this;
        const angle = point.angle;
        return {
            x: x + Math.cos(angle) * radius,
            y: y + Math.sin(angle) * radius,
            angle
        };
    }
}

function _getTarget(source) {
    const { chart , fill , line  } = source;
    if (helpers_dataset.isNumberFinite(fill)) {
        return getLineByIndex(chart, fill);
    }
    if (fill === 'stack') {
        return _buildStackLine(source);
    }
    if (fill === 'shape') {
        return true;
    }
    const boundary = computeBoundary(source);
    if (boundary instanceof simpleArc) {
        return boundary;
    }
    return _createBoundaryLine(boundary, line);
}
 function getLineByIndex(chart, index) {
    const meta = chart.getDatasetMeta(index);
    const visible = meta && chart.isDatasetVisible(index);
    return visible ? meta.dataset : null;
}
function computeBoundary(source) {
    const scale = source.scale || {};
    if (scale.getPointPositionForValue) {
        return computeCircularBoundary(source);
    }
    return computeLinearBoundary(source);
}
function computeLinearBoundary(source) {
    const { scale ={} , fill  } = source;
    const pixel = _getTargetPixel(fill, scale);
    if (helpers_dataset.isNumberFinite(pixel)) {
        const horizontal = scale.isHorizontal();
        return {
            x: horizontal ? pixel : null,
            y: horizontal ? null : pixel
        };
    }
    return null;
}
function computeCircularBoundary(source) {
    const { scale , fill  } = source;
    const options = scale.options;
    const length = scale.getLabels().length;
    const start = options.reverse ? scale.max : scale.min;
    const value = _getTargetValue(fill, scale, start);
    const target = [];
    if (options.grid.circular) {
        const center = scale.getPointPositionForValue(0, start);
        return new simpleArc({
            x: center.x,
            y: center.y,
            radius: scale.getDistanceFromCenterForValue(value)
        });
    }
    for(let i = 0; i < length; ++i){
        target.push(scale.getPointPositionForValue(i, value));
    }
    return target;
}

function _drawfill(ctx, source, area) {
    const target = _getTarget(source);
    const { chart , index , line , scale , axis  } = source;
    const lineOpts = line.options;
    const fillOption = lineOpts.fill;
    const color = lineOpts.backgroundColor;
    const { above =color , below =color  } = fillOption || {};
    const meta = chart.getDatasetMeta(index);
    const clip = helpers_dataset.getDatasetClipArea(chart, meta);
    if (target && line.points.length) {
        helpers_dataset.clipArea(ctx, area);
        doFill(ctx, {
            line,
            target,
            above,
            below,
            area,
            scale,
            axis,
            clip
        });
        helpers_dataset.unclipArea(ctx);
    }
}
function doFill(ctx, cfg) {
    const { line , target , above , below , area , scale , clip  } = cfg;
    const property = line._loop ? 'angle' : cfg.axis;
    ctx.save();
    let fillColor = below;
    if (below !== above) {
        if (property === 'x') {
            clipVertical(ctx, target, area.top);
            fill(ctx, {
                line,
                target,
                color: above,
                scale,
                property,
                clip
            });
            ctx.restore();
            ctx.save();
            clipVertical(ctx, target, area.bottom);
        } else if (property === 'y') {
            clipHorizontal(ctx, target, area.left);
            fill(ctx, {
                line,
                target,
                color: below,
                scale,
                property,
                clip
            });
            ctx.restore();
            ctx.save();
            clipHorizontal(ctx, target, area.right);
            fillColor = above;
        }
    }
    fill(ctx, {
        line,
        target,
        color: fillColor,
        scale,
        property,
        clip
    });
    ctx.restore();
}
function clipVertical(ctx, target, clipY) {
    const { segments , points  } = target;
    let first = true;
    let lineLoop = false;
    ctx.beginPath();
    for (const segment of segments){
        const { start , end  } = segment;
        const firstPoint = points[start];
        const lastPoint = points[_findSegmentEnd(start, end, points)];
        if (first) {
            ctx.moveTo(firstPoint.x, firstPoint.y);
            first = false;
        } else {
            ctx.lineTo(firstPoint.x, clipY);
            ctx.lineTo(firstPoint.x, firstPoint.y);
        }
        lineLoop = !!target.pathSegment(ctx, segment, {
            move: lineLoop
        });
        if (lineLoop) {
            ctx.closePath();
        } else {
            ctx.lineTo(lastPoint.x, clipY);
        }
    }
    ctx.lineTo(target.first().x, clipY);
    ctx.closePath();
    ctx.clip();
}
function clipHorizontal(ctx, target, clipX) {
    const { segments , points  } = target;
    let first = true;
    let lineLoop = false;
    ctx.beginPath();
    for (const segment of segments){
        const { start , end  } = segment;
        const firstPoint = points[start];
        const lastPoint = points[_findSegmentEnd(start, end, points)];
        if (first) {
            ctx.moveTo(firstPoint.x, firstPoint.y);
            first = false;
        } else {
            ctx.lineTo(clipX, firstPoint.y);
            ctx.lineTo(firstPoint.x, firstPoint.y);
        }
        lineLoop = !!target.pathSegment(ctx, segment, {
            move: lineLoop
        });
        if (lineLoop) {
            ctx.closePath();
        } else {
            ctx.lineTo(clipX, lastPoint.y);
        }
    }
    ctx.lineTo(clipX, target.first().y);
    ctx.closePath();
    ctx.clip();
}
function fill(ctx, cfg) {
    const { line , target , property , color , scale , clip  } = cfg;
    const segments = _segments(line, target, property);
    for (const { source: src , target: tgt , start , end  } of segments){
        const { style: { backgroundColor =color  } = {}  } = src;
        const notShape = target !== true;
        ctx.save();
        ctx.fillStyle = backgroundColor;
        clipBounds(ctx, scale, clip, notShape && _getBounds(property, start, end));
        ctx.beginPath();
        const lineLoop = !!line.pathSegment(ctx, src);
        let loop;
        if (notShape) {
            if (lineLoop) {
                ctx.closePath();
            } else {
                interpolatedLineTo(ctx, target, end, property);
            }
            const targetLoop = !!target.pathSegment(ctx, tgt, {
                move: lineLoop,
                reverse: true
            });
            loop = lineLoop && targetLoop;
            if (!loop) {
                interpolatedLineTo(ctx, target, start, property);
            }
        }
        ctx.closePath();
        ctx.fill(loop ? 'evenodd' : 'nonzero');
        ctx.restore();
    }
}
function clipBounds(ctx, scale, clip, bounds) {
    const chartArea = scale.chart.chartArea;
    const { property , start , end  } = bounds || {};
    if (property === 'x' || property === 'y') {
        let left, top, right, bottom;
        if (property === 'x') {
            left = start;
            top = chartArea.top;
            right = end;
            bottom = chartArea.bottom;
        } else {
            left = chartArea.left;
            top = start;
            right = chartArea.right;
            bottom = end;
        }
        ctx.beginPath();
        if (clip) {
            left = Math.max(left, clip.left);
            right = Math.min(right, clip.right);
            top = Math.max(top, clip.top);
            bottom = Math.min(bottom, clip.bottom);
        }
        ctx.rect(left, top, right - left, bottom - top);
        ctx.clip();
    }
}
function interpolatedLineTo(ctx, target, point, property) {
    const interpolatedPoint = target.interpolate(point, property);
    if (interpolatedPoint) {
        ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
    }
}

var index = {
    id: 'filler',
    afterDatasetsUpdate (chart, _args, options) {
        const count = (chart.data.datasets || []).length;
        const sources = [];
        let meta, i, line, source;
        for(i = 0; i < count; ++i){
            meta = chart.getDatasetMeta(i);
            line = meta.dataset;
            source = null;
            if (line && line.options && line instanceof LineElement) {
                source = {
                    visible: chart.isDatasetVisible(i),
                    index: i,
                    fill: _decodeFill(line, i, count),
                    chart,
                    axis: meta.controller.options.indexAxis,
                    scale: meta.vScale,
                    line
                };
            }
            meta.$filler = source;
            sources.push(source);
        }
        for(i = 0; i < count; ++i){
            source = sources[i];
            if (!source || source.fill === false) {
                continue;
            }
            source.fill = _resolveTarget(sources, i, options.propagate);
        }
    },
    beforeDraw (chart, _args, options) {
        const draw = options.drawTime === 'beforeDraw';
        const metasets = chart.getSortedVisibleDatasetMetas();
        const area = chart.chartArea;
        for(let i = metasets.length - 1; i >= 0; --i){
            const source = metasets[i].$filler;
            if (!source) {
                continue;
            }
            source.line.updateControlPoints(area, source.axis);
            if (draw && source.fill) {
                _drawfill(chart.ctx, source, area);
            }
        }
    },
    beforeDatasetsDraw (chart, _args, options) {
        if (options.drawTime !== 'beforeDatasetsDraw') {
            return;
        }
        const metasets = chart.getSortedVisibleDatasetMetas();
        for(let i = metasets.length - 1; i >= 0; --i){
            const source = metasets[i].$filler;
            if (_shouldApplyFill(source)) {
                _drawfill(chart.ctx, source, chart.chartArea);
            }
        }
    },
    beforeDatasetDraw (chart, args, options) {
        const source = args.meta.$filler;
        if (!_shouldApplyFill(source) || options.drawTime !== 'beforeDatasetDraw') {
            return;
        }
        _drawfill(chart.ctx, source, chart.chartArea);
    },
    defaults: {
        propagate: true,
        drawTime: 'beforeDatasetDraw'
    }
};

const getBoxSize = (labelOpts, fontSize)=>{
    let { boxHeight =fontSize , boxWidth =fontSize  } = labelOpts;
    if (labelOpts.usePointStyle) {
        boxHeight = Math.min(boxHeight, fontSize);
        boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
    }
    return {
        boxWidth,
        boxHeight,
        itemHeight: Math.max(fontSize, boxHeight)
    };
};
const itemsEqual = (a, b)=>a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
class Legend extends Element {
 constructor(config){
        super();
        this._added = false;
        this.legendHitBoxes = [];
 this._hoveredItem = null;
        this.doughnutMode = false;
        this.chart = config.chart;
        this.options = config.options;
        this.ctx = config.ctx;
        this.legendItems = undefined;
        this.columnSizes = undefined;
        this.lineWidths = undefined;
        this.maxHeight = undefined;
        this.maxWidth = undefined;
        this.top = undefined;
        this.bottom = undefined;
        this.left = undefined;
        this.right = undefined;
        this.height = undefined;
        this.width = undefined;
        this._margins = undefined;
        this.position = undefined;
        this.weight = undefined;
        this.fullSize = undefined;
    }
    update(maxWidth, maxHeight, margins) {
        this.maxWidth = maxWidth;
        this.maxHeight = maxHeight;
        this._margins = margins;
        this.setDimensions();
        this.buildLabels();
        this.fit();
    }
    setDimensions() {
        if (this.isHorizontal()) {
            this.width = this.maxWidth;
            this.left = this._margins.left;
            this.right = this.width;
        } else {
            this.height = this.maxHeight;
            this.top = this._margins.top;
            this.bottom = this.height;
        }
    }
    buildLabels() {
        const labelOpts = this.options.labels || {};
        let legendItems = helpers_dataset.callback(labelOpts.generateLabels, [
            this.chart
        ], this) || [];
        if (labelOpts.filter) {
            legendItems = legendItems.filter((item)=>labelOpts.filter(item, this.chart.data));
        }
        if (labelOpts.sort) {
            legendItems = legendItems.sort((a, b)=>labelOpts.sort(a, b, this.chart.data));
        }
        if (this.options.reverse) {
            legendItems.reverse();
        }
        this.legendItems = legendItems;
    }
    fit() {
        const { options , ctx  } = this;
        if (!options.display) {
            this.width = this.height = 0;
            return;
        }
        const labelOpts = options.labels;
        const labelFont = helpers_dataset.toFont(labelOpts.font);
        const fontSize = labelFont.size;
        const titleHeight = this._computeTitleHeight();
        const { boxWidth , itemHeight  } = getBoxSize(labelOpts, fontSize);
        let width, height;
        ctx.font = labelFont.string;
        if (this.isHorizontal()) {
            width = this.maxWidth;
            height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
        } else {
            height = this.maxHeight;
            width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;
        }
        this.width = Math.min(width, options.maxWidth || this.maxWidth);
        this.height = Math.min(height, options.maxHeight || this.maxHeight);
    }
 _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
        const { ctx , maxWidth , options: { labels: { padding  }  }  } = this;
        const hitboxes = this.legendHitBoxes = [];
        const lineWidths = this.lineWidths = [
            0
        ];
        const lineHeight = itemHeight + padding;
        let totalHeight = titleHeight;
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        let row = -1;
        let top = -lineHeight;
        this.legendItems.forEach((legendItem, i)=>{
            const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
            if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
                totalHeight += lineHeight;
                lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
                top += lineHeight;
                row++;
            }
            hitboxes[i] = {
                left: 0,
                top,
                row,
                width: itemWidth,
                height: itemHeight
            };
            lineWidths[lineWidths.length - 1] += itemWidth + padding;
        });
        return totalHeight;
    }
    _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {
        const { ctx , maxHeight , options: { labels: { padding  }  }  } = this;
        const hitboxes = this.legendHitBoxes = [];
        const columnSizes = this.columnSizes = [];
        const heightLimit = maxHeight - titleHeight;
        let totalWidth = padding;
        let currentColWidth = 0;
        let currentColHeight = 0;
        let left = 0;
        let col = 0;
        this.legendItems.forEach((legendItem, i)=>{
            const { itemWidth , itemHeight  } = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);
            if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
                totalWidth += currentColWidth + padding;
                columnSizes.push({
                    width: currentColWidth,
                    height: currentColHeight
                });
                left += currentColWidth + padding;
                col++;
                currentColWidth = currentColHeight = 0;
            }
            hitboxes[i] = {
                left,
                top: currentColHeight,
                col,
                width: itemWidth,
                height: itemHeight
            };
            currentColWidth = Math.max(currentColWidth, itemWidth);
            currentColHeight += itemHeight + padding;
        });
        totalWidth += currentColWidth;
        columnSizes.push({
            width: currentColWidth,
            height: currentColHeight
        });
        return totalWidth;
    }
    adjustHitBoxes() {
        if (!this.options.display) {
            return;
        }
        const titleHeight = this._computeTitleHeight();
        const { legendHitBoxes: hitboxes , options: { align , labels: { padding  } , rtl  }  } = this;
        const rtlHelper = helpers_dataset.getRtlAdapter(rtl, this.left, this.width);
        if (this.isHorizontal()) {
            let row = 0;
            let left = helpers_dataset._alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
            for (const hitbox of hitboxes){
                if (row !== hitbox.row) {
                    row = hitbox.row;
                    left = helpers_dataset._alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
                }
                hitbox.top += this.top + titleHeight + padding;
                hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
                left += hitbox.width + padding;
            }
        } else {
            let col = 0;
            let top = helpers_dataset._alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
            for (const hitbox of hitboxes){
                if (hitbox.col !== col) {
                    col = hitbox.col;
                    top = helpers_dataset._alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
                }
                hitbox.top = top;
                hitbox.left += this.left + padding;
                hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
                top += hitbox.height + padding;
            }
        }
    }
    isHorizontal() {
        return this.options.position === 'top' || this.options.position === 'bottom';
    }
    draw() {
        if (this.options.display) {
            const ctx = this.ctx;
            helpers_dataset.clipArea(ctx, this);
            this._draw();
            helpers_dataset.unclipArea(ctx);
        }
    }
 _draw() {
        const { options: opts , columnSizes , lineWidths , ctx  } = this;
        const { align , labels: labelOpts  } = opts;
        const defaultColor = helpers_dataset.defaults.color;
        const rtlHelper = helpers_dataset.getRtlAdapter(opts.rtl, this.left, this.width);
        const labelFont = helpers_dataset.toFont(labelOpts.font);
        const { padding  } = labelOpts;
        const fontSize = labelFont.size;
        const halfFontSize = fontSize / 2;
        let cursor;
        this.drawTitle();
        ctx.textAlign = rtlHelper.textAlign('left');
        ctx.textBaseline = 'middle';
        ctx.lineWidth = 0.5;
        ctx.font = labelFont.string;
        const { boxWidth , boxHeight , itemHeight  } = getBoxSize(labelOpts, fontSize);
        const drawLegendBox = function(x, y, legendItem) {
            if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
                return;
            }
            ctx.save();
            const lineWidth = helpers_dataset.valueOrDefault(legendItem.lineWidth, 1);
            ctx.fillStyle = helpers_dataset.valueOrDefault(legendItem.fillStyle, defaultColor);
            ctx.lineCap = helpers_dataset.valueOrDefault(legendItem.lineCap, 'butt');
            ctx.lineDashOffset = helpers_dataset.valueOrDefault(legendItem.lineDashOffset, 0);
            ctx.lineJoin = helpers_dataset.valueOrDefault(legendItem.lineJoin, 'miter');
            ctx.lineWidth = lineWidth;
            ctx.strokeStyle = helpers_dataset.valueOrDefault(legendItem.strokeStyle, defaultColor);
            ctx.setLineDash(helpers_dataset.valueOrDefault(legendItem.lineDash, []));
            if (labelOpts.usePointStyle) {
                const drawOptions = {
                    radius: boxHeight * Math.SQRT2 / 2,
                    pointStyle: legendItem.pointStyle,
                    rotation: legendItem.rotation,
                    borderWidth: lineWidth
                };
                const centerX = rtlHelper.xPlus(x, boxWidth / 2);
                const centerY = y + halfFontSize;
                helpers_dataset.drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
            } else {
                const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
                const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
                const borderRadius = helpers_dataset.toTRBLCorners(legendItem.borderRadius);
                ctx.beginPath();
                if (Object.values(borderRadius).some((v)=>v !== 0)) {
                    helpers_dataset.addRoundedRectPath(ctx, {
                        x: xBoxLeft,
                        y: yBoxTop,
                        w: boxWidth,
                        h: boxHeight,
                        radius: borderRadius
                    });
                } else {
                    ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
                }
                ctx.fill();
                if (lineWidth !== 0) {
                    ctx.stroke();
                }
            }
            ctx.restore();
        };
        const fillText = function(x, y, legendItem) {
            helpers_dataset.renderText(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {
                strikethrough: legendItem.hidden,
                textAlign: rtlHelper.textAlign(legendItem.textAlign)
            });
        };
        const isHorizontal = this.isHorizontal();
        const titleHeight = this._computeTitleHeight();
        if (isHorizontal) {
            cursor = {
                x: helpers_dataset._alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
                y: this.top + padding + titleHeight,
                line: 0
            };
        } else {
            cursor = {
                x: this.left + padding,
                y: helpers_dataset._alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
                line: 0
            };
        }
        helpers_dataset.overrideTextDirection(this.ctx, opts.textDirection);
        const lineHeight = itemHeight + padding;
        this.legendItems.forEach((legendItem, i)=>{
            ctx.strokeStyle = legendItem.fontColor;
            ctx.fillStyle = legendItem.fontColor;
            const textWidth = ctx.measureText(legendItem.text).width;
            const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
            const width = boxWidth + halfFontSize + textWidth;
            let x = cursor.x;
            let y = cursor.y;
            rtlHelper.setWidth(this.width);
            if (isHorizontal) {
                if (i > 0 && x + width + padding > this.right) {
                    y = cursor.y += lineHeight;
                    cursor.line++;
                    x = cursor.x = helpers_dataset._alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
                }
            } else if (i > 0 && y + lineHeight > this.bottom) {
                x = cursor.x = x + columnSizes[cursor.line].width + padding;
                cursor.line++;
                y = cursor.y = helpers_dataset._alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
            }
            const realX = rtlHelper.x(x);
            drawLegendBox(realX, y, legendItem);
            x = helpers_dataset._textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);
            fillText(rtlHelper.x(x), y, legendItem);
            if (isHorizontal) {
                cursor.x += width + padding;
            } else if (typeof legendItem.text !== 'string') {
                const fontLineHeight = labelFont.lineHeight;
                cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight) + padding;
            } else {
                cursor.y += lineHeight;
            }
        });
        helpers_dataset.restoreTextDirection(this.ctx, opts.textDirection);
    }
 drawTitle() {
        const opts = this.options;
        const titleOpts = opts.title;
        const titleFont = helpers_dataset.toFont(titleOpts.font);
        const titlePadding = helpers_dataset.toPadding(titleOpts.padding);
        if (!titleOpts.display) {
            return;
        }
        const rtlHelper = helpers_dataset.getRtlAdapter(opts.rtl, this.left, this.width);
        const ctx = this.ctx;
        const position = titleOpts.position;
        const halfFontSize = titleFont.size / 2;
        const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
        let y;
        let left = this.left;
        let maxWidth = this.width;
        if (this.isHorizontal()) {
            maxWidth = Math.max(...this.lineWidths);
            y = this.top + topPaddingPlusHalfFontSize;
            left = helpers_dataset._alignStartEnd(opts.align, left, this.right - maxWidth);
        } else {
            const maxHeight = this.columnSizes.reduce((acc, size)=>Math.max(acc, size.height), 0);
            y = topPaddingPlusHalfFontSize + helpers_dataset._alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
        }
        const x = helpers_dataset._alignStartEnd(position, left, left + maxWidth);
        ctx.textAlign = rtlHelper.textAlign(helpers_dataset._toLeftRightCenter(position));
        ctx.textBaseline = 'middle';
        ctx.strokeStyle = titleOpts.color;
        ctx.fillStyle = titleOpts.color;
        ctx.font = titleFont.string;
        helpers_dataset.renderText(ctx, titleOpts.text, x, y, titleFont);
    }
 _computeTitleHeight() {
        const titleOpts = this.options.title;
        const titleFont = helpers_dataset.toFont(titleOpts.font);
        const titlePadding = helpers_dataset.toPadding(titleOpts.padding);
        return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
    }
 _getLegendItemAt(x, y) {
        let i, hitBox, lh;
        if (helpers_dataset._isBetween(x, this.left, this.right) && helpers_dataset._isBetween(y, this.top, this.bottom)) {
            lh = this.legendHitBoxes;
            for(i = 0; i < lh.length; ++i){
                hitBox = lh[i];
                if (helpers_dataset._isBetween(x, hitBox.left, hitBox.left + hitBox.width) && helpers_dataset._isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {
                    return this.legendItems[i];
                }
            }
        }
        return null;
    }
 handleEvent(e) {
        const opts = this.options;
        if (!isListened(e.type, opts)) {
            return;
        }
        const hoveredItem = this._getLegendItemAt(e.x, e.y);
        if (e.type === 'mousemove' || e.type === 'mouseout') {
            const previous = this._hoveredItem;
            const sameItem = itemsEqual(previous, hoveredItem);
            if (previous && !sameItem) {
                helpers_dataset.callback(opts.onLeave, [
                    e,
                    previous,
                    this
                ], this);
            }
            this._hoveredItem = hoveredItem;
            if (hoveredItem && !sameItem) {
                helpers_dataset.callback(opts.onHover, [
                    e,
                    hoveredItem,
                    this
                ], this);
            }
        } else if (hoveredItem) {
            helpers_dataset.callback(opts.onClick, [
                e,
                hoveredItem,
                this
            ], this);
        }
    }
}
function calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {
    const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);
    const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);
    return {
        itemWidth,
        itemHeight
    };
}
function calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {
    let legendItemText = legendItem.text;
    if (legendItemText && typeof legendItemText !== 'string') {
        legendItemText = legendItemText.reduce((a, b)=>a.length > b.length ? a : b);
    }
    return boxWidth + labelFont.size / 2 + ctx.measureText(legendItemText).width;
}
function calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {
    let itemHeight = _itemHeight;
    if (typeof legendItem.text !== 'string') {
        itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);
    }
    return itemHeight;
}
function calculateLegendItemHeight(legendItem, fontLineHeight) {
    const labelHeight = legendItem.text ? legendItem.text.length : 0;
    return fontLineHeight * labelHeight;
}
function isListened(type, opts) {
    if ((type === 'mousemove' || type === 'mouseout') && (opts.onHover || opts.onLeave)) {
        return true;
    }
    if (opts.onClick && (type === 'click' || type === 'mouseup')) {
        return true;
    }
    return false;
}
var plugin_legend = {
    id: 'legend',
 _element: Legend,
    start (chart, _args, options) {
        const legend = chart.legend = new Legend({
            ctx: chart.ctx,
            options,
            chart
        });
        layouts.configure(chart, legend, options);
        layouts.addBox(chart, legend);
    },
    stop (chart) {
        layouts.removeBox(chart, chart.legend);
        delete chart.legend;
    },
    beforeUpdate (chart, _args, options) {
        const legend = chart.legend;
        layouts.configure(chart, legend, options);
        legend.options = options;
    },
    afterUpdate (chart) {
        const legend = chart.legend;
        legend.buildLabels();
        legend.adjustHitBoxes();
    },
    afterEvent (chart, args) {
        if (!args.replay) {
            chart.legend.handleEvent(args.event);
        }
    },
    defaults: {
        display: true,
        position: 'top',
        align: 'center',
        fullSize: true,
        reverse: false,
        weight: 1000,
        onClick (e, legendItem, legend) {
            const index = legendItem.datasetIndex;
            const ci = legend.chart;
            if (ci.isDatasetVisible(index)) {
                ci.hide(index);
                legendItem.hidden = true;
            } else {
                ci.show(index);
                legendItem.hidden = false;
            }
        },
        onHover: null,
        onLeave: null,
        labels: {
            color: (ctx)=>ctx.chart.options.color,
            boxWidth: 40,
            padding: 10,
            generateLabels (chart) {
                const datasets = chart.data.datasets;
                const { labels: { usePointStyle , pointStyle , textAlign , color , useBorderRadius , borderRadius  }  } = chart.legend.options;
                return chart._getSortedDatasetMetas().map((meta)=>{
                    const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);
                    const borderWidth = helpers_dataset.toPadding(style.borderWidth);
                    return {
                        text: datasets[meta.index].label,
                        fillStyle: style.backgroundColor,
                        fontColor: color,
                        hidden: !meta.visible,
                        lineCap: style.borderCapStyle,
                        lineDash: style.borderDash,
                        lineDashOffset: style.borderDashOffset,
                        lineJoin: style.borderJoinStyle,
                        lineWidth: (borderWidth.width + borderWidth.height) / 4,
                        strokeStyle: style.borderColor,
                        pointStyle: pointStyle || style.pointStyle,
                        rotation: style.rotation,
                        textAlign: textAlign || style.textAlign,
                        borderRadius: useBorderRadius && (borderRadius || style.borderRadius),
                        datasetIndex: meta.index
                    };
                }, this);
            }
        },
        title: {
            color: (ctx)=>ctx.chart.options.color,
            display: false,
            position: 'center',
            text: ''
        }
    },
    descriptors: {
        _scriptable: (name)=>!name.startsWith('on'),
        labels: {
            _scriptable: (name)=>![
                    'generateLabels',
                    'filter',
                    'sort'
                ].includes(name)
        }
    }
};

class Title extends Element {
 constructor(config){
        super();
        this.chart = config.chart;
        this.options = config.options;
        this.ctx = config.ctx;
        this._padding = undefined;
        this.top = undefined;
        this.bottom = undefined;
        this.left = undefined;
        this.right = undefined;
        this.width = undefined;
        this.height = undefined;
        this.position = undefined;
        this.weight = undefined;
        this.fullSize = undefined;
    }
    update(maxWidth, maxHeight) {
        const opts = this.options;
        this.left = 0;
        this.top = 0;
        if (!opts.display) {
            this.width = this.height = this.right = this.bottom = 0;
            return;
        }
        this.width = this.right = maxWidth;
        this.height = this.bottom = maxHeight;
        const lineCount = helpers_dataset.isArray(opts.text) ? opts.text.length : 1;
        this._padding = helpers_dataset.toPadding(opts.padding);
        const textSize = lineCount * helpers_dataset.toFont(opts.font).lineHeight + this._padding.height;
        if (this.isHorizontal()) {
            this.height = textSize;
        } else {
            this.width = textSize;
        }
    }
    isHorizontal() {
        const pos = this.options.position;
        return pos === 'top' || pos === 'bottom';
    }
    _drawArgs(offset) {
        const { top , left , bottom , right , options  } = this;
        const align = options.align;
        let rotation = 0;
        let maxWidth, titleX, titleY;
        if (this.isHorizontal()) {
            titleX = helpers_dataset._alignStartEnd(align, left, right);
            titleY = top + offset;
            maxWidth = right - left;
        } else {
            if (options.position === 'left') {
                titleX = left + offset;
                titleY = helpers_dataset._alignStartEnd(align, bottom, top);
                rotation = helpers_dataset.PI * -0.5;
            } else {
                titleX = right - offset;
                titleY = helpers_dataset._alignStartEnd(align, top, bottom);
                rotation = helpers_dataset.PI * 0.5;
            }
            maxWidth = bottom - top;
        }
        return {
            titleX,
            titleY,
            maxWidth,
            rotation
        };
    }
    draw() {
        const ctx = this.ctx;
        const opts = this.options;
        if (!opts.display) {
            return;
        }
        const fontOpts = helpers_dataset.toFont(opts.font);
        const lineHeight = fontOpts.lineHeight;
        const offset = lineHeight / 2 + this._padding.top;
        const { titleX , titleY , maxWidth , rotation  } = this._drawArgs(offset);
        helpers_dataset.renderText(ctx, opts.text, 0, 0, fontOpts, {
            color: opts.color,
            maxWidth,
            rotation,
            textAlign: helpers_dataset._toLeftRightCenter(opts.align),
            textBaseline: 'middle',
            translation: [
                titleX,
                titleY
            ]
        });
    }
}
function createTitle(chart, titleOpts) {
    const title = new Title({
        ctx: chart.ctx,
        options: titleOpts,
        chart
    });
    layouts.configure(chart, title, titleOpts);
    layouts.addBox(chart, title);
    chart.titleBlock = title;
}
var plugin_title = {
    id: 'title',
 _element: Title,
    start (chart, _args, options) {
        createTitle(chart, options);
    },
    stop (chart) {
        const titleBlock = chart.titleBlock;
        layouts.removeBox(chart, titleBlock);
        delete chart.titleBlock;
    },
    beforeUpdate (chart, _args, options) {
        const title = chart.titleBlock;
        layouts.configure(chart, title, options);
        title.options = options;
    },
    defaults: {
        align: 'center',
        display: false,
        font: {
            weight: 'bold'
        },
        fullSize: true,
        padding: 10,
        position: 'top',
        text: '',
        weight: 2000
    },
    defaultRoutes: {
        color: 'color'
    },
    descriptors: {
        _scriptable: true,
        _indexable: false
    }
};

const map = new WeakMap();
var plugin_subtitle = {
    id: 'subtitle',
    start (chart, _args, options) {
        const title = new Title({
            ctx: chart.ctx,
            options,
            chart
        });
        layouts.configure(chart, title, options);
        layouts.addBox(chart, title);
        map.set(chart, title);
    },
    stop (chart) {
        layouts.removeBox(chart, map.get(chart));
        map.delete(chart);
    },
    beforeUpdate (chart, _args, options) {
        const title = map.get(chart);
        layouts.configure(chart, title, options);
        title.options = options;
    },
    defaults: {
        align: 'center',
        display: false,
        font: {
            weight: 'normal'
        },
        fullSize: true,
        padding: 0,
        position: 'top',
        text: '',
        weight: 1500
    },
    defaultRoutes: {
        color: 'color'
    },
    descriptors: {
        _scriptable: true,
        _indexable: false
    }
};

const positioners = {
 average (items) {
        if (!items.length) {
            return false;
        }
        let i, len;
        let xSet = new Set();
        let y = 0;
        let count = 0;
        for(i = 0, len = items.length; i < len; ++i){
            const el = items[i].element;
            if (el && el.hasValue()) {
                const pos = el.tooltipPosition();
                xSet.add(pos.x);
                y += pos.y;
                ++count;
            }
        }
        if (count === 0 || xSet.size === 0) {
            return false;
        }
        const xAverage = [
            ...xSet
        ].reduce((a, b)=>a + b) / xSet.size;
        return {
            x: xAverage,
            y: y / count
        };
    },
 nearest (items, eventPosition) {
        if (!items.length) {
            return false;
        }
        let x = eventPosition.x;
        let y = eventPosition.y;
        let minDistance = Number.POSITIVE_INFINITY;
        let i, len, nearestElement;
        for(i = 0, len = items.length; i < len; ++i){
            const el = items[i].element;
            if (el && el.hasValue()) {
                const center = el.getCenterPoint();
                const d = helpers_dataset.distanceBetweenPoints(eventPosition, center);
                if (d < minDistance) {
                    minDistance = d;
                    nearestElement = el;
                }
            }
        }
        if (nearestElement) {
            const tp = nearestElement.tooltipPosition();
            x = tp.x;
            y = tp.y;
        }
        return {
            x,
            y
        };
    }
};
function pushOrConcat(base, toPush) {
    if (toPush) {
        if (helpers_dataset.isArray(toPush)) {
            Array.prototype.push.apply(base, toPush);
        } else {
            base.push(toPush);
        }
    }
    return base;
}
 function splitNewlines(str) {
    if ((typeof str === 'string' || str instanceof String) && str.indexOf('\n') > -1) {
        return str.split('\n');
    }
    return str;
}
 function createTooltipItem(chart, item) {
    const { element , datasetIndex , index  } = item;
    const controller = chart.getDatasetMeta(datasetIndex).controller;
    const { label , value  } = controller.getLabelAndValue(index);
    return {
        chart,
        label,
        parsed: controller.getParsed(index),
        raw: chart.data.datasets[datasetIndex].data[index],
        formattedValue: value,
        dataset: controller.getDataset(),
        dataIndex: index,
        datasetIndex,
        element
    };
}
 function getTooltipSize(tooltip, options) {
    const ctx = tooltip.chart.ctx;
    const { body , footer , title  } = tooltip;
    const { boxWidth , boxHeight  } = options;
    const bodyFont = helpers_dataset.toFont(options.bodyFont);
    const titleFont = helpers_dataset.toFont(options.titleFont);
    const footerFont = helpers_dataset.toFont(options.footerFont);
    const titleLineCount = title.length;
    const footerLineCount = footer.length;
    const bodyLineItemCount = body.length;
    const padding = helpers_dataset.toPadding(options.padding);
    let height = padding.height;
    let width = 0;
    let combinedBodyLength = body.reduce((count, bodyItem)=>count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
    combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
    if (titleLineCount) {
        height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
    }
    if (combinedBodyLength) {
        const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
        height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
    }
    if (footerLineCount) {
        height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
    }
    let widthPadding = 0;
    const maxLineWidth = function(line) {
        width = Math.max(width, ctx.measureText(line).width + widthPadding);
    };
    ctx.save();
    ctx.font = titleFont.string;
    helpers_dataset.each(tooltip.title, maxLineWidth);
    ctx.font = bodyFont.string;
    helpers_dataset.each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
    widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
    helpers_dataset.each(body, (bodyItem)=>{
        helpers_dataset.each(bodyItem.before, maxLineWidth);
        helpers_dataset.each(bodyItem.lines, maxLineWidth);
        helpers_dataset.each(bodyItem.after, maxLineWidth);
    });
    widthPadding = 0;
    ctx.font = footerFont.string;
    helpers_dataset.each(tooltip.footer, maxLineWidth);
    ctx.restore();
    width += padding.width;
    return {
        width,
        height
    };
}
function determineYAlign(chart, size) {
    const { y , height  } = size;
    if (y < height / 2) {
        return 'top';
    } else if (y > chart.height - height / 2) {
        return 'bottom';
    }
    return 'center';
}
function doesNotFitWithAlign(xAlign, chart, options, size) {
    const { x , width  } = size;
    const caret = options.caretSize + options.caretPadding;
    if (xAlign === 'left' && x + width + caret > chart.width) {
        return true;
    }
    if (xAlign === 'right' && x - width - caret < 0) {
        return true;
    }
}
function determineXAlign(chart, options, size, yAlign) {
    const { x , width  } = size;
    const { width: chartWidth , chartArea: { left , right  }  } = chart;
    let xAlign = 'center';
    if (yAlign === 'center') {
        xAlign = x <= (left + right) / 2 ? 'left' : 'right';
    } else if (x <= width / 2) {
        xAlign = 'left';
    } else if (x >= chartWidth - width / 2) {
        xAlign = 'right';
    }
    if (doesNotFitWithAlign(xAlign, chart, options, size)) {
        xAlign = 'center';
    }
    return xAlign;
}
 function determineAlignment(chart, options, size) {
    const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
    return {
        xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
        yAlign
    };
}
function alignX(size, xAlign) {
    let { x , width  } = size;
    if (xAlign === 'right') {
        x -= width;
    } else if (xAlign === 'center') {
        x -= width / 2;
    }
    return x;
}
function alignY(size, yAlign, paddingAndSize) {
    let { y , height  } = size;
    if (yAlign === 'top') {
        y += paddingAndSize;
    } else if (yAlign === 'bottom') {
        y -= height + paddingAndSize;
    } else {
        y -= height / 2;
    }
    return y;
}
 function getBackgroundPoint(options, size, alignment, chart) {
    const { caretSize , caretPadding , cornerRadius  } = options;
    const { xAlign , yAlign  } = alignment;
    const paddingAndSize = caretSize + caretPadding;
    const { topLeft , topRight , bottomLeft , bottomRight  } = helpers_dataset.toTRBLCorners(cornerRadius);
    let x = alignX(size, xAlign);
    const y = alignY(size, yAlign, paddingAndSize);
    if (yAlign === 'center') {
        if (xAlign === 'left') {
            x += paddingAndSize;
        } else if (xAlign === 'right') {
            x -= paddingAndSize;
        }
    } else if (xAlign === 'left') {
        x -= Math.max(topLeft, bottomLeft) + caretSize;
    } else if (xAlign === 'right') {
        x += Math.max(topRight, bottomRight) + caretSize;
    }
    return {
        x: helpers_dataset._limitValue(x, 0, chart.width - size.width),
        y: helpers_dataset._limitValue(y, 0, chart.height - size.height)
    };
}
function getAlignedX(tooltip, align, options) {
    const padding = helpers_dataset.toPadding(options.padding);
    return align === 'center' ? tooltip.x + tooltip.width / 2 : align === 'right' ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
}
 function getBeforeAfterBodyLines(callback) {
    return pushOrConcat([], splitNewlines(callback));
}
function createTooltipContext(parent, tooltip, tooltipItems) {
    return helpers_dataset.createContext(parent, {
        tooltip,
        tooltipItems,
        type: 'tooltip'
    });
}
function overrideCallbacks(callbacks, context) {
    const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
    return override ? callbacks.override(override) : callbacks;
}
const defaultCallbacks = {
    beforeTitle: helpers_dataset.noop,
    title (tooltipItems) {
        if (tooltipItems.length > 0) {
            const item = tooltipItems[0];
            const labels = item.chart.data.labels;
            const labelCount = labels ? labels.length : 0;
            if (this && this.options && this.options.mode === 'dataset') {
                return item.dataset.label || '';
            } else if (item.label) {
                return item.label;
            } else if (labelCount > 0 && item.dataIndex < labelCount) {
                return labels[item.dataIndex];
            }
        }
        return '';
    },
    afterTitle: helpers_dataset.noop,
    beforeBody: helpers_dataset.noop,
    beforeLabel: helpers_dataset.noop,
    label (tooltipItem) {
        if (this && this.options && this.options.mode === 'dataset') {
            return tooltipItem.label + ': ' + tooltipItem.formattedValue || tooltipItem.formattedValue;
        }
        let label = tooltipItem.dataset.label || '';
        if (label) {
            label += ': ';
        }
        const value = tooltipItem.formattedValue;
        if (!helpers_dataset.isNullOrUndef(value)) {
            label += value;
        }
        return label;
    },
    labelColor (tooltipItem) {
        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
        const options = meta.controller.getStyle(tooltipItem.dataIndex);
        return {
            borderColor: options.borderColor,
            backgroundColor: options.backgroundColor,
            borderWidth: options.borderWidth,
            borderDash: options.borderDash,
            borderDashOffset: options.borderDashOffset,
            borderRadius: 0
        };
    },
    labelTextColor () {
        return this.options.bodyColor;
    },
    labelPointStyle (tooltipItem) {
        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
        const options = meta.controller.getStyle(tooltipItem.dataIndex);
        return {
            pointStyle: options.pointStyle,
            rotation: options.rotation
        };
    },
    afterLabel: helpers_dataset.noop,
    afterBody: helpers_dataset.noop,
    beforeFooter: helpers_dataset.noop,
    footer: helpers_dataset.noop,
    afterFooter: helpers_dataset.noop
};
 function invokeCallbackWithFallback(callbacks, name, ctx, arg) {
    const result = callbacks[name].call(ctx, arg);
    if (typeof result === 'undefined') {
        return defaultCallbacks[name].call(ctx, arg);
    }
    return result;
}
class Tooltip extends Element {
 static positioners = positioners;
    constructor(config){
        super();
        this.opacity = 0;
        this._active = [];
        this._eventPosition = undefined;
        this._size = undefined;
        this._cachedAnimations = undefined;
        this._tooltipItems = [];
        this.$animations = undefined;
        this.$context = undefined;
        this.chart = config.chart;
        this.options = config.options;
        this.dataPoints = undefined;
        this.title = undefined;
        this.beforeBody = undefined;
        this.body = undefined;
        this.afterBody = undefined;
        this.footer = undefined;
        this.xAlign = undefined;
        this.yAlign = undefined;
        this.x = undefined;
        this.y = undefined;
        this.height = undefined;
        this.width = undefined;
        this.caretX = undefined;
        this.caretY = undefined;
        this.labelColors = undefined;
        this.labelPointStyles = undefined;
        this.labelTextColors = undefined;
    }
    initialize(options) {
        this.options = options;
        this._cachedAnimations = undefined;
        this.$context = undefined;
    }
 _resolveAnimations() {
        const cached = this._cachedAnimations;
        if (cached) {
            return cached;
        }
        const chart = this.chart;
        const options = this.options.setContext(this.getContext());
        const opts = options.enabled && chart.options.animation && options.animations;
        const animations = new Animations(this.chart, opts);
        if (opts._cacheable) {
            this._cachedAnimations = Object.freeze(animations);
        }
        return animations;
    }
 getContext() {
        return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
    }
    getTitle(context, options) {
        const { callbacks  } = options;
        const beforeTitle = invokeCallbackWithFallback(callbacks, 'beforeTitle', this, context);
        const title = invokeCallbackWithFallback(callbacks, 'title', this, context);
        const afterTitle = invokeCallbackWithFallback(callbacks, 'afterTitle', this, context);
        let lines = [];
        lines = pushOrConcat(lines, splitNewlines(beforeTitle));
        lines = pushOrConcat(lines, splitNewlines(title));
        lines = pushOrConcat(lines, splitNewlines(afterTitle));
        return lines;
    }
    getBeforeBody(tooltipItems, options) {
        return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, 'beforeBody', this, tooltipItems));
    }
    getBody(tooltipItems, options) {
        const { callbacks  } = options;
        const bodyItems = [];
        helpers_dataset.each(tooltipItems, (context)=>{
            const bodyItem = {
                before: [],
                lines: [],
                after: []
            };
            const scoped = overrideCallbacks(callbacks, context);
            pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, 'beforeLabel', this, context)));
            pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, 'label', this, context));
            pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, 'afterLabel', this, context)));
            bodyItems.push(bodyItem);
        });
        return bodyItems;
    }
    getAfterBody(tooltipItems, options) {
        return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, 'afterBody', this, tooltipItems));
    }
    getFooter(tooltipItems, options) {
        const { callbacks  } = options;
        const beforeFooter = invokeCallbackWithFallback(callbacks, 'beforeFooter', this, tooltipItems);
        const footer = invokeCallbackWithFallback(callbacks, 'footer', this, tooltipItems);
        const afterFooter = invokeCallbackWithFallback(callbacks, 'afterFooter', this, tooltipItems);
        let lines = [];
        lines = pushOrConcat(lines, splitNewlines(beforeFooter));
        lines = pushOrConcat(lines, splitNewlines(footer));
        lines = pushOrConcat(lines, splitNewlines(afterFooter));
        return lines;
    }
 _createItems(options) {
        const active = this._active;
        const data = this.chart.data;
        const labelColors = [];
        const labelPointStyles = [];
        const labelTextColors = [];
        let tooltipItems = [];
        let i, len;
        for(i = 0, len = active.length; i < len; ++i){
            tooltipItems.push(createTooltipItem(this.chart, active[i]));
        }
        if (options.filter) {
            tooltipItems = tooltipItems.filter((element, index, array)=>options.filter(element, index, array, data));
        }
        if (options.itemSort) {
            tooltipItems = tooltipItems.sort((a, b)=>options.itemSort(a, b, data));
        }
        helpers_dataset.each(tooltipItems, (context)=>{
            const scoped = overrideCallbacks(options.callbacks, context);
            labelColors.push(invokeCallbackWithFallback(scoped, 'labelColor', this, context));
            labelPointStyles.push(invokeCallbackWithFallback(scoped, 'labelPointStyle', this, context));
            labelTextColors.push(invokeCallbackWithFallback(scoped, 'labelTextColor', this, context));
        });
        this.labelColors = labelColors;
        this.labelPointStyles = labelPointStyles;
        this.labelTextColors = labelTextColors;
        this.dataPoints = tooltipItems;
        return tooltipItems;
    }
    update(changed, replay) {
        const options = this.options.setContext(this.getContext());
        const active = this._active;
        let properties;
        let tooltipItems = [];
        if (!active.length) {
            if (this.opacity !== 0) {
                properties = {
                    opacity: 0
                };
            }
        } else {
            const position = positioners[options.position].call(this, active, this._eventPosition);
            tooltipItems = this._createItems(options);
            this.title = this.getTitle(tooltipItems, options);
            this.beforeBody = this.getBeforeBody(tooltipItems, options);
            this.body = this.getBody(tooltipItems, options);
            this.afterBody = this.getAfterBody(tooltipItems, options);
            this.footer = this.getFooter(tooltipItems, options);
            const size = this._size = getTooltipSize(this, options);
            const positionAndSize = Object.assign({}, position, size);
            const alignment = determineAlignment(this.chart, options, positionAndSize);
            const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
            this.xAlign = alignment.xAlign;
            this.yAlign = alignment.yAlign;
            properties = {
                opacity: 1,
                x: backgroundPoint.x,
                y: backgroundPoint.y,
                width: size.width,
                height: size.height,
                caretX: position.x,
                caretY: position.y
            };
        }
        this._tooltipItems = tooltipItems;
        this.$context = undefined;
        if (properties) {
            this._resolveAnimations().update(this, properties);
        }
        if (changed && options.external) {
            options.external.call(this, {
                chart: this.chart,
                tooltip: this,
                replay
            });
        }
    }
    drawCaret(tooltipPoint, ctx, size, options) {
        const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
        ctx.lineTo(caretPosition.x1, caretPosition.y1);
        ctx.lineTo(caretPosition.x2, caretPosition.y2);
        ctx.lineTo(caretPosition.x3, caretPosition.y3);
    }
    getCaretPosition(tooltipPoint, size, options) {
        const { xAlign , yAlign  } = this;
        const { caretSize , cornerRadius  } = options;
        const { topLeft , topRight , bottomLeft , bottomRight  } = helpers_dataset.toTRBLCorners(cornerRadius);
        const { x: ptX , y: ptY  } = tooltipPoint;
        const { width , height  } = size;
        let x1, x2, x3, y1, y2, y3;
        if (yAlign === 'center') {
            y2 = ptY + height / 2;
            if (xAlign === 'left') {
                x1 = ptX;
                x2 = x1 - caretSize;
                y1 = y2 + caretSize;
                y3 = y2 - caretSize;
            } else {
                x1 = ptX + width;
                x2 = x1 + caretSize;
                y1 = y2 - caretSize;
                y3 = y2 + caretSize;
            }
            x3 = x1;
        } else {
            if (xAlign === 'left') {
                x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
            } else if (xAlign === 'right') {
                x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
            } else {
                x2 = this.caretX;
            }
            if (yAlign === 'top') {
                y1 = ptY;
                y2 = y1 - caretSize;
                x1 = x2 - caretSize;
                x3 = x2 + caretSize;
            } else {
                y1 = ptY + height;
                y2 = y1 + caretSize;
                x1 = x2 + caretSize;
                x3 = x2 - caretSize;
            }
            y3 = y1;
        }
        return {
            x1,
            x2,
            x3,
            y1,
            y2,
            y3
        };
    }
    drawTitle(pt, ctx, options) {
        const title = this.title;
        const length = title.length;
        let titleFont, titleSpacing, i;
        if (length) {
            const rtlHelper = helpers_dataset.getRtlAdapter(options.rtl, this.x, this.width);
            pt.x = getAlignedX(this, options.titleAlign, options);
            ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
            ctx.textBaseline = 'middle';
            titleFont = helpers_dataset.toFont(options.titleFont);
            titleSpacing = options.titleSpacing;
            ctx.fillStyle = options.titleColor;
            ctx.font = titleFont.string;
            for(i = 0; i < length; ++i){
                ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
                pt.y += titleFont.lineHeight + titleSpacing;
                if (i + 1 === length) {
                    pt.y += options.titleMarginBottom - titleSpacing;
                }
            }
        }
    }
 _drawColorBox(ctx, pt, i, rtlHelper, options) {
        const labelColor = this.labelColors[i];
        const labelPointStyle = this.labelPointStyles[i];
        const { boxHeight , boxWidth  } = options;
        const bodyFont = helpers_dataset.toFont(options.bodyFont);
        const colorX = getAlignedX(this, 'left', options);
        const rtlColorX = rtlHelper.x(colorX);
        const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
        const colorY = pt.y + yOffSet;
        if (options.usePointStyle) {
            const drawOptions = {
                radius: Math.min(boxWidth, boxHeight) / 2,
                pointStyle: labelPointStyle.pointStyle,
                rotation: labelPointStyle.rotation,
                borderWidth: 1
            };
            const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
            const centerY = colorY + boxHeight / 2;
            ctx.strokeStyle = options.multiKeyBackground;
            ctx.fillStyle = options.multiKeyBackground;
            helpers_dataset.drawPoint(ctx, drawOptions, centerX, centerY);
            ctx.strokeStyle = labelColor.borderColor;
            ctx.fillStyle = labelColor.backgroundColor;
            helpers_dataset.drawPoint(ctx, drawOptions, centerX, centerY);
        } else {
            ctx.lineWidth = helpers_dataset.isObject(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : labelColor.borderWidth || 1;
            ctx.strokeStyle = labelColor.borderColor;
            ctx.setLineDash(labelColor.borderDash || []);
            ctx.lineDashOffset = labelColor.borderDashOffset || 0;
            const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);
            const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);
            const borderRadius = helpers_dataset.toTRBLCorners(labelColor.borderRadius);
            if (Object.values(borderRadius).some((v)=>v !== 0)) {
                ctx.beginPath();
                ctx.fillStyle = options.multiKeyBackground;
                helpers_dataset.addRoundedRectPath(ctx, {
                    x: outerX,
                    y: colorY,
                    w: boxWidth,
                    h: boxHeight,
                    radius: borderRadius
                });
                ctx.fill();
                ctx.stroke();
                ctx.fillStyle = labelColor.backgroundColor;
                ctx.beginPath();
                helpers_dataset.addRoundedRectPath(ctx, {
                    x: innerX,
                    y: colorY + 1,
                    w: boxWidth - 2,
                    h: boxHeight - 2,
                    radius: borderRadius
                });
                ctx.fill();
            } else {
                ctx.fillStyle = options.multiKeyBackground;
                ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
                ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
                ctx.fillStyle = labelColor.backgroundColor;
                ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
            }
        }
        ctx.fillStyle = this.labelTextColors[i];
    }
    drawBody(pt, ctx, options) {
        const { body  } = this;
        const { bodySpacing , bodyAlign , displayColors , boxHeight , boxWidth , boxPadding  } = options;
        const bodyFont = helpers_dataset.toFont(options.bodyFont);
        let bodyLineHeight = bodyFont.lineHeight;
        let xLinePadding = 0;
        const rtlHelper = helpers_dataset.getRtlAdapter(options.rtl, this.x, this.width);
        const fillLineOfText = function(line) {
            ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
            pt.y += bodyLineHeight + bodySpacing;
        };
        const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
        let bodyItem, textColor, lines, i, j, ilen, jlen;
        ctx.textAlign = bodyAlign;
        ctx.textBaseline = 'middle';
        ctx.font = bodyFont.string;
        pt.x = getAlignedX(this, bodyAlignForCalculation, options);
        ctx.fillStyle = options.bodyColor;
        helpers_dataset.each(this.beforeBody, fillLineOfText);
        xLinePadding = displayColors && bodyAlignForCalculation !== 'right' ? bodyAlign === 'center' ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
        for(i = 0, ilen = body.length; i < ilen; ++i){
            bodyItem = body[i];
            textColor = this.labelTextColors[i];
            ctx.fillStyle = textColor;
            helpers_dataset.each(bodyItem.before, fillLineOfText);
            lines = bodyItem.lines;
            if (displayColors && lines.length) {
                this._drawColorBox(ctx, pt, i, rtlHelper, options);
                bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
            }
            for(j = 0, jlen = lines.length; j < jlen; ++j){
                fillLineOfText(lines[j]);
                bodyLineHeight = bodyFont.lineHeight;
            }
            helpers_dataset.each(bodyItem.after, fillLineOfText);
        }
        xLinePadding = 0;
        bodyLineHeight = bodyFont.lineHeight;
        helpers_dataset.each(this.afterBody, fillLineOfText);
        pt.y -= bodySpacing;
    }
    drawFooter(pt, ctx, options) {
        const footer = this.footer;
        const length = footer.length;
        let footerFont, i;
        if (length) {
            const rtlHelper = helpers_dataset.getRtlAdapter(options.rtl, this.x, this.width);
            pt.x = getAlignedX(this, options.footerAlign, options);
            pt.y += options.footerMarginTop;
            ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
            ctx.textBaseline = 'middle';
            footerFont = helpers_dataset.toFont(options.footerFont);
            ctx.fillStyle = options.footerColor;
            ctx.font = footerFont.string;
            for(i = 0; i < length; ++i){
                ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
                pt.y += footerFont.lineHeight + options.footerSpacing;
            }
        }
    }
    drawBackground(pt, ctx, tooltipSize, options) {
        const { xAlign , yAlign  } = this;
        const { x , y  } = pt;
        const { width , height  } = tooltipSize;
        const { topLeft , topRight , bottomLeft , bottomRight  } = helpers_dataset.toTRBLCorners(options.cornerRadius);
        ctx.fillStyle = options.backgroundColor;
        ctx.strokeStyle = options.borderColor;
        ctx.lineWidth = options.borderWidth;
        ctx.beginPath();
        ctx.moveTo(x + topLeft, y);
        if (yAlign === 'top') {
            this.drawCaret(pt, ctx, tooltipSize, options);
        }
        ctx.lineTo(x + width - topRight, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);
        if (yAlign === 'center' && xAlign === 'right') {
            this.drawCaret(pt, ctx, tooltipSize, options);
        }
        ctx.lineTo(x + width, y + height - bottomRight);
        ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);
        if (yAlign === 'bottom') {
            this.drawCaret(pt, ctx, tooltipSize, options);
        }
        ctx.lineTo(x + bottomLeft, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);
        if (yAlign === 'center' && xAlign === 'left') {
            this.drawCaret(pt, ctx, tooltipSize, options);
        }
        ctx.lineTo(x, y + topLeft);
        ctx.quadraticCurveTo(x, y, x + topLeft, y);
        ctx.closePath();
        ctx.fill();
        if (options.borderWidth > 0) {
            ctx.stroke();
        }
    }
 _updateAnimationTarget(options) {
        const chart = this.chart;
        const anims = this.$animations;
        const animX = anims && anims.x;
        const animY = anims && anims.y;
        if (animX || animY) {
            const position = positioners[options.position].call(this, this._active, this._eventPosition);
            if (!position) {
                return;
            }
            const size = this._size = getTooltipSize(this, options);
            const positionAndSize = Object.assign({}, position, this._size);
            const alignment = determineAlignment(chart, options, positionAndSize);
            const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
            if (animX._to !== point.x || animY._to !== point.y) {
                this.xAlign = alignment.xAlign;
                this.yAlign = alignment.yAlign;
                this.width = size.width;
                this.height = size.height;
                this.caretX = position.x;
                this.caretY = position.y;
                this._resolveAnimations().update(this, point);
            }
        }
    }
 _willRender() {
        return !!this.opacity;
    }
    draw(ctx) {
        const options = this.options.setContext(this.getContext());
        let opacity = this.opacity;
        if (!opacity) {
            return;
        }
        this._updateAnimationTarget(options);
        const tooltipSize = {
            width: this.width,
            height: this.height
        };
        const pt = {
            x: this.x,
            y: this.y
        };
        opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
        const padding = helpers_dataset.toPadding(options.padding);
        const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
        if (options.enabled && hasTooltipContent) {
            ctx.save();
            ctx.globalAlpha = opacity;
            this.drawBackground(pt, ctx, tooltipSize, options);
            helpers_dataset.overrideTextDirection(ctx, options.textDirection);
            pt.y += padding.top;
            this.drawTitle(pt, ctx, options);
            this.drawBody(pt, ctx, options);
            this.drawFooter(pt, ctx, options);
            helpers_dataset.restoreTextDirection(ctx, options.textDirection);
            ctx.restore();
        }
    }
 getActiveElements() {
        return this._active || [];
    }
 setActiveElements(activeElements, eventPosition) {
        const lastActive = this._active;
        const active = activeElements.map(({ datasetIndex , index  })=>{
            const meta = this.chart.getDatasetMeta(datasetIndex);
            if (!meta) {
                throw new Error('Cannot find a dataset at index ' + datasetIndex);
            }
            return {
                datasetIndex,
                element: meta.data[index],
                index
            };
        });
        const changed = !helpers_dataset._elementsEqual(lastActive, active);
        const positionChanged = this._positionChanged(active, eventPosition);
        if (changed || positionChanged) {
            this._active = active;
            this._eventPosition = eventPosition;
            this._ignoreReplayEvents = true;
            this.update(true);
        }
    }
 handleEvent(e, replay, inChartArea = true) {
        if (replay && this._ignoreReplayEvents) {
            return false;
        }
        this._ignoreReplayEvents = false;
        const options = this.options;
        const lastActive = this._active || [];
        const active = this._getActiveElements(e, lastActive, replay, inChartArea);
        const positionChanged = this._positionChanged(active, e);
        const changed = replay || !helpers_dataset._elementsEqual(active, lastActive) || positionChanged;
        if (changed) {
            this._active = active;
            if (options.enabled || options.external) {
                this._eventPosition = {
                    x: e.x,
                    y: e.y
                };
                this.update(true, replay);
            }
        }
        return changed;
    }
 _getActiveElements(e, lastActive, replay, inChartArea) {
        const options = this.options;
        if (e.type === 'mouseout') {
            return [];
        }
        if (!inChartArea) {
            return lastActive.filter((i)=>this.chart.data.datasets[i.datasetIndex] && this.chart.getDatasetMeta(i.datasetIndex).controller.getParsed(i.index) !== undefined);
        }
        const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);
        if (options.reverse) {
            active.reverse();
        }
        return active;
    }
 _positionChanged(active, e) {
        const { caretX , caretY , options  } = this;
        const position = positioners[options.position].call(this, active, e);
        return position !== false && (caretX !== position.x || caretY !== position.y);
    }
}
var plugin_tooltip = {
    id: 'tooltip',
    _element: Tooltip,
    positioners,
    afterInit (chart, _args, options) {
        if (options) {
            chart.tooltip = new Tooltip({
                chart,
                options
            });
        }
    },
    beforeUpdate (chart, _args, options) {
        if (chart.tooltip) {
            chart.tooltip.initialize(options);
        }
    },
    reset (chart, _args, options) {
        if (chart.tooltip) {
            chart.tooltip.initialize(options);
        }
    },
    afterDraw (chart) {
        const tooltip = chart.tooltip;
        if (tooltip && tooltip._willRender()) {
            const args = {
                tooltip
            };
            if (chart.notifyPlugins('beforeTooltipDraw', {
                ...args,
                cancelable: true
            }) === false) {
                return;
            }
            tooltip.draw(chart.ctx);
            chart.notifyPlugins('afterTooltipDraw', args);
        }
    },
    afterEvent (chart, args) {
        if (chart.tooltip) {
            const useFinalPosition = args.replay;
            if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
                args.changed = true;
            }
        }
    },
    defaults: {
        enabled: true,
        external: null,
        position: 'average',
        backgroundColor: 'rgba(0,0,0,0.8)',
        titleColor: '#fff',
        titleFont: {
            weight: 'bold'
        },
        titleSpacing: 2,
        titleMarginBottom: 6,
        titleAlign: 'left',
        bodyColor: '#fff',
        bodySpacing: 2,
        bodyFont: {},
        bodyAlign: 'left',
        footerColor: '#fff',
        footerSpacing: 2,
        footerMarginTop: 6,
        footerFont: {
            weight: 'bold'
        },
        footerAlign: 'left',
        padding: 6,
        caretPadding: 2,
        caretSize: 5,
        cornerRadius: 6,
        boxHeight: (ctx, opts)=>opts.bodyFont.size,
        boxWidth: (ctx, opts)=>opts.bodyFont.size,
        multiKeyBackground: '#fff',
        displayColors: true,
        boxPadding: 0,
        borderColor: 'rgba(0,0,0,0)',
        borderWidth: 0,
        animation: {
            duration: 400,
            easing: 'easeOutQuart'
        },
        animations: {
            numbers: {
                type: 'number',
                properties: [
                    'x',
                    'y',
                    'width',
                    'height',
                    'caretX',
                    'caretY'
                ]
            },
            opacity: {
                easing: 'linear',
                duration: 200
            }
        },
        callbacks: defaultCallbacks
    },
    defaultRoutes: {
        bodyFont: 'font',
        footerFont: 'font',
        titleFont: 'font'
    },
    descriptors: {
        _scriptable: (name)=>name !== 'filter' && name !== 'itemSort' && name !== 'external',
        _indexable: false,
        callbacks: {
            _scriptable: false,
            _indexable: false
        },
        animation: {
            _fallback: false
        },
        animations: {
            _fallback: 'animation'
        }
    },
    additionalOptionScopes: [
        'interaction'
    ]
};

var plugins = /*#__PURE__*/Object.freeze({
__proto__: null,
Colors: plugin_colors,
Decimation: plugin_decimation,
Filler: index,
Legend: plugin_legend,
SubTitle: plugin_subtitle,
Title: plugin_title,
Tooltip: plugin_tooltip
});

const addIfString = (labels, raw, index, addedLabels)=>{
    if (typeof raw === 'string') {
        index = labels.push(raw) - 1;
        addedLabels.unshift({
            index,
            label: raw
        });
    } else if (isNaN(raw)) {
        index = null;
    }
    return index;
};
function findOrAddLabel(labels, raw, index, addedLabels) {
    const first = labels.indexOf(raw);
    if (first === -1) {
        return addIfString(labels, raw, index, addedLabels);
    }
    const last = labels.lastIndexOf(raw);
    return first !== last ? index : first;
}
const validIndex = (index, max)=>index === null ? null : helpers_dataset._limitValue(Math.round(index), 0, max);
function _getLabelForValue(value) {
    const labels = this.getLabels();
    if (value >= 0 && value < labels.length) {
        return labels[value];
    }
    return value;
}
class CategoryScale extends Scale {
    static id = 'category';
 static defaults = {
        ticks: {
            callback: _getLabelForValue
        }
    };
    constructor(cfg){
        super(cfg);
         this._startValue = undefined;
        this._valueRange = 0;
        this._addedLabels = [];
    }
    init(scaleOptions) {
        const added = this._addedLabels;
        if (added.length) {
            const labels = this.getLabels();
            for (const { index , label  } of added){
                if (labels[index] === label) {
                    labels.splice(index, 1);
                }
            }
            this._addedLabels = [];
        }
        super.init(scaleOptions);
    }
    parse(raw, index) {
        if (helpers_dataset.isNullOrUndef(raw)) {
            return null;
        }
        const labels = this.getLabels();
        index = isFinite(index) && labels[index] === raw ? index : findOrAddLabel(labels, raw, helpers_dataset.valueOrDefault(index, raw), this._addedLabels);
        return validIndex(index, labels.length - 1);
    }
    determineDataLimits() {
        const { minDefined , maxDefined  } = this.getUserBounds();
        let { min , max  } = this.getMinMax(true);
        if (this.options.bounds === 'ticks') {
            if (!minDefined) {
                min = 0;
            }
            if (!maxDefined) {
                max = this.getLabels().length - 1;
            }
        }
        this.min = min;
        this.max = max;
    }
    buildTicks() {
        const min = this.min;
        const max = this.max;
        const offset = this.options.offset;
        const ticks = [];
        let labels = this.getLabels();
        labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);
        this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
        this._startValue = this.min - (offset ? 0.5 : 0);
        for(let value = min; value <= max; value++){
            ticks.push({
                value
            });
        }
        return ticks;
    }
    getLabelForValue(value) {
        return _getLabelForValue.call(this, value);
    }
 configure() {
        super.configure();
        if (!this.isHorizontal()) {
            this._reversePixels = !this._reversePixels;
        }
    }
    getPixelForValue(value) {
        if (typeof value !== 'number') {
            value = this.parse(value);
        }
        return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
    }
    getPixelForTick(index) {
        const ticks = this.ticks;
        if (index < 0 || index > ticks.length - 1) {
            return null;
        }
        return this.getPixelForValue(ticks[index].value);
    }
    getValueForPixel(pixel) {
        return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
    }
    getBasePixel() {
        return this.bottom;
    }
}

function generateTicks$1(generationOptions, dataRange) {
    const ticks = [];
    const MIN_SPACING = 1e-14;
    const { bounds , step , min , max , precision , count , maxTicks , maxDigits , includeBounds  } = generationOptions;
    const unit = step || 1;
    const maxSpaces = maxTicks - 1;
    const { min: rmin , max: rmax  } = dataRange;
    const minDefined = !helpers_dataset.isNullOrUndef(min);
    const maxDefined = !helpers_dataset.isNullOrUndef(max);
    const countDefined = !helpers_dataset.isNullOrUndef(count);
    const minSpacing = (rmax - rmin) / (maxDigits + 1);
    let spacing = helpers_dataset.niceNum((rmax - rmin) / maxSpaces / unit) * unit;
    let factor, niceMin, niceMax, numSpaces;
    if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
        return [
            {
                value: rmin
            },
            {
                value: rmax
            }
        ];
    }
    numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
    if (numSpaces > maxSpaces) {
        spacing = helpers_dataset.niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
    }
    if (!helpers_dataset.isNullOrUndef(precision)) {
        factor = Math.pow(10, precision);
        spacing = Math.ceil(spacing * factor) / factor;
    }
    if (bounds === 'ticks') {
        niceMin = Math.floor(rmin / spacing) * spacing;
        niceMax = Math.ceil(rmax / spacing) * spacing;
    } else {
        niceMin = rmin;
        niceMax = rmax;
    }
    if (minDefined && maxDefined && step && helpers_dataset.almostWhole((max - min) / step, spacing / 1000)) {
        numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
        spacing = (max - min) / numSpaces;
        niceMin = min;
        niceMax = max;
    } else if (countDefined) {
        niceMin = minDefined ? min : niceMin;
        niceMax = maxDefined ? max : niceMax;
        numSpaces = count - 1;
        spacing = (niceMax - niceMin) / numSpaces;
    } else {
        numSpaces = (niceMax - niceMin) / spacing;
        if (helpers_dataset.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {
            numSpaces = Math.round(numSpaces);
        } else {
            numSpaces = Math.ceil(numSpaces);
        }
    }
    const decimalPlaces = Math.max(helpers_dataset._decimalPlaces(spacing), helpers_dataset._decimalPlaces(niceMin));
    factor = Math.pow(10, helpers_dataset.isNullOrUndef(precision) ? decimalPlaces : precision);
    niceMin = Math.round(niceMin * factor) / factor;
    niceMax = Math.round(niceMax * factor) / factor;
    let j = 0;
    if (minDefined) {
        if (includeBounds && niceMin !== min) {
            ticks.push({
                value: min
            });
            if (niceMin < min) {
                j++;
            }
            if (helpers_dataset.almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
                j++;
            }
        } else if (niceMin < min) {
            j++;
        }
    }
    for(; j < numSpaces; ++j){
        const tickValue = Math.round((niceMin + j * spacing) * factor) / factor;
        if (maxDefined && tickValue > max) {
            break;
        }
        ticks.push({
            value: tickValue
        });
    }
    if (maxDefined && includeBounds && niceMax !== max) {
        if (ticks.length && helpers_dataset.almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {
            ticks[ticks.length - 1].value = max;
        } else {
            ticks.push({
                value: max
            });
        }
    } else if (!maxDefined || niceMax === max) {
        ticks.push({
            value: niceMax
        });
    }
    return ticks;
}
function relativeLabelSize(value, minSpacing, { horizontal , minRotation  }) {
    const rad = helpers_dataset.toRadians(minRotation);
    const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;
    const length = 0.75 * minSpacing * ('' + value).length;
    return Math.min(minSpacing / ratio, length);
}
class LinearScaleBase extends Scale {
    constructor(cfg){
        super(cfg);
         this.start = undefined;
         this.end = undefined;
         this._startValue = undefined;
         this._endValue = undefined;
        this._valueRange = 0;
    }
    parse(raw, index) {
        if (helpers_dataset.isNullOrUndef(raw)) {
            return null;
        }
        if ((typeof raw === 'number' || raw instanceof Number) && !isFinite(+raw)) {
            return null;
        }
        return +raw;
    }
    handleTickRangeOptions() {
        const { beginAtZero  } = this.options;
        const { minDefined , maxDefined  } = this.getUserBounds();
        let { min , max  } = this;
        const setMin = (v)=>min = minDefined ? min : v;
        const setMax = (v)=>max = maxDefined ? max : v;
        if (beginAtZero) {
            const minSign = helpers_dataset.sign(min);
            const maxSign = helpers_dataset.sign(max);
            if (minSign < 0 && maxSign < 0) {
                setMax(0);
            } else if (minSign > 0 && maxSign > 0) {
                setMin(0);
            }
        }
        if (min === max) {
            let offset = max === 0 ? 1 : Math.abs(max * 0.05);
            setMax(max + offset);
            if (!beginAtZero) {
                setMin(min - offset);
            }
        }
        this.min = min;
        this.max = max;
    }
    getTickLimit() {
        const tickOpts = this.options.ticks;
        let { maxTicksLimit , stepSize  } = tickOpts;
        let maxTicks;
        if (stepSize) {
            maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
            if (maxTicks > 1000) {
                console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
                maxTicks = 1000;
            }
        } else {
            maxTicks = this.computeTickLimit();
            maxTicksLimit = maxTicksLimit || 11;
        }
        if (maxTicksLimit) {
            maxTicks = Math.min(maxTicksLimit, maxTicks);
        }
        return maxTicks;
    }
 computeTickLimit() {
        return Number.POSITIVE_INFINITY;
    }
    buildTicks() {
        const opts = this.options;
        const tickOpts = opts.ticks;
        let maxTicks = this.getTickLimit();
        maxTicks = Math.max(2, maxTicks);
        const numericGeneratorOptions = {
            maxTicks,
            bounds: opts.bounds,
            min: opts.min,
            max: opts.max,
            precision: tickOpts.precision,
            step: tickOpts.stepSize,
            count: tickOpts.count,
            maxDigits: this._maxDigits(),
            horizontal: this.isHorizontal(),
            minRotation: tickOpts.minRotation || 0,
            includeBounds: tickOpts.includeBounds !== false
        };
        const dataRange = this._range || this;
        const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
        if (opts.bounds === 'ticks') {
            helpers_dataset._setMinAndMaxByKey(ticks, this, 'value');
        }
        if (opts.reverse) {
            ticks.reverse();
            this.start = this.max;
            this.end = this.min;
        } else {
            this.start = this.min;
            this.end = this.max;
        }
        return ticks;
    }
 configure() {
        const ticks = this.ticks;
        let start = this.min;
        let end = this.max;
        super.configure();
        if (this.options.offset && ticks.length) {
            const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
            start -= offset;
            end += offset;
        }
        this._startValue = start;
        this._endValue = end;
        this._valueRange = end - start;
    }
    getLabelForValue(value) {
        return helpers_dataset.formatNumber(value, this.chart.options.locale, this.options.ticks.format);
    }
}

class LinearScale extends LinearScaleBase {
    static id = 'linear';
 static defaults = {
        ticks: {
            callback: helpers_dataset.Ticks.formatters.numeric
        }
    };
    determineDataLimits() {
        const { min , max  } = this.getMinMax(true);
        this.min = helpers_dataset.isNumberFinite(min) ? min : 0;
        this.max = helpers_dataset.isNumberFinite(max) ? max : 1;
        this.handleTickRangeOptions();
    }
 computeTickLimit() {
        const horizontal = this.isHorizontal();
        const length = horizontal ? this.width : this.height;
        const minRotation = helpers_dataset.toRadians(this.options.ticks.minRotation);
        const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;
        const tickFont = this._resolveTickFontOptions(0);
        return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
    }
    getPixelForValue(value) {
        return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
    }
    getValueForPixel(pixel) {
        return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
    }
}

const log10Floor = (v)=>Math.floor(helpers_dataset.log10(v));
const changeExponent = (v, m)=>Math.pow(10, log10Floor(v) + m);
function isMajor(tickVal) {
    const remain = tickVal / Math.pow(10, log10Floor(tickVal));
    return remain === 1;
}
function steps(min, max, rangeExp) {
    const rangeStep = Math.pow(10, rangeExp);
    const start = Math.floor(min / rangeStep);
    const end = Math.ceil(max / rangeStep);
    return end - start;
}
function startExp(min, max) {
    const range = max - min;
    let rangeExp = log10Floor(range);
    while(steps(min, max, rangeExp) > 10){
        rangeExp++;
    }
    while(steps(min, max, rangeExp) < 10){
        rangeExp--;
    }
    return Math.min(rangeExp, log10Floor(min));
}
 function generateTicks(generationOptions, { min , max  }) {
    min = helpers_dataset.finiteOrDefault(generationOptions.min, min);
    const ticks = [];
    const minExp = log10Floor(min);
    let exp = startExp(min, max);
    let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
    const stepSize = Math.pow(10, exp);
    const base = minExp > exp ? Math.pow(10, minExp) : 0;
    const start = Math.round((min - base) * precision) / precision;
    const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;
    let significand = Math.floor((start - offset) / Math.pow(10, exp));
    let value = helpers_dataset.finiteOrDefault(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);
    while(value < max){
        ticks.push({
            value,
            major: isMajor(value),
            significand
        });
        if (significand >= 10) {
            significand = significand < 15 ? 15 : 20;
        } else {
            significand++;
        }
        if (significand >= 20) {
            exp++;
            significand = 2;
            precision = exp >= 0 ? 1 : precision;
        }
        value = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;
    }
    const lastTick = helpers_dataset.finiteOrDefault(generationOptions.max, value);
    ticks.push({
        value: lastTick,
        major: isMajor(lastTick),
        significand
    });
    return ticks;
}
class LogarithmicScale extends Scale {
    static id = 'logarithmic';
 static defaults = {
        ticks: {
            callback: helpers_dataset.Ticks.formatters.logarithmic,
            major: {
                enabled: true
            }
        }
    };
    constructor(cfg){
        super(cfg);
         this.start = undefined;
         this.end = undefined;
         this._startValue = undefined;
        this._valueRange = 0;
    }
    parse(raw, index) {
        const value = LinearScaleBase.prototype.parse.apply(this, [
            raw,
            index
        ]);
        if (value === 0) {
            this._zero = true;
            return undefined;
        }
        return helpers_dataset.isNumberFinite(value) && value > 0 ? value : null;
    }
    determineDataLimits() {
        const { min , max  } = this.getMinMax(true);
        this.min = helpers_dataset.isNumberFinite(min) ? Math.max(0, min) : null;
        this.max = helpers_dataset.isNumberFinite(max) ? Math.max(0, max) : null;
        if (this.options.beginAtZero) {
            this._zero = true;
        }
        if (this._zero && this.min !== this._suggestedMin && !helpers_dataset.isNumberFinite(this._userMin)) {
            this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);
        }
        this.handleTickRangeOptions();
    }
    handleTickRangeOptions() {
        const { minDefined , maxDefined  } = this.getUserBounds();
        let min = this.min;
        let max = this.max;
        const setMin = (v)=>min = minDefined ? min : v;
        const setMax = (v)=>max = maxDefined ? max : v;
        if (min === max) {
            if (min <= 0) {
                setMin(1);
                setMax(10);
            } else {
                setMin(changeExponent(min, -1));
                setMax(changeExponent(max, +1));
            }
        }
        if (min <= 0) {
            setMin(changeExponent(max, -1));
        }
        if (max <= 0) {
            setMax(changeExponent(min, +1));
        }
        this.min = min;
        this.max = max;
    }
    buildTicks() {
        const opts = this.options;
        const generationOptions = {
            min: this._userMin,
            max: this._userMax
        };
        const ticks = generateTicks(generationOptions, this);
        if (opts.bounds === 'ticks') {
            helpers_dataset._setMinAndMaxByKey(ticks, this, 'value');
        }
        if (opts.reverse) {
            ticks.reverse();
            this.start = this.max;
            this.end = this.min;
        } else {
            this.start = this.min;
            this.end = this.max;
        }
        return ticks;
    }
 getLabelForValue(value) {
        return value === undefined ? '0' : helpers_dataset.formatNumber(value, this.chart.options.locale, this.options.ticks.format);
    }
 configure() {
        const start = this.min;
        super.configure();
        this._startValue = helpers_dataset.log10(start);
        this._valueRange = helpers_dataset.log10(this.max) - helpers_dataset.log10(start);
    }
    getPixelForValue(value) {
        if (value === undefined || value === 0) {
            value = this.min;
        }
        if (value === null || isNaN(value)) {
            return NaN;
        }
        return this.getPixelForDecimal(value === this.min ? 0 : (helpers_dataset.log10(value) - this._startValue) / this._valueRange);
    }
    getValueForPixel(pixel) {
        const decimal = this.getDecimalForPixel(pixel);
        return Math.pow(10, this._startValue + decimal * this._valueRange);
    }
}

function getTickBackdropHeight(opts) {
    const tickOpts = opts.ticks;
    if (tickOpts.display && opts.display) {
        const padding = helpers_dataset.toPadding(tickOpts.backdropPadding);
        return helpers_dataset.valueOrDefault(tickOpts.font && tickOpts.font.size, helpers_dataset.defaults.font.size) + padding.height;
    }
    return 0;
}
function measureLabelSize(ctx, font, label) {
    label = helpers_dataset.isArray(label) ? label : [
        label
    ];
    return {
        w: helpers_dataset._longestText(ctx, font.string, label),
        h: label.length * font.lineHeight
    };
}
function determineLimits(angle, pos, size, min, max) {
    if (angle === min || angle === max) {
        return {
            start: pos - size / 2,
            end: pos + size / 2
        };
    } else if (angle < min || angle > max) {
        return {
            start: pos - size,
            end: pos
        };
    }
    return {
        start: pos,
        end: pos + size
    };
}
 function fitWithPointLabels(scale) {
    const orig = {
        l: scale.left + scale._padding.left,
        r: scale.right - scale._padding.right,
        t: scale.top + scale._padding.top,
        b: scale.bottom - scale._padding.bottom
    };
    const limits = Object.assign({}, orig);
    const labelSizes = [];
    const padding = [];
    const valueCount = scale._pointLabels.length;
    const pointLabelOpts = scale.options.pointLabels;
    const additionalAngle = pointLabelOpts.centerPointLabels ? helpers_dataset.PI / valueCount : 0;
    for(let i = 0; i < valueCount; i++){
        const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));
        padding[i] = opts.padding;
        const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);
        const plFont = helpers_dataset.toFont(opts.font);
        const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);
        labelSizes[i] = textSize;
        const angleRadians = helpers_dataset._normalizeAngle(scale.getIndexAngle(i) + additionalAngle);
        const angle = Math.round(helpers_dataset.toDegrees(angleRadians));
        const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
        const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
        updateLimits(limits, orig, angleRadians, hLimits, vLimits);
    }
    scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
    scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
}
function updateLimits(limits, orig, angle, hLimits, vLimits) {
    const sin = Math.abs(Math.sin(angle));
    const cos = Math.abs(Math.cos(angle));
    let x = 0;
    let y = 0;
    if (hLimits.start < orig.l) {
        x = (orig.l - hLimits.start) / sin;
        limits.l = Math.min(limits.l, orig.l - x);
    } else if (hLimits.end > orig.r) {
        x = (hLimits.end - orig.r) / sin;
        limits.r = Math.max(limits.r, orig.r + x);
    }
    if (vLimits.start < orig.t) {
        y = (orig.t - vLimits.start) / cos;
        limits.t = Math.min(limits.t, orig.t - y);
    } else if (vLimits.end > orig.b) {
        y = (vLimits.end - orig.b) / cos;
        limits.b = Math.max(limits.b, orig.b + y);
    }
}
function createPointLabelItem(scale, index, itemOpts) {
    const outerDistance = scale.drawingArea;
    const { extra , additionalAngle , padding , size  } = itemOpts;
    const pointLabelPosition = scale.getPointPosition(index, outerDistance + extra + padding, additionalAngle);
    const angle = Math.round(helpers_dataset.toDegrees(helpers_dataset._normalizeAngle(pointLabelPosition.angle + helpers_dataset.HALF_PI)));
    const y = yForAngle(pointLabelPosition.y, size.h, angle);
    const textAlign = getTextAlignForAngle(angle);
    const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
    return {
        visible: true,
        x: pointLabelPosition.x,
        y,
        textAlign,
        left,
        top: y,
        right: left + size.w,
        bottom: y + size.h
    };
}
function isNotOverlapped(item, area) {
    if (!area) {
        return true;
    }
    const { left , top , right , bottom  } = item;
    const apexesInArea = helpers_dataset._isPointInArea({
        x: left,
        y: top
    }, area) || helpers_dataset._isPointInArea({
        x: left,
        y: bottom
    }, area) || helpers_dataset._isPointInArea({
        x: right,
        y: top
    }, area) || helpers_dataset._isPointInArea({
        x: right,
        y: bottom
    }, area);
    return !apexesInArea;
}
function buildPointLabelItems(scale, labelSizes, padding) {
    const items = [];
    const valueCount = scale._pointLabels.length;
    const opts = scale.options;
    const { centerPointLabels , display  } = opts.pointLabels;
    const itemOpts = {
        extra: getTickBackdropHeight(opts) / 2,
        additionalAngle: centerPointLabels ? helpers_dataset.PI / valueCount : 0
    };
    let area;
    for(let i = 0; i < valueCount; i++){
        itemOpts.padding = padding[i];
        itemOpts.size = labelSizes[i];
        const item = createPointLabelItem(scale, i, itemOpts);
        items.push(item);
        if (display === 'auto') {
            item.visible = isNotOverlapped(item, area);
            if (item.visible) {
                area = item;
            }
        }
    }
    return items;
}
function getTextAlignForAngle(angle) {
    if (angle === 0 || angle === 180) {
        return 'center';
    } else if (angle < 180) {
        return 'left';
    }
    return 'right';
}
function leftForTextAlign(x, w, align) {
    if (align === 'right') {
        x -= w;
    } else if (align === 'center') {
        x -= w / 2;
    }
    return x;
}
function yForAngle(y, h, angle) {
    if (angle === 90 || angle === 270) {
        y -= h / 2;
    } else if (angle > 270 || angle < 90) {
        y -= h;
    }
    return y;
}
function drawPointLabelBox(ctx, opts, item) {
    const { left , top , right , bottom  } = item;
    const { backdropColor  } = opts;
    if (!helpers_dataset.isNullOrUndef(backdropColor)) {
        const borderRadius = helpers_dataset.toTRBLCorners(opts.borderRadius);
        const padding = helpers_dataset.toPadding(opts.backdropPadding);
        ctx.fillStyle = backdropColor;
        const backdropLeft = left - padding.left;
        const backdropTop = top - padding.top;
        const backdropWidth = right - left + padding.width;
        const backdropHeight = bottom - top + padding.height;
        if (Object.values(borderRadius).some((v)=>v !== 0)) {
            ctx.beginPath();
            helpers_dataset.addRoundedRectPath(ctx, {
                x: backdropLeft,
                y: backdropTop,
                w: backdropWidth,
                h: backdropHeight,
                radius: borderRadius
            });
            ctx.fill();
        } else {
            ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
        }
    }
}
function drawPointLabels(scale, labelCount) {
    const { ctx , options: { pointLabels  }  } = scale;
    for(let i = labelCount - 1; i >= 0; i--){
        const item = scale._pointLabelItems[i];
        if (!item.visible) {
            continue;
        }
        const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));
        drawPointLabelBox(ctx, optsAtIndex, item);
        const plFont = helpers_dataset.toFont(optsAtIndex.font);
        const { x , y , textAlign  } = item;
        helpers_dataset.renderText(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {
            color: optsAtIndex.color,
            textAlign: textAlign,
            textBaseline: 'middle'
        });
    }
}
function pathRadiusLine(scale, radius, circular, labelCount) {
    const { ctx  } = scale;
    if (circular) {
        ctx.arc(scale.xCenter, scale.yCenter, radius, 0, helpers_dataset.TAU);
    } else {
        let pointPosition = scale.getPointPosition(0, radius);
        ctx.moveTo(pointPosition.x, pointPosition.y);
        for(let i = 1; i < labelCount; i++){
            pointPosition = scale.getPointPosition(i, radius);
            ctx.lineTo(pointPosition.x, pointPosition.y);
        }
    }
}
function drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {
    const ctx = scale.ctx;
    const circular = gridLineOpts.circular;
    const { color , lineWidth  } = gridLineOpts;
    if (!circular && !labelCount || !color || !lineWidth || radius < 0) {
        return;
    }
    ctx.save();
    ctx.strokeStyle = color;
    ctx.lineWidth = lineWidth;
    ctx.setLineDash(borderOpts.dash || []);
    ctx.lineDashOffset = borderOpts.dashOffset;
    ctx.beginPath();
    pathRadiusLine(scale, radius, circular, labelCount);
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
}
function createPointLabelContext(parent, index, label) {
    return helpers_dataset.createContext(parent, {
        label,
        index,
        type: 'pointLabel'
    });
}
class RadialLinearScale extends LinearScaleBase {
    static id = 'radialLinear';
 static defaults = {
        display: true,
        animate: true,
        position: 'chartArea',
        angleLines: {
            display: true,
            lineWidth: 1,
            borderDash: [],
            borderDashOffset: 0.0
        },
        grid: {
            circular: false
        },
        startAngle: 0,
        ticks: {
            showLabelBackdrop: true,
            callback: helpers_dataset.Ticks.formatters.numeric
        },
        pointLabels: {
            backdropColor: undefined,
            backdropPadding: 2,
            display: true,
            font: {
                size: 10
            },
            callback (label) {
                return label;
            },
            padding: 5,
            centerPointLabels: false
        }
    };
    static defaultRoutes = {
        'angleLines.color': 'borderColor',
        'pointLabels.color': 'color',
        'ticks.color': 'color'
    };
    static descriptors = {
        angleLines: {
            _fallback: 'grid'
        }
    };
    constructor(cfg){
        super(cfg);
         this.xCenter = undefined;
         this.yCenter = undefined;
         this.drawingArea = undefined;
         this._pointLabels = [];
        this._pointLabelItems = [];
    }
    setDimensions() {
        const padding = this._padding = helpers_dataset.toPadding(getTickBackdropHeight(this.options) / 2);
        const w = this.width = this.maxWidth - padding.width;
        const h = this.height = this.maxHeight - padding.height;
        this.xCenter = Math.floor(this.left + w / 2 + padding.left);
        this.yCenter = Math.floor(this.top + h / 2 + padding.top);
        this.drawingArea = Math.floor(Math.min(w, h) / 2);
    }
    determineDataLimits() {
        const { min , max  } = this.getMinMax(false);
        this.min = helpers_dataset.isNumberFinite(min) && !isNaN(min) ? min : 0;
        this.max = helpers_dataset.isNumberFinite(max) && !isNaN(max) ? max : 0;
        this.handleTickRangeOptions();
    }
 computeTickLimit() {
        return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
    }
    generateTickLabels(ticks) {
        LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
        this._pointLabels = this.getLabels().map((value, index)=>{
            const label = helpers_dataset.callback(this.options.pointLabels.callback, [
                value,
                index
            ], this);
            return label || label === 0 ? label : '';
        }).filter((v, i)=>this.chart.getDataVisibility(i));
    }
    fit() {
        const opts = this.options;
        if (opts.display && opts.pointLabels.display) {
            fitWithPointLabels(this);
        } else {
            this.setCenterPoint(0, 0, 0, 0);
        }
    }
    setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
        this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
        this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
        this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
    }
    getIndexAngle(index) {
        const angleMultiplier = helpers_dataset.TAU / (this._pointLabels.length || 1);
        const startAngle = this.options.startAngle || 0;
        return helpers_dataset._normalizeAngle(index * angleMultiplier + helpers_dataset.toRadians(startAngle));
    }
    getDistanceFromCenterForValue(value) {
        if (helpers_dataset.isNullOrUndef(value)) {
            return NaN;
        }
        const scalingFactor = this.drawingArea / (this.max - this.min);
        if (this.options.reverse) {
            return (this.max - value) * scalingFactor;
        }
        return (value - this.min) * scalingFactor;
    }
    getValueForDistanceFromCenter(distance) {
        if (helpers_dataset.isNullOrUndef(distance)) {
            return NaN;
        }
        const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
        return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
    }
    getPointLabelContext(index) {
        const pointLabels = this._pointLabels || [];
        if (index >= 0 && index < pointLabels.length) {
            const pointLabel = pointLabels[index];
            return createPointLabelContext(this.getContext(), index, pointLabel);
        }
    }
    getPointPosition(index, distanceFromCenter, additionalAngle = 0) {
        const angle = this.getIndexAngle(index) - helpers_dataset.HALF_PI + additionalAngle;
        return {
            x: Math.cos(angle) * distanceFromCenter + this.xCenter,
            y: Math.sin(angle) * distanceFromCenter + this.yCenter,
            angle
        };
    }
    getPointPositionForValue(index, value) {
        return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
    }
    getBasePosition(index) {
        return this.getPointPositionForValue(index || 0, this.getBaseValue());
    }
    getPointLabelPosition(index) {
        const { left , top , right , bottom  } = this._pointLabelItems[index];
        return {
            left,
            top,
            right,
            bottom
        };
    }
 drawBackground() {
        const { backgroundColor , grid: { circular  }  } = this.options;
        if (backgroundColor) {
            const ctx = this.ctx;
            ctx.save();
            ctx.beginPath();
            pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
            ctx.closePath();
            ctx.fillStyle = backgroundColor;
            ctx.fill();
            ctx.restore();
        }
    }
 drawGrid() {
        const ctx = this.ctx;
        const opts = this.options;
        const { angleLines , grid , border  } = opts;
        const labelCount = this._pointLabels.length;
        let i, offset, position;
        if (opts.pointLabels.display) {
            drawPointLabels(this, labelCount);
        }
        if (grid.display) {
            this.ticks.forEach((tick, index)=>{
                if (index !== 0 || index === 0 && this.min < 0) {
                    offset = this.getDistanceFromCenterForValue(tick.value);
                    const context = this.getContext(index);
                    const optsAtIndex = grid.setContext(context);
                    const optsAtIndexBorder = border.setContext(context);
                    drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);
                }
            });
        }
        if (angleLines.display) {
            ctx.save();
            for(i = labelCount - 1; i >= 0; i--){
                const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));
                const { color , lineWidth  } = optsAtIndex;
                if (!lineWidth || !color) {
                    continue;
                }
                ctx.lineWidth = lineWidth;
                ctx.strokeStyle = color;
                ctx.setLineDash(optsAtIndex.borderDash);
                ctx.lineDashOffset = optsAtIndex.borderDashOffset;
                offset = this.getDistanceFromCenterForValue(opts.reverse ? this.min : this.max);
                position = this.getPointPosition(i, offset);
                ctx.beginPath();
                ctx.moveTo(this.xCenter, this.yCenter);
                ctx.lineTo(position.x, position.y);
                ctx.stroke();
            }
            ctx.restore();
        }
    }
 drawBorder() {}
 drawLabels() {
        const ctx = this.ctx;
        const opts = this.options;
        const tickOpts = opts.ticks;
        if (!tickOpts.display) {
            return;
        }
        const startAngle = this.getIndexAngle(0);
        let offset, width;
        ctx.save();
        ctx.translate(this.xCenter, this.yCenter);
        ctx.rotate(startAngle);
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        this.ticks.forEach((tick, index)=>{
            if (index === 0 && this.min >= 0 && !opts.reverse) {
                return;
            }
            const optsAtIndex = tickOpts.setContext(this.getContext(index));
            const tickFont = helpers_dataset.toFont(optsAtIndex.font);
            offset = this.getDistanceFromCenterForValue(this.ticks[index].value);
            if (optsAtIndex.showLabelBackdrop) {
                ctx.font = tickFont.string;
                width = ctx.measureText(tick.label).width;
                ctx.fillStyle = optsAtIndex.backdropColor;
                const padding = helpers_dataset.toPadding(optsAtIndex.backdropPadding);
                ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
            }
            helpers_dataset.renderText(ctx, tick.label, 0, -offset, tickFont, {
                color: optsAtIndex.color,
                strokeColor: optsAtIndex.textStrokeColor,
                strokeWidth: optsAtIndex.textStrokeWidth
            });
        });
        ctx.restore();
    }
 drawTitle() {}
}

const INTERVALS = {
    millisecond: {
        common: true,
        size: 1,
        steps: 1000
    },
    second: {
        common: true,
        size: 1000,
        steps: 60
    },
    minute: {
        common: true,
        size: 60000,
        steps: 60
    },
    hour: {
        common: true,
        size: 3600000,
        steps: 24
    },
    day: {
        common: true,
        size: 86400000,
        steps: 30
    },
    week: {
        common: false,
        size: 604800000,
        steps: 4
    },
    month: {
        common: true,
        size: 2.628e9,
        steps: 12
    },
    quarter: {
        common: false,
        size: 7.884e9,
        steps: 4
    },
    year: {
        common: true,
        size: 3.154e10
    }
};
 const UNITS =  /* #__PURE__ */ Object.keys(INTERVALS);
 function sorter(a, b) {
    return a - b;
}
 function parse(scale, input) {
    if (helpers_dataset.isNullOrUndef(input)) {
        return null;
    }
    const adapter = scale._adapter;
    const { parser , round , isoWeekday  } = scale._parseOpts;
    let value = input;
    if (typeof parser === 'function') {
        value = parser(value);
    }
    if (!helpers_dataset.isNumberFinite(value)) {
        value = typeof parser === 'string' ? adapter.parse(value, parser) : adapter.parse(value);
    }
    if (value === null) {
        return null;
    }
    if (round) {
        value = round === 'week' && (helpers_dataset.isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, 'isoWeek', isoWeekday) : adapter.startOf(value, round);
    }
    return +value;
}
 function determineUnitForAutoTicks(minUnit, min, max, capacity) {
    const ilen = UNITS.length;
    for(let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i){
        const interval = INTERVALS[UNITS[i]];
        const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
        if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
            return UNITS[i];
        }
    }
    return UNITS[ilen - 1];
}
 function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
    for(let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--){
        const unit = UNITS[i];
        if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
            return unit;
        }
    }
    return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
}
 function determineMajorUnit(unit) {
    for(let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i){
        if (INTERVALS[UNITS[i]].common) {
            return UNITS[i];
        }
    }
}
 function addTick(ticks, time, timestamps) {
    if (!timestamps) {
        ticks[time] = true;
    } else if (timestamps.length) {
        const { lo , hi  } = helpers_dataset._lookup(timestamps, time);
        const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
        ticks[timestamp] = true;
    }
}
 function setMajorTicks(scale, ticks, map, majorUnit) {
    const adapter = scale._adapter;
    const first = +adapter.startOf(ticks[0].value, majorUnit);
    const last = ticks[ticks.length - 1].value;
    let major, index;
    for(major = first; major <= last; major = +adapter.add(major, 1, majorUnit)){
        index = map[major];
        if (index >= 0) {
            ticks[index].major = true;
        }
    }
    return ticks;
}
 function ticksFromTimestamps(scale, values, majorUnit) {
    const ticks = [];
     const map = {};
    const ilen = values.length;
    let i, value;
    for(i = 0; i < ilen; ++i){
        value = values[i];
        map[value] = i;
        ticks.push({
            value,
            major: false
        });
    }
    return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map, majorUnit);
}
class TimeScale extends Scale {
    static id = 'time';
 static defaults = {
 bounds: 'data',
        adapters: {},
        time: {
            parser: false,
            unit: false,
            round: false,
            isoWeekday: false,
            minUnit: 'millisecond',
            displayFormats: {}
        },
        ticks: {
 source: 'auto',
            callback: false,
            major: {
                enabled: false
            }
        }
    };
 constructor(props){
        super(props);
         this._cache = {
            data: [],
            labels: [],
            all: []
        };
         this._unit = 'day';
         this._majorUnit = undefined;
        this._offsets = {};
        this._normalized = false;
        this._parseOpts = undefined;
    }
    init(scaleOpts, opts = {}) {
        const time = scaleOpts.time || (scaleOpts.time = {});
         const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
        adapter.init(opts);
        helpers_dataset.mergeIf(time.displayFormats, adapter.formats());
        this._parseOpts = {
            parser: time.parser,
            round: time.round,
            isoWeekday: time.isoWeekday
        };
        super.init(scaleOpts);
        this._normalized = opts.normalized;
    }
 parse(raw, index) {
        if (raw === undefined) {
            return null;
        }
        return parse(this, raw);
    }
    beforeLayout() {
        super.beforeLayout();
        this._cache = {
            data: [],
            labels: [],
            all: []
        };
    }
    determineDataLimits() {
        const options = this.options;
        const adapter = this._adapter;
        const unit = options.time.unit || 'day';
        let { min , max , minDefined , maxDefined  } = this.getUserBounds();
 function _applyBounds(bounds) {
            if (!minDefined && !isNaN(bounds.min)) {
                min = Math.min(min, bounds.min);
            }
            if (!maxDefined && !isNaN(bounds.max)) {
                max = Math.max(max, bounds.max);
            }
        }
        if (!minDefined || !maxDefined) {
            _applyBounds(this._getLabelBounds());
            if (options.bounds !== 'ticks' || options.ticks.source !== 'labels') {
                _applyBounds(this.getMinMax(false));
            }
        }
        min = helpers_dataset.isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
        max = helpers_dataset.isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
        this.min = Math.min(min, max - 1);
        this.max = Math.max(min + 1, max);
    }
 _getLabelBounds() {
        const arr = this.getLabelTimestamps();
        let min = Number.POSITIVE_INFINITY;
        let max = Number.NEGATIVE_INFINITY;
        if (arr.length) {
            min = arr[0];
            max = arr[arr.length - 1];
        }
        return {
            min,
            max
        };
    }
 buildTicks() {
        const options = this.options;
        const timeOpts = options.time;
        const tickOpts = options.ticks;
        const timestamps = tickOpts.source === 'labels' ? this.getLabelTimestamps() : this._generate();
        if (options.bounds === 'ticks' && timestamps.length) {
            this.min = this._userMin || timestamps[0];
            this.max = this._userMax || timestamps[timestamps.length - 1];
        }
        const min = this.min;
        const max = this.max;
        const ticks = helpers_dataset._filterBetween(timestamps, min, max);
        this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
        this._majorUnit = !tickOpts.major.enabled || this._unit === 'year' ? undefined : determineMajorUnit(this._unit);
        this.initOffsets(timestamps);
        if (options.reverse) {
            ticks.reverse();
        }
        return ticksFromTimestamps(this, ticks, this._majorUnit);
    }
    afterAutoSkip() {
        if (this.options.offsetAfterAutoskip) {
            this.initOffsets(this.ticks.map((tick)=>+tick.value));
        }
    }
 initOffsets(timestamps = []) {
        let start = 0;
        let end = 0;
        let first, last;
        if (this.options.offset && timestamps.length) {
            first = this.getDecimalForValue(timestamps[0]);
            if (timestamps.length === 1) {
                start = 1 - first;
            } else {
                start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
            }
            last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
            if (timestamps.length === 1) {
                end = last;
            } else {
                end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
            }
        }
        const limit = timestamps.length < 3 ? 0.5 : 0.25;
        start = helpers_dataset._limitValue(start, 0, limit);
        end = helpers_dataset._limitValue(end, 0, limit);
        this._offsets = {
            start,
            end,
            factor: 1 / (start + 1 + end)
        };
    }
 _generate() {
        const adapter = this._adapter;
        const min = this.min;
        const max = this.max;
        const options = this.options;
        const timeOpts = options.time;
        const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
        const stepSize = helpers_dataset.valueOrDefault(options.ticks.stepSize, 1);
        const weekday = minor === 'week' ? timeOpts.isoWeekday : false;
        const hasWeekday = helpers_dataset.isNumber(weekday) || weekday === true;
        const ticks = {};
        let first = min;
        let time, count;
        if (hasWeekday) {
            first = +adapter.startOf(first, 'isoWeek', weekday);
        }
        first = +adapter.startOf(first, hasWeekday ? 'day' : minor);
        if (adapter.diff(max, min, minor) > 100000 * stepSize) {
            throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);
        }
        const timestamps = options.ticks.source === 'data' && this.getDataTimestamps();
        for(time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++){
            addTick(ticks, time, timestamps);
        }
        if (time === max || options.bounds === 'ticks' || count === 1) {
            addTick(ticks, time, timestamps);
        }
        return Object.keys(ticks).sort(sorter).map((x)=>+x);
    }
 getLabelForValue(value) {
        const adapter = this._adapter;
        const timeOpts = this.options.time;
        if (timeOpts.tooltipFormat) {
            return adapter.format(value, timeOpts.tooltipFormat);
        }
        return adapter.format(value, timeOpts.displayFormats.datetime);
    }
 format(value, format) {
        const options = this.options;
        const formats = options.time.displayFormats;
        const unit = this._unit;
        const fmt = format || formats[unit];
        return this._adapter.format(value, fmt);
    }
 _tickFormatFunction(time, index, ticks, format) {
        const options = this.options;
        const formatter = options.ticks.callback;
        if (formatter) {
            return helpers_dataset.callback(formatter, [
                time,
                index,
                ticks
            ], this);
        }
        const formats = options.time.displayFormats;
        const unit = this._unit;
        const majorUnit = this._majorUnit;
        const minorFormat = unit && formats[unit];
        const majorFormat = majorUnit && formats[majorUnit];
        const tick = ticks[index];
        const major = majorUnit && majorFormat && tick && tick.major;
        return this._adapter.format(time, format || (major ? majorFormat : minorFormat));
    }
 generateTickLabels(ticks) {
        let i, ilen, tick;
        for(i = 0, ilen = ticks.length; i < ilen; ++i){
            tick = ticks[i];
            tick.label = this._tickFormatFunction(tick.value, i, ticks);
        }
    }
 getDecimalForValue(value) {
        return value === null ? NaN : (value - this.min) / (this.max - this.min);
    }
 getPixelForValue(value) {
        const offsets = this._offsets;
        const pos = this.getDecimalForValue(value);
        return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
    }
 getValueForPixel(pixel) {
        const offsets = this._offsets;
        const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
        return this.min + pos * (this.max - this.min);
    }
 _getLabelSize(label) {
        const ticksOpts = this.options.ticks;
        const tickLabelWidth = this.ctx.measureText(label).width;
        const angle = helpers_dataset.toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
        const cosRotation = Math.cos(angle);
        const sinRotation = Math.sin(angle);
        const tickFontSize = this._resolveTickFontOptions(0).size;
        return {
            w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
            h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
        };
    }
 _getLabelCapacity(exampleTime) {
        const timeOpts = this.options.time;
        const displayFormats = timeOpts.displayFormats;
        const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
        const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [
            exampleTime
        ], this._majorUnit), format);
        const size = this._getLabelSize(exampleLabel);
        const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
        return capacity > 0 ? capacity : 1;
    }
 getDataTimestamps() {
        let timestamps = this._cache.data || [];
        let i, ilen;
        if (timestamps.length) {
            return timestamps;
        }
        const metas = this.getMatchingVisibleMetas();
        if (this._normalized && metas.length) {
            return this._cache.data = metas[0].controller.getAllParsedValues(this);
        }
        for(i = 0, ilen = metas.length; i < ilen; ++i){
            timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
        }
        return this._cache.data = this.normalize(timestamps);
    }
 getLabelTimestamps() {
        const timestamps = this._cache.labels || [];
        let i, ilen;
        if (timestamps.length) {
            return timestamps;
        }
        const labels = this.getLabels();
        for(i = 0, ilen = labels.length; i < ilen; ++i){
            timestamps.push(parse(this, labels[i]));
        }
        return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
    }
 normalize(values) {
        return helpers_dataset._arrayUnique(values.sort(sorter));
    }
}

function interpolate(table, val, reverse) {
    let lo = 0;
    let hi = table.length - 1;
    let prevSource, nextSource, prevTarget, nextTarget;
    if (reverse) {
        if (val >= table[lo].pos && val <= table[hi].pos) {
            ({ lo , hi  } = helpers_dataset._lookupByKey(table, 'pos', val));
        }
        ({ pos: prevSource , time: prevTarget  } = table[lo]);
        ({ pos: nextSource , time: nextTarget  } = table[hi]);
    } else {
        if (val >= table[lo].time && val <= table[hi].time) {
            ({ lo , hi  } = helpers_dataset._lookupByKey(table, 'time', val));
        }
        ({ time: prevSource , pos: prevTarget  } = table[lo]);
        ({ time: nextSource , pos: nextTarget  } = table[hi]);
    }
    const span = nextSource - prevSource;
    return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
}
class TimeSeriesScale extends TimeScale {
    static id = 'timeseries';
 static defaults = TimeScale.defaults;
 constructor(props){
        super(props);
         this._table = [];
         this._minPos = undefined;
         this._tableRange = undefined;
    }
 initOffsets() {
        const timestamps = this._getTimestampsForTable();
        const table = this._table = this.buildLookupTable(timestamps);
        this._minPos = interpolate(table, this.min);
        this._tableRange = interpolate(table, this.max) - this._minPos;
        super.initOffsets(timestamps);
    }
 buildLookupTable(timestamps) {
        const { min , max  } = this;
        const items = [];
        const table = [];
        let i, ilen, prev, curr, next;
        for(i = 0, ilen = timestamps.length; i < ilen; ++i){
            curr = timestamps[i];
            if (curr >= min && curr <= max) {
                items.push(curr);
            }
        }
        if (items.length < 2) {
            return [
                {
                    time: min,
                    pos: 0
                },
                {
                    time: max,
                    pos: 1
                }
            ];
        }
        for(i = 0, ilen = items.length; i < ilen; ++i){
            next = items[i + 1];
            prev = items[i - 1];
            curr = items[i];
            if (Math.round((next + prev) / 2) !== curr) {
                table.push({
                    time: curr,
                    pos: i / (ilen - 1)
                });
            }
        }
        return table;
    }
 _generate() {
        const min = this.min;
        const max = this.max;
        let timestamps = super.getDataTimestamps();
        if (!timestamps.includes(min) || !timestamps.length) {
            timestamps.splice(0, 0, min);
        }
        if (!timestamps.includes(max) || timestamps.length === 1) {
            timestamps.push(max);
        }
        return timestamps.sort((a, b)=>a - b);
    }
 _getTimestampsForTable() {
        let timestamps = this._cache.all || [];
        if (timestamps.length) {
            return timestamps;
        }
        const data = this.getDataTimestamps();
        const label = this.getLabelTimestamps();
        if (data.length && label.length) {
            timestamps = this.normalize(data.concat(label));
        } else {
            timestamps = data.length ? data : label;
        }
        timestamps = this._cache.all = timestamps;
        return timestamps;
    }
 getDecimalForValue(value) {
        return (interpolate(this._table, value) - this._minPos) / this._tableRange;
    }
 getValueForPixel(pixel) {
        const offsets = this._offsets;
        const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
        return interpolate(this._table, decimal * this._tableRange + this._minPos, true);
    }
}

var scales = /*#__PURE__*/Object.freeze({
__proto__: null,
CategoryScale: CategoryScale,
LinearScale: LinearScale,
LogarithmicScale: LogarithmicScale,
RadialLinearScale: RadialLinearScale,
TimeScale: TimeScale,
TimeSeriesScale: TimeSeriesScale
});

const registerables = [
    controllers,
    elements,
    plugins,
    scales
];

exports.Ticks = helpers_dataset.Ticks;
exports.defaults = helpers_dataset.defaults;
exports.Animation = Animation;
exports.Animations = Animations;
exports.ArcElement = ArcElement;
exports.BarController = BarController;
exports.BarElement = BarElement;
exports.BasePlatform = BasePlatform;
exports.BasicPlatform = BasicPlatform;
exports.BubbleController = BubbleController;
exports.CategoryScale = CategoryScale;
exports.Chart = Chart;
exports.Colors = plugin_colors;
exports.DatasetController = DatasetController;
exports.Decimation = plugin_decimation;
exports.DomPlatform = DomPlatform;
exports.DoughnutController = DoughnutController;
exports.Element = Element;
exports.Filler = index;
exports.Interaction = Interaction;
exports.Legend = plugin_legend;
exports.LineController = LineController;
exports.LineElement = LineElement;
exports.LinearScale = LinearScale;
exports.LogarithmicScale = LogarithmicScale;
exports.PieController = PieController;
exports.PointElement = PointElement;
exports.PolarAreaController = PolarAreaController;
exports.RadarController = RadarController;
exports.RadialLinearScale = RadialLinearScale;
exports.Scale = Scale;
exports.ScatterController = ScatterController;
exports.SubTitle = plugin_subtitle;
exports.TimeScale = TimeScale;
exports.TimeSeriesScale = TimeSeriesScale;
exports.Title = plugin_title;
exports.Tooltip = plugin_tooltip;
exports._adapters = adapters;
exports._detectPlatform = _detectPlatform;
exports.animator = animator;
exports.controllers = controllers;
exports.elements = elements;
exports.layouts = layouts;
exports.plugins = plugins;
exports.registerables = registerables;
exports.registry = registry;
exports.scales = scales;
//# sourceMappingURL=chart.cjs.map


/***/ }),

/***/ "./node_modules/chart.js/dist/chunks/helpers.dataset.cjs":
/*!***************************************************************!*\
  !*** ./node_modules/chart.js/dist/chunks/helpers.dataset.cjs ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*!
 * Chart.js v4.5.0
 * https://www.chartjs.org
 * (c) 2025 Chart.js Contributors
 * Released under the MIT License
 */


var color$1 = __webpack_require__(/*! @kurkle/color */ "./node_modules/@kurkle/color/dist/color.cjs");

/**
 * @namespace Chart.helpers
 */ /**
 * An empty function that can be used, for example, for optional callback.
 */ function noop() {
/* noop */ }
/**
 * Returns a unique id, sequentially generated from a global variable.
 */ const uid = (()=>{
    let id = 0;
    return ()=>id++;
})();
/**
 * Returns true if `value` is neither null nor undefined, else returns false.
 * @param value - The value to test.
 * @since 2.7.0
 */ function isNullOrUndef(value) {
    return value === null || value === undefined;
}
/**
 * Returns true if `value` is an array (including typed arrays), else returns false.
 * @param value - The value to test.
 * @function
 */ function isArray(value) {
    if (Array.isArray && Array.isArray(value)) {
        return true;
    }
    const type = Object.prototype.toString.call(value);
    if (type.slice(0, 7) === '[object' && type.slice(-6) === 'Array]') {
        return true;
    }
    return false;
}
/**
 * Returns true if `value` is an object (excluding null), else returns false.
 * @param value - The value to test.
 * @since 2.7.0
 */ function isObject(value) {
    return value !== null && Object.prototype.toString.call(value) === '[object Object]';
}
/**
 * Returns true if `value` is a finite number, else returns false
 * @param value  - The value to test.
 */ function isNumberFinite(value) {
    return (typeof value === 'number' || value instanceof Number) && isFinite(+value);
}
/**
 * Returns `value` if finite, else returns `defaultValue`.
 * @param value - The value to return if defined.
 * @param defaultValue - The value to return if `value` is not finite.
 */ function finiteOrDefault(value, defaultValue) {
    return isNumberFinite(value) ? value : defaultValue;
}
/**
 * Returns `value` if defined, else returns `defaultValue`.
 * @param value - The value to return if defined.
 * @param defaultValue - The value to return if `value` is undefined.
 */ function valueOrDefault(value, defaultValue) {
    return typeof value === 'undefined' ? defaultValue : value;
}
const toPercentage = (value, dimension)=>typeof value === 'string' && value.endsWith('%') ? parseFloat(value) / 100 : +value / dimension;
const toDimension = (value, dimension)=>typeof value === 'string' && value.endsWith('%') ? parseFloat(value) / 100 * dimension : +value;
/**
 * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the
 * value returned by `fn`. If `fn` is not a function, this method returns undefined.
 * @param fn - The function to call.
 * @param args - The arguments with which `fn` should be called.
 * @param [thisArg] - The value of `this` provided for the call to `fn`.
 */ function callback(fn, args, thisArg) {
    if (fn && typeof fn.call === 'function') {
        return fn.apply(thisArg, args);
    }
}
function each(loopable, fn, thisArg, reverse) {
    let i, len, keys;
    if (isArray(loopable)) {
        len = loopable.length;
        if (reverse) {
            for(i = len - 1; i >= 0; i--){
                fn.call(thisArg, loopable[i], i);
            }
        } else {
            for(i = 0; i < len; i++){
                fn.call(thisArg, loopable[i], i);
            }
        }
    } else if (isObject(loopable)) {
        keys = Object.keys(loopable);
        len = keys.length;
        for(i = 0; i < len; i++){
            fn.call(thisArg, loopable[keys[i]], keys[i]);
        }
    }
}
/**
 * Returns true if the `a0` and `a1` arrays have the same content, else returns false.
 * @param a0 - The array to compare
 * @param a1 - The array to compare
 * @private
 */ function _elementsEqual(a0, a1) {
    let i, ilen, v0, v1;
    if (!a0 || !a1 || a0.length !== a1.length) {
        return false;
    }
    for(i = 0, ilen = a0.length; i < ilen; ++i){
        v0 = a0[i];
        v1 = a1[i];
        if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
            return false;
        }
    }
    return true;
}
/**
 * Returns a deep copy of `source` without keeping references on objects and arrays.
 * @param source - The value to clone.
 */ function clone(source) {
    if (isArray(source)) {
        return source.map(clone);
    }
    if (isObject(source)) {
        const target = Object.create(null);
        const keys = Object.keys(source);
        const klen = keys.length;
        let k = 0;
        for(; k < klen; ++k){
            target[keys[k]] = clone(source[keys[k]]);
        }
        return target;
    }
    return source;
}
function isValidKey(key) {
    return [
        '__proto__',
        'prototype',
        'constructor'
    ].indexOf(key) === -1;
}
/**
 * The default merger when Chart.helpers.merge is called without merger option.
 * Note(SB): also used by mergeConfig and mergeScaleConfig as fallback.
 * @private
 */ function _merger(key, target, source, options) {
    if (!isValidKey(key)) {
        return;
    }
    const tval = target[key];
    const sval = source[key];
    if (isObject(tval) && isObject(sval)) {
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        merge(tval, sval, options);
    } else {
        target[key] = clone(sval);
    }
}
function merge(target, source, options) {
    const sources = isArray(source) ? source : [
        source
    ];
    const ilen = sources.length;
    if (!isObject(target)) {
        return target;
    }
    options = options || {};
    const merger = options.merger || _merger;
    let current;
    for(let i = 0; i < ilen; ++i){
        current = sources[i];
        if (!isObject(current)) {
            continue;
        }
        const keys = Object.keys(current);
        for(let k = 0, klen = keys.length; k < klen; ++k){
            merger(keys[k], target, current, options);
        }
    }
    return target;
}
function mergeIf(target, source) {
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    return merge(target, source, {
        merger: _mergerIf
    });
}
/**
 * Merges source[key] in target[key] only if target[key] is undefined.
 * @private
 */ function _mergerIf(key, target, source) {
    if (!isValidKey(key)) {
        return;
    }
    const tval = target[key];
    const sval = source[key];
    if (isObject(tval) && isObject(sval)) {
        mergeIf(tval, sval);
    } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
        target[key] = clone(sval);
    }
}
/**
 * @private
 */ function _deprecated(scope, value, previous, current) {
    if (value !== undefined) {
        console.warn(scope + ': "' + previous + '" is deprecated. Please use "' + current + '" instead');
    }
}
// resolveObjectKey resolver cache
const keyResolvers = {
    // Chart.helpers.core resolveObjectKey should resolve empty key to root object
    '': (v)=>v,
    // default resolvers
    x: (o)=>o.x,
    y: (o)=>o.y
};
/**
 * @private
 */ function _splitKey(key) {
    const parts = key.split('.');
    const keys = [];
    let tmp = '';
    for (const part of parts){
        tmp += part;
        if (tmp.endsWith('\\')) {
            tmp = tmp.slice(0, -1) + '.';
        } else {
            keys.push(tmp);
            tmp = '';
        }
    }
    return keys;
}
function _getKeyResolver(key) {
    const keys = _splitKey(key);
    return (obj)=>{
        for (const k of keys){
            if (k === '') {
                break;
            }
            obj = obj && obj[k];
        }
        return obj;
    };
}
function resolveObjectKey(obj, key) {
    const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
    return resolver(obj);
}
/**
 * @private
 */ function _capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}
const defined = (value)=>typeof value !== 'undefined';
const isFunction = (value)=>typeof value === 'function';
// Adapted from https://stackoverflow.com/questions/31128855/comparing-ecma6-sets-for-equality#31129384
const setsEqual = (a, b)=>{
    if (a.size !== b.size) {
        return false;
    }
    for (const item of a){
        if (!b.has(item)) {
            return false;
        }
    }
    return true;
};
/**
 * @param e - The event
 * @private
 */ function _isClickEvent(e) {
    return e.type === 'mouseup' || e.type === 'click' || e.type === 'contextmenu';
}

/**
 * @alias Chart.helpers.math
 * @namespace
 */ const PI = Math.PI;
const TAU = 2 * PI;
const PITAU = TAU + PI;
const INFINITY = Number.POSITIVE_INFINITY;
const RAD_PER_DEG = PI / 180;
const HALF_PI = PI / 2;
const QUARTER_PI = PI / 4;
const TWO_THIRDS_PI = PI * 2 / 3;
const log10 = Math.log10;
const sign = Math.sign;
function almostEquals(x, y, epsilon) {
    return Math.abs(x - y) < epsilon;
}
/**
 * Implementation of the nice number algorithm used in determining where axis labels will go
 */ function niceNum(range) {
    const roundedRange = Math.round(range);
    range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;
    const niceRange = Math.pow(10, Math.floor(log10(range)));
    const fraction = range / niceRange;
    const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
    return niceFraction * niceRange;
}
/**
 * Returns an array of factors sorted from 1 to sqrt(value)
 * @private
 */ function _factorize(value) {
    const result = [];
    const sqrt = Math.sqrt(value);
    let i;
    for(i = 1; i < sqrt; i++){
        if (value % i === 0) {
            result.push(i);
            result.push(value / i);
        }
    }
    if (sqrt === (sqrt | 0)) {
        result.push(sqrt);
    }
    result.sort((a, b)=>a - b).pop();
    return result;
}
/**
 * Verifies that attempting to coerce n to string or number won't throw a TypeError.
 */ function isNonPrimitive(n) {
    return typeof n === 'symbol' || typeof n === 'object' && n !== null && !(Symbol.toPrimitive in n || 'toString' in n || 'valueOf' in n);
}
function isNumber(n) {
    return !isNonPrimitive(n) && !isNaN(parseFloat(n)) && isFinite(n);
}
function almostWhole(x, epsilon) {
    const rounded = Math.round(x);
    return rounded - epsilon <= x && rounded + epsilon >= x;
}
/**
 * @private
 */ function _setMinAndMaxByKey(array, target, property) {
    let i, ilen, value;
    for(i = 0, ilen = array.length; i < ilen; i++){
        value = array[i][property];
        if (!isNaN(value)) {
            target.min = Math.min(target.min, value);
            target.max = Math.max(target.max, value);
        }
    }
}
function toRadians(degrees) {
    return degrees * (PI / 180);
}
function toDegrees(radians) {
    return radians * (180 / PI);
}
/**
 * Returns the number of decimal places
 * i.e. the number of digits after the decimal point, of the value of this Number.
 * @param x - A number.
 * @returns The number of decimal places.
 * @private
 */ function _decimalPlaces(x) {
    if (!isNumberFinite(x)) {
        return;
    }
    let e = 1;
    let p = 0;
    while(Math.round(x * e) / e !== x){
        e *= 10;
        p++;
    }
    return p;
}
// Gets the angle from vertical upright to the point about a centre.
function getAngleFromPoint(centrePoint, anglePoint) {
    const distanceFromXCenter = anglePoint.x - centrePoint.x;
    const distanceFromYCenter = anglePoint.y - centrePoint.y;
    const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
    let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
    if (angle < -0.5 * PI) {
        angle += TAU; // make sure the returned angle is in the range of (-PI/2, 3PI/2]
    }
    return {
        angle,
        distance: radialDistanceFromCenter
    };
}
function distanceBetweenPoints(pt1, pt2) {
    return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
}
/**
 * Shortest distance between angles, in either direction.
 * @private
 */ function _angleDiff(a, b) {
    return (a - b + PITAU) % TAU - PI;
}
/**
 * Normalize angle to be between 0 and 2*PI
 * @private
 */ function _normalizeAngle(a) {
    return (a % TAU + TAU) % TAU;
}
/**
 * @private
 */ function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
    const a = _normalizeAngle(angle);
    const s = _normalizeAngle(start);
    const e = _normalizeAngle(end);
    const angleToStart = _normalizeAngle(s - a);
    const angleToEnd = _normalizeAngle(e - a);
    const startToAngle = _normalizeAngle(a - s);
    const endToAngle = _normalizeAngle(a - e);
    return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;
}
/**
 * Limit `value` between `min` and `max`
 * @param value
 * @param min
 * @param max
 * @private
 */ function _limitValue(value, min, max) {
    return Math.max(min, Math.min(max, value));
}
/**
 * @param {number} value
 * @private
 */ function _int16Range(value) {
    return _limitValue(value, -32768, 32767);
}
/**
 * @param value
 * @param start
 * @param end
 * @param [epsilon]
 * @private
 */ function _isBetween(value, start, end, epsilon = 1e-6) {
    return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;
}

function _lookup(table, value, cmp) {
    cmp = cmp || ((index)=>table[index] < value);
    let hi = table.length - 1;
    let lo = 0;
    let mid;
    while(hi - lo > 1){
        mid = lo + hi >> 1;
        if (cmp(mid)) {
            lo = mid;
        } else {
            hi = mid;
        }
    }
    return {
        lo,
        hi
    };
}
/**
 * Binary search
 * @param table - the table search. must be sorted!
 * @param key - property name for the value in each entry
 * @param value - value to find
 * @param last - lookup last index
 * @private
 */ const _lookupByKey = (table, key, value, last)=>_lookup(table, value, last ? (index)=>{
        const ti = table[index][key];
        return ti < value || ti === value && table[index + 1][key] === value;
    } : (index)=>table[index][key] < value);
/**
 * Reverse binary search
 * @param table - the table search. must be sorted!
 * @param key - property name for the value in each entry
 * @param value - value to find
 * @private
 */ const _rlookupByKey = (table, key, value)=>_lookup(table, value, (index)=>table[index][key] >= value);
/**
 * Return subset of `values` between `min` and `max` inclusive.
 * Values are assumed to be in sorted order.
 * @param values - sorted array of values
 * @param min - min value
 * @param max - max value
 */ function _filterBetween(values, min, max) {
    let start = 0;
    let end = values.length;
    while(start < end && values[start] < min){
        start++;
    }
    while(end > start && values[end - 1] > max){
        end--;
    }
    return start > 0 || end < values.length ? values.slice(start, end) : values;
}
const arrayEvents = [
    'push',
    'pop',
    'shift',
    'splice',
    'unshift'
];
function listenArrayEvents(array, listener) {
    if (array._chartjs) {
        array._chartjs.listeners.push(listener);
        return;
    }
    Object.defineProperty(array, '_chartjs', {
        configurable: true,
        enumerable: false,
        value: {
            listeners: [
                listener
            ]
        }
    });
    arrayEvents.forEach((key)=>{
        const method = '_onData' + _capitalize(key);
        const base = array[key];
        Object.defineProperty(array, key, {
            configurable: true,
            enumerable: false,
            value (...args) {
                const res = base.apply(this, args);
                array._chartjs.listeners.forEach((object)=>{
                    if (typeof object[method] === 'function') {
                        object[method](...args);
                    }
                });
                return res;
            }
        });
    });
}
function unlistenArrayEvents(array, listener) {
    const stub = array._chartjs;
    if (!stub) {
        return;
    }
    const listeners = stub.listeners;
    const index = listeners.indexOf(listener);
    if (index !== -1) {
        listeners.splice(index, 1);
    }
    if (listeners.length > 0) {
        return;
    }
    arrayEvents.forEach((key)=>{
        delete array[key];
    });
    delete array._chartjs;
}
/**
 * @param items
 */ function _arrayUnique(items) {
    const set = new Set(items);
    if (set.size === items.length) {
        return items;
    }
    return Array.from(set);
}

function fontString(pixelSize, fontStyle, fontFamily) {
    return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;
}
/**
* Request animation polyfill
*/ const requestAnimFrame = function() {
    if (typeof window === 'undefined') {
        return function(callback) {
            return callback();
        };
    }
    return window.requestAnimationFrame;
}();
/**
 * Throttles calling `fn` once per animation frame
 * Latest arguments are used on the actual call
 */ function throttled(fn, thisArg) {
    let argsToUse = [];
    let ticking = false;
    return function(...args) {
        // Save the args for use later
        argsToUse = args;
        if (!ticking) {
            ticking = true;
            requestAnimFrame.call(window, ()=>{
                ticking = false;
                fn.apply(thisArg, argsToUse);
            });
        }
    };
}
/**
 * Debounces calling `fn` for `delay` ms
 */ function debounce(fn, delay) {
    let timeout;
    return function(...args) {
        if (delay) {
            clearTimeout(timeout);
            timeout = setTimeout(fn, delay, args);
        } else {
            fn.apply(this, args);
        }
        return delay;
    };
}
/**
 * Converts 'start' to 'left', 'end' to 'right' and others to 'center'
 * @private
 */ const _toLeftRightCenter = (align)=>align === 'start' ? 'left' : align === 'end' ? 'right' : 'center';
/**
 * Returns `start`, `end` or `(start + end) / 2` depending on `align`. Defaults to `center`
 * @private
 */ const _alignStartEnd = (align, start, end)=>align === 'start' ? start : align === 'end' ? end : (start + end) / 2;
/**
 * Returns `left`, `right` or `(left + right) / 2` depending on `align`. Defaults to `left`
 * @private
 */ const _textX = (align, left, right, rtl)=>{
    const check = rtl ? 'left' : 'right';
    return align === check ? right : align === 'center' ? (left + right) / 2 : left;
};
/**
 * Return start and count of visible points.
 * @private
 */ function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
    const pointCount = points.length;
    let start = 0;
    let count = pointCount;
    if (meta._sorted) {
        const { iScale , vScale , _parsed  } = meta;
        const spanGaps = meta.dataset ? meta.dataset.options ? meta.dataset.options.spanGaps : null : null;
        const axis = iScale.axis;
        const { min , max , minDefined , maxDefined  } = iScale.getUserBounds();
        if (minDefined) {
            start = Math.min(// @ts-expect-error Need to type _parsed
            _lookupByKey(_parsed, axis, min).lo, // @ts-expect-error Need to fix types on _lookupByKey
            animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo);
            if (spanGaps) {
                const distanceToDefinedLo = _parsed.slice(0, start + 1).reverse().findIndex((point)=>!isNullOrUndef(point[vScale.axis]));
                start -= Math.max(0, distanceToDefinedLo);
            }
            start = _limitValue(start, 0, pointCount - 1);
        }
        if (maxDefined) {
            let end = Math.max(// @ts-expect-error Need to type _parsed
            _lookupByKey(_parsed, iScale.axis, max, true).hi + 1, // @ts-expect-error Need to fix types on _lookupByKey
            animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1);
            if (spanGaps) {
                const distanceToDefinedHi = _parsed.slice(end - 1).findIndex((point)=>!isNullOrUndef(point[vScale.axis]));
                end += Math.max(0, distanceToDefinedHi);
            }
            count = _limitValue(end, start, pointCount) - start;
        } else {
            count = pointCount - start;
        }
    }
    return {
        start,
        count
    };
}
/**
 * Checks if the scale ranges have changed.
 * @param {object} meta - dataset meta.
 * @returns {boolean}
 * @private
 */ function _scaleRangesChanged(meta) {
    const { xScale , yScale , _scaleRanges  } = meta;
    const newRanges = {
        xmin: xScale.min,
        xmax: xScale.max,
        ymin: yScale.min,
        ymax: yScale.max
    };
    if (!_scaleRanges) {
        meta._scaleRanges = newRanges;
        return true;
    }
    const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
    Object.assign(_scaleRanges, newRanges);
    return changed;
}

const atEdge = (t)=>t === 0 || t === 1;
const elasticIn = (t, s, p)=>-(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));
const elasticOut = (t, s, p)=>Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;
/**
 * Easing functions adapted from Robert Penner's easing equations.
 * @namespace Chart.helpers.easing.effects
 * @see http://www.robertpenner.com/easing/
 */ const effects = {
    linear: (t)=>t,
    easeInQuad: (t)=>t * t,
    easeOutQuad: (t)=>-t * (t - 2),
    easeInOutQuad: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),
    easeInCubic: (t)=>t * t * t,
    easeOutCubic: (t)=>(t -= 1) * t * t + 1,
    easeInOutCubic: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),
    easeInQuart: (t)=>t * t * t * t,
    easeOutQuart: (t)=>-((t -= 1) * t * t * t - 1),
    easeInOutQuart: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),
    easeInQuint: (t)=>t * t * t * t * t,
    easeOutQuint: (t)=>(t -= 1) * t * t * t * t + 1,
    easeInOutQuint: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),
    easeInSine: (t)=>-Math.cos(t * HALF_PI) + 1,
    easeOutSine: (t)=>Math.sin(t * HALF_PI),
    easeInOutSine: (t)=>-0.5 * (Math.cos(PI * t) - 1),
    easeInExpo: (t)=>t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
    easeOutExpo: (t)=>t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
    easeInOutExpo: (t)=>atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
    easeInCirc: (t)=>t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),
    easeOutCirc: (t)=>Math.sqrt(1 - (t -= 1) * t),
    easeInOutCirc: (t)=>(t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
    easeInElastic: (t)=>atEdge(t) ? t : elasticIn(t, 0.075, 0.3),
    easeOutElastic: (t)=>atEdge(t) ? t : elasticOut(t, 0.075, 0.3),
    easeInOutElastic (t) {
        const s = 0.1125;
        const p = 0.45;
        return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);
    },
    easeInBack (t) {
        const s = 1.70158;
        return t * t * ((s + 1) * t - s);
    },
    easeOutBack (t) {
        const s = 1.70158;
        return (t -= 1) * t * ((s + 1) * t + s) + 1;
    },
    easeInOutBack (t) {
        let s = 1.70158;
        if ((t /= 0.5) < 1) {
            return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
        }
        return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
    },
    easeInBounce: (t)=>1 - effects.easeOutBounce(1 - t),
    easeOutBounce (t) {
        const m = 7.5625;
        const d = 2.75;
        if (t < 1 / d) {
            return m * t * t;
        }
        if (t < 2 / d) {
            return m * (t -= 1.5 / d) * t + 0.75;
        }
        if (t < 2.5 / d) {
            return m * (t -= 2.25 / d) * t + 0.9375;
        }
        return m * (t -= 2.625 / d) * t + 0.984375;
    },
    easeInOutBounce: (t)=>t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5
};

function isPatternOrGradient(value) {
    if (value && typeof value === 'object') {
        const type = value.toString();
        return type === '[object CanvasPattern]' || type === '[object CanvasGradient]';
    }
    return false;
}
function color(value) {
    return isPatternOrGradient(value) ? value : new color$1.Color(value);
}
function getHoverColor(value) {
    return isPatternOrGradient(value) ? value : new color$1.Color(value).saturate(0.5).darken(0.1).hexString();
}

const numbers = [
    'x',
    'y',
    'borderWidth',
    'radius',
    'tension'
];
const colors = [
    'color',
    'borderColor',
    'backgroundColor'
];
function applyAnimationsDefaults(defaults) {
    defaults.set('animation', {
        delay: undefined,
        duration: 1000,
        easing: 'easeOutQuart',
        fn: undefined,
        from: undefined,
        loop: undefined,
        to: undefined,
        type: undefined
    });
    defaults.describe('animation', {
        _fallback: false,
        _indexable: false,
        _scriptable: (name)=>name !== 'onProgress' && name !== 'onComplete' && name !== 'fn'
    });
    defaults.set('animations', {
        colors: {
            type: 'color',
            properties: colors
        },
        numbers: {
            type: 'number',
            properties: numbers
        }
    });
    defaults.describe('animations', {
        _fallback: 'animation'
    });
    defaults.set('transitions', {
        active: {
            animation: {
                duration: 400
            }
        },
        resize: {
            animation: {
                duration: 0
            }
        },
        show: {
            animations: {
                colors: {
                    from: 'transparent'
                },
                visible: {
                    type: 'boolean',
                    duration: 0
                }
            }
        },
        hide: {
            animations: {
                colors: {
                    to: 'transparent'
                },
                visible: {
                    type: 'boolean',
                    easing: 'linear',
                    fn: (v)=>v | 0
                }
            }
        }
    });
}

function applyLayoutsDefaults(defaults) {
    defaults.set('layout', {
        autoPadding: true,
        padding: {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
        }
    });
}

const intlCache = new Map();
function getNumberFormat(locale, options) {
    options = options || {};
    const cacheKey = locale + JSON.stringify(options);
    let formatter = intlCache.get(cacheKey);
    if (!formatter) {
        formatter = new Intl.NumberFormat(locale, options);
        intlCache.set(cacheKey, formatter);
    }
    return formatter;
}
function formatNumber(num, locale, options) {
    return getNumberFormat(locale, options).format(num);
}

const formatters = {
 values (value) {
        return isArray(value) ?  value : '' + value;
    },
 numeric (tickValue, index, ticks) {
        if (tickValue === 0) {
            return '0';
        }
        const locale = this.chart.options.locale;
        let notation;
        let delta = tickValue;
        if (ticks.length > 1) {
            const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
            if (maxTick < 1e-4 || maxTick > 1e+15) {
                notation = 'scientific';
            }
            delta = calculateDelta(tickValue, ticks);
        }
        const logDelta = log10(Math.abs(delta));
        const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
        const options = {
            notation,
            minimumFractionDigits: numDecimal,
            maximumFractionDigits: numDecimal
        };
        Object.assign(options, this.options.ticks.format);
        return formatNumber(tickValue, locale, options);
    },
 logarithmic (tickValue, index, ticks) {
        if (tickValue === 0) {
            return '0';
        }
        const remain = ticks[index].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));
        if ([
            1,
            2,
            3,
            5,
            10,
            15
        ].includes(remain) || index > 0.8 * ticks.length) {
            return formatters.numeric.call(this, tickValue, index, ticks);
        }
        return '';
    }
};
function calculateDelta(tickValue, ticks) {
    let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
    if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
        delta = tickValue - Math.floor(tickValue);
    }
    return delta;
}
 var Ticks = {
    formatters
};

function applyScaleDefaults(defaults) {
    defaults.set('scale', {
        display: true,
        offset: false,
        reverse: false,
        beginAtZero: false,
 bounds: 'ticks',
        clip: true,
 grace: 0,
        grid: {
            display: true,
            lineWidth: 1,
            drawOnChartArea: true,
            drawTicks: true,
            tickLength: 8,
            tickWidth: (_ctx, options)=>options.lineWidth,
            tickColor: (_ctx, options)=>options.color,
            offset: false
        },
        border: {
            display: true,
            dash: [],
            dashOffset: 0.0,
            width: 1
        },
        title: {
            display: false,
            text: '',
            padding: {
                top: 4,
                bottom: 4
            }
        },
        ticks: {
            minRotation: 0,
            maxRotation: 50,
            mirror: false,
            textStrokeWidth: 0,
            textStrokeColor: '',
            padding: 3,
            display: true,
            autoSkip: true,
            autoSkipPadding: 3,
            labelOffset: 0,
            callback: Ticks.formatters.values,
            minor: {},
            major: {},
            align: 'center',
            crossAlign: 'near',
            showLabelBackdrop: false,
            backdropColor: 'rgba(255, 255, 255, 0.75)',
            backdropPadding: 2
        }
    });
    defaults.route('scale.ticks', 'color', '', 'color');
    defaults.route('scale.grid', 'color', '', 'borderColor');
    defaults.route('scale.border', 'color', '', 'borderColor');
    defaults.route('scale.title', 'color', '', 'color');
    defaults.describe('scale', {
        _fallback: false,
        _scriptable: (name)=>!name.startsWith('before') && !name.startsWith('after') && name !== 'callback' && name !== 'parser',
        _indexable: (name)=>name !== 'borderDash' && name !== 'tickBorderDash' && name !== 'dash'
    });
    defaults.describe('scales', {
        _fallback: 'scale'
    });
    defaults.describe('scale.ticks', {
        _scriptable: (name)=>name !== 'backdropPadding' && name !== 'callback',
        _indexable: (name)=>name !== 'backdropPadding'
    });
}

const overrides = Object.create(null);
const descriptors = Object.create(null);
 function getScope$1(node, key) {
    if (!key) {
        return node;
    }
    const keys = key.split('.');
    for(let i = 0, n = keys.length; i < n; ++i){
        const k = keys[i];
        node = node[k] || (node[k] = Object.create(null));
    }
    return node;
}
function set(root, scope, values) {
    if (typeof scope === 'string') {
        return merge(getScope$1(root, scope), values);
    }
    return merge(getScope$1(root, ''), scope);
}
 class Defaults {
    constructor(_descriptors, _appliers){
        this.animation = undefined;
        this.backgroundColor = 'rgba(0,0,0,0.1)';
        this.borderColor = 'rgba(0,0,0,0.1)';
        this.color = '#666';
        this.datasets = {};
        this.devicePixelRatio = (context)=>context.chart.platform.getDevicePixelRatio();
        this.elements = {};
        this.events = [
            'mousemove',
            'mouseout',
            'click',
            'touchstart',
            'touchmove'
        ];
        this.font = {
            family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
            size: 12,
            style: 'normal',
            lineHeight: 1.2,
            weight: null
        };
        this.hover = {};
        this.hoverBackgroundColor = (ctx, options)=>getHoverColor(options.backgroundColor);
        this.hoverBorderColor = (ctx, options)=>getHoverColor(options.borderColor);
        this.hoverColor = (ctx, options)=>getHoverColor(options.color);
        this.indexAxis = 'x';
        this.interaction = {
            mode: 'nearest',
            intersect: true,
            includeInvisible: false
        };
        this.maintainAspectRatio = true;
        this.onHover = null;
        this.onClick = null;
        this.parsing = true;
        this.plugins = {};
        this.responsive = true;
        this.scale = undefined;
        this.scales = {};
        this.showLine = true;
        this.drawActiveElementsOnTop = true;
        this.describe(_descriptors);
        this.apply(_appliers);
    }
 set(scope, values) {
        return set(this, scope, values);
    }
 get(scope) {
        return getScope$1(this, scope);
    }
 describe(scope, values) {
        return set(descriptors, scope, values);
    }
    override(scope, values) {
        return set(overrides, scope, values);
    }
 route(scope, name, targetScope, targetName) {
        const scopeObject = getScope$1(this, scope);
        const targetScopeObject = getScope$1(this, targetScope);
        const privateName = '_' + name;
        Object.defineProperties(scopeObject, {
            [privateName]: {
                value: scopeObject[name],
                writable: true
            },
            [name]: {
                enumerable: true,
                get () {
                    const local = this[privateName];
                    const target = targetScopeObject[targetName];
                    if (isObject(local)) {
                        return Object.assign({}, target, local);
                    }
                    return valueOrDefault(local, target);
                },
                set (value) {
                    this[privateName] = value;
                }
            }
        });
    }
    apply(appliers) {
        appliers.forEach((apply)=>apply(this));
    }
}
var defaults = /* #__PURE__ */ new Defaults({
    _scriptable: (name)=>!name.startsWith('on'),
    _indexable: (name)=>name !== 'events',
    hover: {
        _fallback: 'interaction'
    },
    interaction: {
        _scriptable: false,
        _indexable: false
    }
}, [
    applyAnimationsDefaults,
    applyLayoutsDefaults,
    applyScaleDefaults
]);

/**
 * Converts the given font object into a CSS font string.
 * @param font - A font object.
 * @return The CSS font string. See https://developer.mozilla.org/en-US/docs/Web/CSS/font
 * @private
 */ function toFontString(font) {
    if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
        return null;
    }
    return (font.style ? font.style + ' ' : '') + (font.weight ? font.weight + ' ' : '') + font.size + 'px ' + font.family;
}
/**
 * @private
 */ function _measureText(ctx, data, gc, longest, string) {
    let textWidth = data[string];
    if (!textWidth) {
        textWidth = data[string] = ctx.measureText(string).width;
        gc.push(string);
    }
    if (textWidth > longest) {
        longest = textWidth;
    }
    return longest;
}
/**
 * @private
 */ // eslint-disable-next-line complexity
function _longestText(ctx, font, arrayOfThings, cache) {
    cache = cache || {};
    let data = cache.data = cache.data || {};
    let gc = cache.garbageCollect = cache.garbageCollect || [];
    if (cache.font !== font) {
        data = cache.data = {};
        gc = cache.garbageCollect = [];
        cache.font = font;
    }
    ctx.save();
    ctx.font = font;
    let longest = 0;
    const ilen = arrayOfThings.length;
    let i, j, jlen, thing, nestedThing;
    for(i = 0; i < ilen; i++){
        thing = arrayOfThings[i];
        // Undefined strings and arrays should not be measured
        if (thing !== undefined && thing !== null && !isArray(thing)) {
            longest = _measureText(ctx, data, gc, longest, thing);
        } else if (isArray(thing)) {
            // if it is an array lets measure each element
            // to do maybe simplify this function a bit so we can do this more recursively?
            for(j = 0, jlen = thing.length; j < jlen; j++){
                nestedThing = thing[j];
                // Undefined strings and arrays should not be measured
                if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) {
                    longest = _measureText(ctx, data, gc, longest, nestedThing);
                }
            }
        }
    }
    ctx.restore();
    const gcLen = gc.length / 2;
    if (gcLen > arrayOfThings.length) {
        for(i = 0; i < gcLen; i++){
            delete data[gc[i]];
        }
        gc.splice(0, gcLen);
    }
    return longest;
}
/**
 * Returns the aligned pixel value to avoid anti-aliasing blur
 * @param chart - The chart instance.
 * @param pixel - A pixel value.
 * @param width - The width of the element.
 * @returns The aligned pixel value.
 * @private
 */ function _alignPixel(chart, pixel, width) {
    const devicePixelRatio = chart.currentDevicePixelRatio;
    const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
    return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
}
/**
 * Clears the entire canvas.
 */ function clearCanvas(canvas, ctx) {
    if (!ctx && !canvas) {
        return;
    }
    ctx = ctx || canvas.getContext('2d');
    ctx.save();
    // canvas.width and canvas.height do not consider the canvas transform,
    // while clearRect does
    ctx.resetTransform();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.restore();
}
function drawPoint(ctx, options, x, y) {
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    drawPointLegend(ctx, options, x, y, null);
}
// eslint-disable-next-line complexity
function drawPointLegend(ctx, options, x, y, w) {
    let type, xOffset, yOffset, size, cornerRadius, width, xOffsetW, yOffsetW;
    const style = options.pointStyle;
    const rotation = options.rotation;
    const radius = options.radius;
    let rad = (rotation || 0) * RAD_PER_DEG;
    if (style && typeof style === 'object') {
        type = style.toString();
        if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rad);
            ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
            ctx.restore();
            return;
        }
    }
    if (isNaN(radius) || radius <= 0) {
        return;
    }
    ctx.beginPath();
    switch(style){
        // Default includes circle
        default:
            if (w) {
                ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);
            } else {
                ctx.arc(x, y, radius, 0, TAU);
            }
            ctx.closePath();
            break;
        case 'triangle':
            width = w ? w / 2 : radius;
            ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
            rad += TWO_THIRDS_PI;
            ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
            rad += TWO_THIRDS_PI;
            ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
            ctx.closePath();
            break;
        case 'rectRounded':
            // NOTE: the rounded rect implementation changed to use `arc` instead of
            // `quadraticCurveTo` since it generates better results when rect is
            // almost a circle. 0.516 (instead of 0.5) produces results with visually
            // closer proportion to the previous impl and it is inscribed in the
            // circle with `radius`. For more details, see the following PRs:
            // https://github.com/chartjs/Chart.js/issues/5597
            // https://github.com/chartjs/Chart.js/issues/5858
            cornerRadius = radius * 0.516;
            size = radius - cornerRadius;
            xOffset = Math.cos(rad + QUARTER_PI) * size;
            xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
            yOffset = Math.sin(rad + QUARTER_PI) * size;
            yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
            ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
            ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);
            ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);
            ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
            ctx.closePath();
            break;
        case 'rect':
            if (!rotation) {
                size = Math.SQRT1_2 * radius;
                width = w ? w / 2 : size;
                ctx.rect(x - width, y - size, 2 * width, 2 * size);
                break;
            }
            rad += QUARTER_PI;
        /* falls through */ case 'rectRot':
            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
            ctx.moveTo(x - xOffsetW, y - yOffset);
            ctx.lineTo(x + yOffsetW, y - xOffset);
            ctx.lineTo(x + xOffsetW, y + yOffset);
            ctx.lineTo(x - yOffsetW, y + xOffset);
            ctx.closePath();
            break;
        case 'crossRot':
            rad += QUARTER_PI;
        /* falls through */ case 'cross':
            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
            ctx.moveTo(x - xOffsetW, y - yOffset);
            ctx.lineTo(x + xOffsetW, y + yOffset);
            ctx.moveTo(x + yOffsetW, y - xOffset);
            ctx.lineTo(x - yOffsetW, y + xOffset);
            break;
        case 'star':
            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
            ctx.moveTo(x - xOffsetW, y - yOffset);
            ctx.lineTo(x + xOffsetW, y + yOffset);
            ctx.moveTo(x + yOffsetW, y - xOffset);
            ctx.lineTo(x - yOffsetW, y + xOffset);
            rad += QUARTER_PI;
            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
            ctx.moveTo(x - xOffsetW, y - yOffset);
            ctx.lineTo(x + xOffsetW, y + yOffset);
            ctx.moveTo(x + yOffsetW, y - xOffset);
            ctx.lineTo(x - yOffsetW, y + xOffset);
            break;
        case 'line':
            xOffset = w ? w / 2 : Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            break;
        case 'dash':
            ctx.moveTo(x, y);
            ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);
            break;
        case false:
            ctx.closePath();
            break;
    }
    ctx.fill();
    if (options.borderWidth > 0) {
        ctx.stroke();
    }
}
/**
 * Returns true if the point is inside the rectangle
 * @param point - The point to test
 * @param area - The rectangle
 * @param margin - allowed margin
 * @private
 */ function _isPointInArea(point, area, margin) {
    margin = margin || 0.5; // margin - default is to match rounded decimals
    return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
}
function clipArea(ctx, area) {
    ctx.save();
    ctx.beginPath();
    ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
    ctx.clip();
}
function unclipArea(ctx) {
    ctx.restore();
}
/**
 * @private
 */ function _steppedLineTo(ctx, previous, target, flip, mode) {
    if (!previous) {
        return ctx.lineTo(target.x, target.y);
    }
    if (mode === 'middle') {
        const midpoint = (previous.x + target.x) / 2.0;
        ctx.lineTo(midpoint, previous.y);
        ctx.lineTo(midpoint, target.y);
    } else if (mode === 'after' !== !!flip) {
        ctx.lineTo(previous.x, target.y);
    } else {
        ctx.lineTo(target.x, previous.y);
    }
    ctx.lineTo(target.x, target.y);
}
/**
 * @private
 */ function _bezierCurveTo(ctx, previous, target, flip) {
    if (!previous) {
        return ctx.lineTo(target.x, target.y);
    }
    ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);
}
function setRenderOpts(ctx, opts) {
    if (opts.translation) {
        ctx.translate(opts.translation[0], opts.translation[1]);
    }
    if (!isNullOrUndef(opts.rotation)) {
        ctx.rotate(opts.rotation);
    }
    if (opts.color) {
        ctx.fillStyle = opts.color;
    }
    if (opts.textAlign) {
        ctx.textAlign = opts.textAlign;
    }
    if (opts.textBaseline) {
        ctx.textBaseline = opts.textBaseline;
    }
}
function decorateText(ctx, x, y, line, opts) {
    if (opts.strikethrough || opts.underline) {
        /**
     * Now that IE11 support has been dropped, we can use more
     * of the TextMetrics object. The actual bounding boxes
     * are unflagged in Chrome, Firefox, Edge, and Safari so they
     * can be safely used.
     * See https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics#Browser_compatibility
     */ const metrics = ctx.measureText(line);
        const left = x - metrics.actualBoundingBoxLeft;
        const right = x + metrics.actualBoundingBoxRight;
        const top = y - metrics.actualBoundingBoxAscent;
        const bottom = y + metrics.actualBoundingBoxDescent;
        const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
        ctx.strokeStyle = ctx.fillStyle;
        ctx.beginPath();
        ctx.lineWidth = opts.decorationWidth || 2;
        ctx.moveTo(left, yDecoration);
        ctx.lineTo(right, yDecoration);
        ctx.stroke();
    }
}
function drawBackdrop(ctx, opts) {
    const oldColor = ctx.fillStyle;
    ctx.fillStyle = opts.color;
    ctx.fillRect(opts.left, opts.top, opts.width, opts.height);
    ctx.fillStyle = oldColor;
}
/**
 * Render text onto the canvas
 */ function renderText(ctx, text, x, y, font, opts = {}) {
    const lines = isArray(text) ? text : [
        text
    ];
    const stroke = opts.strokeWidth > 0 && opts.strokeColor !== '';
    let i, line;
    ctx.save();
    ctx.font = font.string;
    setRenderOpts(ctx, opts);
    for(i = 0; i < lines.length; ++i){
        line = lines[i];
        if (opts.backdrop) {
            drawBackdrop(ctx, opts.backdrop);
        }
        if (stroke) {
            if (opts.strokeColor) {
                ctx.strokeStyle = opts.strokeColor;
            }
            if (!isNullOrUndef(opts.strokeWidth)) {
                ctx.lineWidth = opts.strokeWidth;
            }
            ctx.strokeText(line, x, y, opts.maxWidth);
        }
        ctx.fillText(line, x, y, opts.maxWidth);
        decorateText(ctx, x, y, line, opts);
        y += Number(font.lineHeight);
    }
    ctx.restore();
}
/**
 * Add a path of a rectangle with rounded corners to the current sub-path
 * @param ctx - Context
 * @param rect - Bounding rect
 */ function addRoundedRectPath(ctx, rect) {
    const { x , y , w , h , radius  } = rect;
    // top left arc
    ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, 1.5 * PI, PI, true);
    // line from top left to bottom left
    ctx.lineTo(x, y + h - radius.bottomLeft);
    // bottom left arc
    ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
    // line from bottom left to bottom right
    ctx.lineTo(x + w - radius.bottomRight, y + h);
    // bottom right arc
    ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
    // line from bottom right to top right
    ctx.lineTo(x + w, y + radius.topRight);
    // top right arc
    ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
    // line from top right to top left
    ctx.lineTo(x + radius.topLeft, y);
}

const LINE_HEIGHT = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/;
const FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
/**
 * @alias Chart.helpers.options
 * @namespace
 */ /**
 * Converts the given line height `value` in pixels for a specific font `size`.
 * @param value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').
 * @param size - The font size (in pixels) used to resolve relative `value`.
 * @returns The effective line height in pixels (size * 1.2 if value is invalid).
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height
 * @since 2.7.0
 */ function toLineHeight(value, size) {
    const matches = ('' + value).match(LINE_HEIGHT);
    if (!matches || matches[1] === 'normal') {
        return size * 1.2;
    }
    value = +matches[2];
    switch(matches[3]){
        case 'px':
            return value;
        case '%':
            value /= 100;
            break;
    }
    return size * value;
}
const numberOrZero = (v)=>+v || 0;
function _readValueToProps(value, props) {
    const ret = {};
    const objProps = isObject(props);
    const keys = objProps ? Object.keys(props) : props;
    const read = isObject(value) ? objProps ? (prop)=>valueOrDefault(value[prop], value[props[prop]]) : (prop)=>value[prop] : ()=>value;
    for (const prop of keys){
        ret[prop] = numberOrZero(read(prop));
    }
    return ret;
}
/**
 * Converts the given value into a TRBL object.
 * @param value - If a number, set the value to all TRBL component,
 *  else, if an object, use defined properties and sets undefined ones to 0.
 *  x / y are shorthands for same value for left/right and top/bottom.
 * @returns The padding values (top, right, bottom, left)
 * @since 3.0.0
 */ function toTRBL(value) {
    return _readValueToProps(value, {
        top: 'y',
        right: 'x',
        bottom: 'y',
        left: 'x'
    });
}
/**
 * Converts the given value into a TRBL corners object (similar with css border-radius).
 * @param value - If a number, set the value to all TRBL corner components,
 *  else, if an object, use defined properties and sets undefined ones to 0.
 * @returns The TRBL corner values (topLeft, topRight, bottomLeft, bottomRight)
 * @since 3.0.0
 */ function toTRBLCorners(value) {
    return _readValueToProps(value, [
        'topLeft',
        'topRight',
        'bottomLeft',
        'bottomRight'
    ]);
}
/**
 * Converts the given value into a padding object with pre-computed width/height.
 * @param value - If a number, set the value to all TRBL component,
 *  else, if an object, use defined properties and sets undefined ones to 0.
 *  x / y are shorthands for same value for left/right and top/bottom.
 * @returns The padding values (top, right, bottom, left, width, height)
 * @since 2.7.0
 */ function toPadding(value) {
    const obj = toTRBL(value);
    obj.width = obj.left + obj.right;
    obj.height = obj.top + obj.bottom;
    return obj;
}
/**
 * Parses font options and returns the font object.
 * @param options - A object that contains font options to be parsed.
 * @param fallback - A object that contains fallback font options.
 * @return The font object.
 * @private
 */ function toFont(options, fallback) {
    options = options || {};
    fallback = fallback || defaults.font;
    let size = valueOrDefault(options.size, fallback.size);
    if (typeof size === 'string') {
        size = parseInt(size, 10);
    }
    let style = valueOrDefault(options.style, fallback.style);
    if (style && !('' + style).match(FONT_STYLE)) {
        console.warn('Invalid font style specified: "' + style + '"');
        style = undefined;
    }
    const font = {
        family: valueOrDefault(options.family, fallback.family),
        lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
        size,
        style,
        weight: valueOrDefault(options.weight, fallback.weight),
        string: ''
    };
    font.string = toFontString(font);
    return font;
}
/**
 * Evaluates the given `inputs` sequentially and returns the first defined value.
 * @param inputs - An array of values, falling back to the last value.
 * @param context - If defined and the current value is a function, the value
 * is called with `context` as first argument and the result becomes the new input.
 * @param index - If defined and the current value is an array, the value
 * at `index` become the new input.
 * @param info - object to return information about resolution in
 * @param info.cacheable - Will be set to `false` if option is not cacheable.
 * @since 2.7.0
 */ function resolve(inputs, context, index, info) {
    let cacheable = true;
    let i, ilen, value;
    for(i = 0, ilen = inputs.length; i < ilen; ++i){
        value = inputs[i];
        if (value === undefined) {
            continue;
        }
        if (context !== undefined && typeof value === 'function') {
            value = value(context);
            cacheable = false;
        }
        if (index !== undefined && isArray(value)) {
            value = value[index % value.length];
            cacheable = false;
        }
        if (value !== undefined) {
            if (info && !cacheable) {
                info.cacheable = false;
            }
            return value;
        }
    }
}
/**
 * @param minmax
 * @param grace
 * @param beginAtZero
 * @private
 */ function _addGrace(minmax, grace, beginAtZero) {
    const { min , max  } = minmax;
    const change = toDimension(grace, (max - min) / 2);
    const keepZero = (value, add)=>beginAtZero && value === 0 ? 0 : value + add;
    return {
        min: keepZero(min, -Math.abs(change)),
        max: keepZero(max, change)
    };
}
function createContext(parentContext, context) {
    return Object.assign(Object.create(parentContext), context);
}

/**
 * Creates a Proxy for resolving raw values for options.
 * @param scopes - The option scopes to look for values, in resolution order
 * @param prefixes - The prefixes for values, in resolution order.
 * @param rootScopes - The root option scopes
 * @param fallback - Parent scopes fallback
 * @param getTarget - callback for getting the target for changed values
 * @returns Proxy
 * @private
 */ function _createResolver(scopes, prefixes = [
    ''
], rootScopes, fallback, getTarget = ()=>scopes[0]) {
    const finalRootScopes = rootScopes || scopes;
    if (typeof fallback === 'undefined') {
        fallback = _resolve('_fallback', scopes);
    }
    const cache = {
        [Symbol.toStringTag]: 'Object',
        _cacheable: true,
        _scopes: scopes,
        _rootScopes: finalRootScopes,
        _fallback: fallback,
        _getTarget: getTarget,
        override: (scope)=>_createResolver([
                scope,
                ...scopes
            ], prefixes, finalRootScopes, fallback)
    };
    return new Proxy(cache, {
        /**
     * A trap for the delete operator.
     */ deleteProperty (target, prop) {
            delete target[prop]; // remove from cache
            delete target._keys; // remove cached keys
            delete scopes[0][prop]; // remove from top level scope
            return true;
        },
        /**
     * A trap for getting property values.
     */ get (target, prop) {
            return _cached(target, prop, ()=>_resolveWithPrefixes(prop, prefixes, scopes, target));
        },
        /**
     * A trap for Object.getOwnPropertyDescriptor.
     * Also used by Object.hasOwnProperty.
     */ getOwnPropertyDescriptor (target, prop) {
            return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
        },
        /**
     * A trap for Object.getPrototypeOf.
     */ getPrototypeOf () {
            return Reflect.getPrototypeOf(scopes[0]);
        },
        /**
     * A trap for the in operator.
     */ has (target, prop) {
            return getKeysFromAllScopes(target).includes(prop);
        },
        /**
     * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
     */ ownKeys (target) {
            return getKeysFromAllScopes(target);
        },
        /**
     * A trap for setting property values.
     */ set (target, prop, value) {
            const storage = target._storage || (target._storage = getTarget());
            target[prop] = storage[prop] = value; // set to top level scope + cache
            delete target._keys; // remove cached keys
            return true;
        }
    });
}
/**
 * Returns an Proxy for resolving option values with context.
 * @param proxy - The Proxy returned by `_createResolver`
 * @param context - Context object for scriptable/indexable options
 * @param subProxy - The proxy provided for scriptable options
 * @param descriptorDefaults - Defaults for descriptors
 * @private
 */ function _attachContext(proxy, context, subProxy, descriptorDefaults) {
    const cache = {
        _cacheable: false,
        _proxy: proxy,
        _context: context,
        _subProxy: subProxy,
        _stack: new Set(),
        _descriptors: _descriptors(proxy, descriptorDefaults),
        setContext: (ctx)=>_attachContext(proxy, ctx, subProxy, descriptorDefaults),
        override: (scope)=>_attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
    };
    return new Proxy(cache, {
        /**
     * A trap for the delete operator.
     */ deleteProperty (target, prop) {
            delete target[prop]; // remove from cache
            delete proxy[prop]; // remove from proxy
            return true;
        },
        /**
     * A trap for getting property values.
     */ get (target, prop, receiver) {
            return _cached(target, prop, ()=>_resolveWithContext(target, prop, receiver));
        },
        /**
     * A trap for Object.getOwnPropertyDescriptor.
     * Also used by Object.hasOwnProperty.
     */ getOwnPropertyDescriptor (target, prop) {
            return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {
                enumerable: true,
                configurable: true
            } : undefined : Reflect.getOwnPropertyDescriptor(proxy, prop);
        },
        /**
     * A trap for Object.getPrototypeOf.
     */ getPrototypeOf () {
            return Reflect.getPrototypeOf(proxy);
        },
        /**
     * A trap for the in operator.
     */ has (target, prop) {
            return Reflect.has(proxy, prop);
        },
        /**
     * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
     */ ownKeys () {
            return Reflect.ownKeys(proxy);
        },
        /**
     * A trap for setting property values.
     */ set (target, prop, value) {
            proxy[prop] = value; // set to proxy
            delete target[prop]; // remove from cache
            return true;
        }
    });
}
/**
 * @private
 */ function _descriptors(proxy, defaults = {
    scriptable: true,
    indexable: true
}) {
    const { _scriptable =defaults.scriptable , _indexable =defaults.indexable , _allKeys =defaults.allKeys  } = proxy;
    return {
        allKeys: _allKeys,
        scriptable: _scriptable,
        indexable: _indexable,
        isScriptable: isFunction(_scriptable) ? _scriptable : ()=>_scriptable,
        isIndexable: isFunction(_indexable) ? _indexable : ()=>_indexable
    };
}
const readKey = (prefix, name)=>prefix ? prefix + _capitalize(name) : name;
const needsSubResolver = (prop, value)=>isObject(value) && prop !== 'adapters' && (Object.getPrototypeOf(value) === null || value.constructor === Object);
function _cached(target, prop, resolve) {
    if (Object.prototype.hasOwnProperty.call(target, prop) || prop === 'constructor') {
        return target[prop];
    }
    const value = resolve();
    // cache the resolved value
    target[prop] = value;
    return value;
}
function _resolveWithContext(target, prop, receiver) {
    const { _proxy , _context , _subProxy , _descriptors: descriptors  } = target;
    let value = _proxy[prop]; // resolve from proxy
    // resolve with context
    if (isFunction(value) && descriptors.isScriptable(prop)) {
        value = _resolveScriptable(prop, value, target, receiver);
    }
    if (isArray(value) && value.length) {
        value = _resolveArray(prop, value, target, descriptors.isIndexable);
    }
    if (needsSubResolver(prop, value)) {
        // if the resolved value is an object, create a sub resolver for it
        value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);
    }
    return value;
}
function _resolveScriptable(prop, getValue, target, receiver) {
    const { _proxy , _context , _subProxy , _stack  } = target;
    if (_stack.has(prop)) {
        throw new Error('Recursion detected: ' + Array.from(_stack).join('->') + '->' + prop);
    }
    _stack.add(prop);
    let value = getValue(_context, _subProxy || receiver);
    _stack.delete(prop);
    if (needsSubResolver(prop, value)) {
        // When scriptable option returns an object, create a resolver on that.
        value = createSubResolver(_proxy._scopes, _proxy, prop, value);
    }
    return value;
}
function _resolveArray(prop, value, target, isIndexable) {
    const { _proxy , _context , _subProxy , _descriptors: descriptors  } = target;
    if (typeof _context.index !== 'undefined' && isIndexable(prop)) {
        return value[_context.index % value.length];
    } else if (isObject(value[0])) {
        // Array of objects, return array or resolvers
        const arr = value;
        const scopes = _proxy._scopes.filter((s)=>s !== arr);
        value = [];
        for (const item of arr){
            const resolver = createSubResolver(scopes, _proxy, prop, item);
            value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));
        }
    }
    return value;
}
function resolveFallback(fallback, prop, value) {
    return isFunction(fallback) ? fallback(prop, value) : fallback;
}
const getScope = (key, parent)=>key === true ? parent : typeof key === 'string' ? resolveObjectKey(parent, key) : undefined;
function addScopes(set, parentScopes, key, parentFallback, value) {
    for (const parent of parentScopes){
        const scope = getScope(key, parent);
        if (scope) {
            set.add(scope);
            const fallback = resolveFallback(scope._fallback, key, value);
            if (typeof fallback !== 'undefined' && fallback !== key && fallback !== parentFallback) {
                // When we reach the descriptor that defines a new _fallback, return that.
                // The fallback will resume to that new scope.
                return fallback;
            }
        } else if (scope === false && typeof parentFallback !== 'undefined' && key !== parentFallback) {
            // Fallback to `false` results to `false`, when falling back to different key.
            // For example `interaction` from `hover` or `plugins.tooltip` and `animation` from `animations`
            return null;
        }
    }
    return false;
}
function createSubResolver(parentScopes, resolver, prop, value) {
    const rootScopes = resolver._rootScopes;
    const fallback = resolveFallback(resolver._fallback, prop, value);
    const allScopes = [
        ...parentScopes,
        ...rootScopes
    ];
    const set = new Set();
    set.add(value);
    let key = addScopesFromKey(set, allScopes, prop, fallback || prop, value);
    if (key === null) {
        return false;
    }
    if (typeof fallback !== 'undefined' && fallback !== prop) {
        key = addScopesFromKey(set, allScopes, fallback, key, value);
        if (key === null) {
            return false;
        }
    }
    return _createResolver(Array.from(set), [
        ''
    ], rootScopes, fallback, ()=>subGetTarget(resolver, prop, value));
}
function addScopesFromKey(set, allScopes, key, fallback, item) {
    while(key){
        key = addScopes(set, allScopes, key, fallback, item);
    }
    return key;
}
function subGetTarget(resolver, prop, value) {
    const parent = resolver._getTarget();
    if (!(prop in parent)) {
        parent[prop] = {};
    }
    const target = parent[prop];
    if (isArray(target) && isObject(value)) {
        // For array of objects, the object is used to store updated values
        return value;
    }
    return target || {};
}
function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
    let value;
    for (const prefix of prefixes){
        value = _resolve(readKey(prefix, prop), scopes);
        if (typeof value !== 'undefined') {
            return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
        }
    }
}
function _resolve(key, scopes) {
    for (const scope of scopes){
        if (!scope) {
            continue;
        }
        const value = scope[key];
        if (typeof value !== 'undefined') {
            return value;
        }
    }
}
function getKeysFromAllScopes(target) {
    let keys = target._keys;
    if (!keys) {
        keys = target._keys = resolveKeysFromAllScopes(target._scopes);
    }
    return keys;
}
function resolveKeysFromAllScopes(scopes) {
    const set = new Set();
    for (const scope of scopes){
        for (const key of Object.keys(scope).filter((k)=>!k.startsWith('_'))){
            set.add(key);
        }
    }
    return Array.from(set);
}
function _parseObjectDataRadialScale(meta, data, start, count) {
    const { iScale  } = meta;
    const { key ='r'  } = this._parsing;
    const parsed = new Array(count);
    let i, ilen, index, item;
    for(i = 0, ilen = count; i < ilen; ++i){
        index = i + start;
        item = data[index];
        parsed[i] = {
            r: iScale.parse(resolveObjectKey(item, key), index)
        };
    }
    return parsed;
}

const EPSILON = Number.EPSILON || 1e-14;
const getPoint = (points, i)=>i < points.length && !points[i].skip && points[i];
const getValueAxis = (indexAxis)=>indexAxis === 'x' ? 'y' : 'x';
function splineCurve(firstPoint, middlePoint, afterPoint, t) {
    // Props to Rob Spencer at scaled innovation for his post on splining between points
    // http://scaledinnovation.com/analytics/splines/aboutSplines.html
    // This function must also respect "skipped" points
    const previous = firstPoint.skip ? middlePoint : firstPoint;
    const current = middlePoint;
    const next = afterPoint.skip ? middlePoint : afterPoint;
    const d01 = distanceBetweenPoints(current, previous);
    const d12 = distanceBetweenPoints(next, current);
    let s01 = d01 / (d01 + d12);
    let s12 = d12 / (d01 + d12);
    // If all points are the same, s01 & s02 will be inf
    s01 = isNaN(s01) ? 0 : s01;
    s12 = isNaN(s12) ? 0 : s12;
    const fa = t * s01; // scaling factor for triangle Ta
    const fb = t * s12;
    return {
        previous: {
            x: current.x - fa * (next.x - previous.x),
            y: current.y - fa * (next.y - previous.y)
        },
        next: {
            x: current.x + fb * (next.x - previous.x),
            y: current.y + fb * (next.y - previous.y)
        }
    };
}
/**
 * Adjust tangents to ensure monotonic properties
 */ function monotoneAdjust(points, deltaK, mK) {
    const pointsLen = points.length;
    let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for(let i = 0; i < pointsLen - 1; ++i){
        pointCurrent = pointAfter;
        pointAfter = getPoint(points, i + 1);
        if (!pointCurrent || !pointAfter) {
            continue;
        }
        if (almostEquals(deltaK[i], 0, EPSILON)) {
            mK[i] = mK[i + 1] = 0;
            continue;
        }
        alphaK = mK[i] / deltaK[i];
        betaK = mK[i + 1] / deltaK[i];
        squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
        if (squaredMagnitude <= 9) {
            continue;
        }
        tauK = 3 / Math.sqrt(squaredMagnitude);
        mK[i] = alphaK * tauK * deltaK[i];
        mK[i + 1] = betaK * tauK * deltaK[i];
    }
}
function monotoneCompute(points, mK, indexAxis = 'x') {
    const valueAxis = getValueAxis(indexAxis);
    const pointsLen = points.length;
    let delta, pointBefore, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for(let i = 0; i < pointsLen; ++i){
        pointBefore = pointCurrent;
        pointCurrent = pointAfter;
        pointAfter = getPoint(points, i + 1);
        if (!pointCurrent) {
            continue;
        }
        const iPixel = pointCurrent[indexAxis];
        const vPixel = pointCurrent[valueAxis];
        if (pointBefore) {
            delta = (iPixel - pointBefore[indexAxis]) / 3;
            pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
            pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];
        }
        if (pointAfter) {
            delta = (pointAfter[indexAxis] - iPixel) / 3;
            pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
            pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];
        }
    }
}
/**
 * This function calculates Bézier control points in a similar way than |splineCurve|,
 * but preserves monotonicity of the provided data and ensures no local extremums are added
 * between the dataset discrete points due to the interpolation.
 * See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation
 */ function splineCurveMonotone(points, indexAxis = 'x') {
    const valueAxis = getValueAxis(indexAxis);
    const pointsLen = points.length;
    const deltaK = Array(pointsLen).fill(0);
    const mK = Array(pointsLen);
    // Calculate slopes (deltaK) and initialize tangents (mK)
    let i, pointBefore, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for(i = 0; i < pointsLen; ++i){
        pointBefore = pointCurrent;
        pointCurrent = pointAfter;
        pointAfter = getPoint(points, i + 1);
        if (!pointCurrent) {
            continue;
        }
        if (pointAfter) {
            const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
            // In the case of two points that appear at the same x pixel, slopeDeltaX is 0
            deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
        }
        mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;
    }
    monotoneAdjust(points, deltaK, mK);
    monotoneCompute(points, mK, indexAxis);
}
function capControlPoint(pt, min, max) {
    return Math.max(Math.min(pt, max), min);
}
function capBezierPoints(points, area) {
    let i, ilen, point, inArea, inAreaPrev;
    let inAreaNext = _isPointInArea(points[0], area);
    for(i = 0, ilen = points.length; i < ilen; ++i){
        inAreaPrev = inArea;
        inArea = inAreaNext;
        inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);
        if (!inArea) {
            continue;
        }
        point = points[i];
        if (inAreaPrev) {
            point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
            point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
        }
        if (inAreaNext) {
            point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
            point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
        }
    }
}
/**
 * @private
 */ function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
    let i, ilen, point, controlPoints;
    // Only consider points that are drawn in case the spanGaps option is used
    if (options.spanGaps) {
        points = points.filter((pt)=>!pt.skip);
    }
    if (options.cubicInterpolationMode === 'monotone') {
        splineCurveMonotone(points, indexAxis);
    } else {
        let prev = loop ? points[points.length - 1] : points[0];
        for(i = 0, ilen = points.length; i < ilen; ++i){
            point = points[i];
            controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);
            point.cp1x = controlPoints.previous.x;
            point.cp1y = controlPoints.previous.y;
            point.cp2x = controlPoints.next.x;
            point.cp2y = controlPoints.next.y;
            prev = point;
        }
    }
    if (options.capBezierPoints) {
        capBezierPoints(points, area);
    }
}

/**
 * @private
 */ function _isDomSupported() {
    return typeof window !== 'undefined' && typeof document !== 'undefined';
}
/**
 * @private
 */ function _getParentNode(domNode) {
    let parent = domNode.parentNode;
    if (parent && parent.toString() === '[object ShadowRoot]') {
        parent = parent.host;
    }
    return parent;
}
/**
 * convert max-width/max-height values that may be percentages into a number
 * @private
 */ function parseMaxStyle(styleValue, node, parentProperty) {
    let valueInPixels;
    if (typeof styleValue === 'string') {
        valueInPixels = parseInt(styleValue, 10);
        if (styleValue.indexOf('%') !== -1) {
            // percentage * size in dimension
            valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
        }
    } else {
        valueInPixels = styleValue;
    }
    return valueInPixels;
}
const getComputedStyle = (element)=>element.ownerDocument.defaultView.getComputedStyle(element, null);
function getStyle(el, property) {
    return getComputedStyle(el).getPropertyValue(property);
}
const positions = [
    'top',
    'right',
    'bottom',
    'left'
];
function getPositionedStyle(styles, style, suffix) {
    const result = {};
    suffix = suffix ? '-' + suffix : '';
    for(let i = 0; i < 4; i++){
        const pos = positions[i];
        result[pos] = parseFloat(styles[style + '-' + pos + suffix]) || 0;
    }
    result.width = result.left + result.right;
    result.height = result.top + result.bottom;
    return result;
}
const useOffsetPos = (x, y, target)=>(x > 0 || y > 0) && (!target || !target.shadowRoot);
/**
 * @param e
 * @param canvas
 * @returns Canvas position
 */ function getCanvasPosition(e, canvas) {
    const touches = e.touches;
    const source = touches && touches.length ? touches[0] : e;
    const { offsetX , offsetY  } = source;
    let box = false;
    let x, y;
    if (useOffsetPos(offsetX, offsetY, e.target)) {
        x = offsetX;
        y = offsetY;
    } else {
        const rect = canvas.getBoundingClientRect();
        x = source.clientX - rect.left;
        y = source.clientY - rect.top;
        box = true;
    }
    return {
        x,
        y,
        box
    };
}
/**
 * Gets an event's x, y coordinates, relative to the chart area
 * @param event
 * @param chart
 * @returns x and y coordinates of the event
 */ function getRelativePosition(event, chart) {
    if ('native' in event) {
        return event;
    }
    const { canvas , currentDevicePixelRatio  } = chart;
    const style = getComputedStyle(canvas);
    const borderBox = style.boxSizing === 'border-box';
    const paddings = getPositionedStyle(style, 'padding');
    const borders = getPositionedStyle(style, 'border', 'width');
    const { x , y , box  } = getCanvasPosition(event, canvas);
    const xOffset = paddings.left + (box && borders.left);
    const yOffset = paddings.top + (box && borders.top);
    let { width , height  } = chart;
    if (borderBox) {
        width -= paddings.width + borders.width;
        height -= paddings.height + borders.height;
    }
    return {
        x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
        y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
    };
}
function getContainerSize(canvas, width, height) {
    let maxWidth, maxHeight;
    if (width === undefined || height === undefined) {
        const container = canvas && _getParentNode(canvas);
        if (!container) {
            width = canvas.clientWidth;
            height = canvas.clientHeight;
        } else {
            const rect = container.getBoundingClientRect(); // this is the border box of the container
            const containerStyle = getComputedStyle(container);
            const containerBorder = getPositionedStyle(containerStyle, 'border', 'width');
            const containerPadding = getPositionedStyle(containerStyle, 'padding');
            width = rect.width - containerPadding.width - containerBorder.width;
            height = rect.height - containerPadding.height - containerBorder.height;
            maxWidth = parseMaxStyle(containerStyle.maxWidth, container, 'clientWidth');
            maxHeight = parseMaxStyle(containerStyle.maxHeight, container, 'clientHeight');
        }
    }
    return {
        width,
        height,
        maxWidth: maxWidth || INFINITY,
        maxHeight: maxHeight || INFINITY
    };
}
const round1 = (v)=>Math.round(v * 10) / 10;
// eslint-disable-next-line complexity
function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
    const style = getComputedStyle(canvas);
    const margins = getPositionedStyle(style, 'margin');
    const maxWidth = parseMaxStyle(style.maxWidth, canvas, 'clientWidth') || INFINITY;
    const maxHeight = parseMaxStyle(style.maxHeight, canvas, 'clientHeight') || INFINITY;
    const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
    let { width , height  } = containerSize;
    if (style.boxSizing === 'content-box') {
        const borders = getPositionedStyle(style, 'border', 'width');
        const paddings = getPositionedStyle(style, 'padding');
        width -= paddings.width + borders.width;
        height -= paddings.height + borders.height;
    }
    width = Math.max(0, width - margins.width);
    height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);
    width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
    height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
    if (width && !height) {
        // https://github.com/chartjs/Chart.js/issues/4659
        // If the canvas has width, but no height, default to aspectRatio of 2 (canvas default)
        height = round1(width / 2);
    }
    const maintainHeight = bbWidth !== undefined || bbHeight !== undefined;
    if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {
        height = containerSize.height;
        width = round1(Math.floor(height * aspectRatio));
    }
    return {
        width,
        height
    };
}
/**
 * @param chart
 * @param forceRatio
 * @param forceStyle
 * @returns True if the canvas context size or transformation has changed.
 */ function retinaScale(chart, forceRatio, forceStyle) {
    const pixelRatio = forceRatio || 1;
    const deviceHeight = Math.floor(chart.height * pixelRatio);
    const deviceWidth = Math.floor(chart.width * pixelRatio);
    chart.height = Math.floor(chart.height);
    chart.width = Math.floor(chart.width);
    const canvas = chart.canvas;
    // If no style has been set on the canvas, the render size is used as display size,
    // making the chart visually bigger, so let's enforce it to the "correct" values.
    // See https://github.com/chartjs/Chart.js/issues/3575
    if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
        canvas.style.height = `${chart.height}px`;
        canvas.style.width = `${chart.width}px`;
    }
    if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
        chart.currentDevicePixelRatio = pixelRatio;
        canvas.height = deviceHeight;
        canvas.width = deviceWidth;
        chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
        return true;
    }
    return false;
}
/**
 * Detects support for options object argument in addEventListener.
 * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support
 * @private
 */ const supportsEventListenerOptions = function() {
    let passiveSupported = false;
    try {
        const options = {
            get passive () {
                passiveSupported = true;
                return false;
            }
        };
        if (_isDomSupported()) {
            window.addEventListener('test', null, options);
            window.removeEventListener('test', null, options);
        }
    } catch (e) {
    // continue regardless of error
    }
    return passiveSupported;
}();
/**
 * The "used" size is the final value of a dimension property after all calculations have
 * been performed. This method uses the computed style of `element` but returns undefined
 * if the computed style is not expressed in pixels. That can happen in some cases where
 * `element` has a size relative to its parent and this last one is not yet displayed,
 * for example because of `display: none` on a parent node.
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value
 * @returns Size in pixels or undefined if unknown.
 */ function readUsedSize(element, property) {
    const value = getStyle(element, property);
    const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
    return matches ? +matches[1] : undefined;
}

/**
 * @private
 */ function _pointInLine(p1, p2, t, mode) {
    return {
        x: p1.x + t * (p2.x - p1.x),
        y: p1.y + t * (p2.y - p1.y)
    };
}
/**
 * @private
 */ function _steppedInterpolation(p1, p2, t, mode) {
    return {
        x: p1.x + t * (p2.x - p1.x),
        y: mode === 'middle' ? t < 0.5 ? p1.y : p2.y : mode === 'after' ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y
    };
}
/**
 * @private
 */ function _bezierInterpolation(p1, p2, t, mode) {
    const cp1 = {
        x: p1.cp2x,
        y: p1.cp2y
    };
    const cp2 = {
        x: p2.cp1x,
        y: p2.cp1y
    };
    const a = _pointInLine(p1, cp1, t);
    const b = _pointInLine(cp1, cp2, t);
    const c = _pointInLine(cp2, p2, t);
    const d = _pointInLine(a, b, t);
    const e = _pointInLine(b, c, t);
    return _pointInLine(d, e, t);
}

const getRightToLeftAdapter = function(rectX, width) {
    return {
        x (x) {
            return rectX + rectX + width - x;
        },
        setWidth (w) {
            width = w;
        },
        textAlign (align) {
            if (align === 'center') {
                return align;
            }
            return align === 'right' ? 'left' : 'right';
        },
        xPlus (x, value) {
            return x - value;
        },
        leftForLtr (x, itemWidth) {
            return x - itemWidth;
        }
    };
};
const getLeftToRightAdapter = function() {
    return {
        x (x) {
            return x;
        },
        setWidth (w) {},
        textAlign (align) {
            return align;
        },
        xPlus (x, value) {
            return x + value;
        },
        leftForLtr (x, _itemWidth) {
            return x;
        }
    };
};
function getRtlAdapter(rtl, rectX, width) {
    return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
}
function overrideTextDirection(ctx, direction) {
    let style, original;
    if (direction === 'ltr' || direction === 'rtl') {
        style = ctx.canvas.style;
        original = [
            style.getPropertyValue('direction'),
            style.getPropertyPriority('direction')
        ];
        style.setProperty('direction', direction, 'important');
        ctx.prevTextDirection = original;
    }
}
function restoreTextDirection(ctx, original) {
    if (original !== undefined) {
        delete ctx.prevTextDirection;
        ctx.canvas.style.setProperty('direction', original[0], original[1]);
    }
}

function propertyFn(property) {
    if (property === 'angle') {
        return {
            between: _angleBetween,
            compare: _angleDiff,
            normalize: _normalizeAngle
        };
    }
    return {
        between: _isBetween,
        compare: (a, b)=>a - b,
        normalize: (x)=>x
    };
}
function normalizeSegment({ start , end , count , loop , style  }) {
    return {
        start: start % count,
        end: end % count,
        loop: loop && (end - start + 1) % count === 0,
        style
    };
}
function getSegment(segment, points, bounds) {
    const { property , start: startBound , end: endBound  } = bounds;
    const { between , normalize  } = propertyFn(property);
    const count = points.length;
    let { start , end , loop  } = segment;
    let i, ilen;
    if (loop) {
        start += count;
        end += count;
        for(i = 0, ilen = count; i < ilen; ++i){
            if (!between(normalize(points[start % count][property]), startBound, endBound)) {
                break;
            }
            start--;
            end--;
        }
        start %= count;
        end %= count;
    }
    if (end < start) {
        end += count;
    }
    return {
        start,
        end,
        loop,
        style: segment.style
    };
}
 function _boundSegment(segment, points, bounds) {
    if (!bounds) {
        return [
            segment
        ];
    }
    const { property , start: startBound , end: endBound  } = bounds;
    const count = points.length;
    const { compare , between , normalize  } = propertyFn(property);
    const { start , end , loop , style  } = getSegment(segment, points, bounds);
    const result = [];
    let inside = false;
    let subStart = null;
    let value, point, prevValue;
    const startIsBefore = ()=>between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
    const endIsBefore = ()=>compare(endBound, value) === 0 || between(endBound, prevValue, value);
    const shouldStart = ()=>inside || startIsBefore();
    const shouldStop = ()=>!inside || endIsBefore();
    for(let i = start, prev = start; i <= end; ++i){
        point = points[i % count];
        if (point.skip) {
            continue;
        }
        value = normalize(point[property]);
        if (value === prevValue) {
            continue;
        }
        inside = between(value, startBound, endBound);
        if (subStart === null && shouldStart()) {
            subStart = compare(value, startBound) === 0 ? i : prev;
        }
        if (subStart !== null && shouldStop()) {
            result.push(normalizeSegment({
                start: subStart,
                end: i,
                loop,
                count,
                style
            }));
            subStart = null;
        }
        prev = i;
        prevValue = value;
    }
    if (subStart !== null) {
        result.push(normalizeSegment({
            start: subStart,
            end,
            loop,
            count,
            style
        }));
    }
    return result;
}
 function _boundSegments(line, bounds) {
    const result = [];
    const segments = line.segments;
    for(let i = 0; i < segments.length; i++){
        const sub = _boundSegment(segments[i], line.points, bounds);
        if (sub.length) {
            result.push(...sub);
        }
    }
    return result;
}
 function findStartAndEnd(points, count, loop, spanGaps) {
    let start = 0;
    let end = count - 1;
    if (loop && !spanGaps) {
        while(start < count && !points[start].skip){
            start++;
        }
    }
    while(start < count && points[start].skip){
        start++;
    }
    start %= count;
    if (loop) {
        end += start;
    }
    while(end > start && points[end % count].skip){
        end--;
    }
    end %= count;
    return {
        start,
        end
    };
}
 function solidSegments(points, start, max, loop) {
    const count = points.length;
    const result = [];
    let last = start;
    let prev = points[start];
    let end;
    for(end = start + 1; end <= max; ++end){
        const cur = points[end % count];
        if (cur.skip || cur.stop) {
            if (!prev.skip) {
                loop = false;
                result.push({
                    start: start % count,
                    end: (end - 1) % count,
                    loop
                });
                start = last = cur.stop ? end : null;
            }
        } else {
            last = end;
            if (prev.skip) {
                start = end;
            }
        }
        prev = cur;
    }
    if (last !== null) {
        result.push({
            start: start % count,
            end: last % count,
            loop
        });
    }
    return result;
}
 function _computeSegments(line, segmentOptions) {
    const points = line.points;
    const spanGaps = line.options.spanGaps;
    const count = points.length;
    if (!count) {
        return [];
    }
    const loop = !!line._loop;
    const { start , end  } = findStartAndEnd(points, count, loop, spanGaps);
    if (spanGaps === true) {
        return splitByStyles(line, [
            {
                start,
                end,
                loop
            }
        ], points, segmentOptions);
    }
    const max = end < start ? end + count : end;
    const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;
    return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);
}
 function splitByStyles(line, segments, points, segmentOptions) {
    if (!segmentOptions || !segmentOptions.setContext || !points) {
        return segments;
    }
    return doSplitByStyles(line, segments, points, segmentOptions);
}
 function doSplitByStyles(line, segments, points, segmentOptions) {
    const chartContext = line._chart.getContext();
    const baseStyle = readStyle(line.options);
    const { _datasetIndex: datasetIndex , options: { spanGaps  }  } = line;
    const count = points.length;
    const result = [];
    let prevStyle = baseStyle;
    let start = segments[0].start;
    let i = start;
    function addStyle(s, e, l, st) {
        const dir = spanGaps ? -1 : 1;
        if (s === e) {
            return;
        }
        s += count;
        while(points[s % count].skip){
            s -= dir;
        }
        while(points[e % count].skip){
            e += dir;
        }
        if (s % count !== e % count) {
            result.push({
                start: s % count,
                end: e % count,
                loop: l,
                style: st
            });
            prevStyle = st;
            start = e % count;
        }
    }
    for (const segment of segments){
        start = spanGaps ? start : segment.start;
        let prev = points[start % count];
        let style;
        for(i = start + 1; i <= segment.end; i++){
            const pt = points[i % count];
            style = readStyle(segmentOptions.setContext(createContext(chartContext, {
                type: 'segment',
                p0: prev,
                p1: pt,
                p0DataIndex: (i - 1) % count,
                p1DataIndex: i % count,
                datasetIndex
            })));
            if (styleChanged(style, prevStyle)) {
                addStyle(start, i - 1, segment.loop, prevStyle);
            }
            prev = pt;
            prevStyle = style;
        }
        if (start < i - 1) {
            addStyle(start, i - 1, segment.loop, prevStyle);
        }
    }
    return result;
}
function readStyle(options) {
    return {
        backgroundColor: options.backgroundColor,
        borderCapStyle: options.borderCapStyle,
        borderDash: options.borderDash,
        borderDashOffset: options.borderDashOffset,
        borderJoinStyle: options.borderJoinStyle,
        borderWidth: options.borderWidth,
        borderColor: options.borderColor
    };
}
function styleChanged(style, prevStyle) {
    if (!prevStyle) {
        return false;
    }
    const cache = [];
    const replacer = function(key, value) {
        if (!isPatternOrGradient(value)) {
            return value;
        }
        if (!cache.includes(value)) {
            cache.push(value);
        }
        return cache.indexOf(value);
    };
    return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);
}

function getSizeForArea(scale, chartArea, field) {
    return scale.options.clip ? scale[field] : chartArea[field];
}
function getDatasetArea(meta, chartArea) {
    const { xScale , yScale  } = meta;
    if (xScale && yScale) {
        return {
            left: getSizeForArea(xScale, chartArea, 'left'),
            right: getSizeForArea(xScale, chartArea, 'right'),
            top: getSizeForArea(yScale, chartArea, 'top'),
            bottom: getSizeForArea(yScale, chartArea, 'bottom')
        };
    }
    return chartArea;
}
function getDatasetClipArea(chart, meta) {
    const clip = meta._clip;
    if (clip.disabled) {
        return false;
    }
    const area = getDatasetArea(meta, chart.chartArea);
    return {
        left: clip.left === false ? 0 : area.left - (clip.left === true ? 0 : clip.left),
        right: clip.right === false ? chart.width : area.right + (clip.right === true ? 0 : clip.right),
        top: clip.top === false ? 0 : area.top - (clip.top === true ? 0 : clip.top),
        bottom: clip.bottom === false ? chart.height : area.bottom + (clip.bottom === true ? 0 : clip.bottom)
    };
}

exports.HALF_PI = HALF_PI;
exports.INFINITY = INFINITY;
exports.PI = PI;
exports.PITAU = PITAU;
exports.QUARTER_PI = QUARTER_PI;
exports.RAD_PER_DEG = RAD_PER_DEG;
exports.TAU = TAU;
exports.TWO_THIRDS_PI = TWO_THIRDS_PI;
exports.Ticks = Ticks;
exports._addGrace = _addGrace;
exports._alignPixel = _alignPixel;
exports._alignStartEnd = _alignStartEnd;
exports._angleBetween = _angleBetween;
exports._angleDiff = _angleDiff;
exports._arrayUnique = _arrayUnique;
exports._attachContext = _attachContext;
exports._bezierCurveTo = _bezierCurveTo;
exports._bezierInterpolation = _bezierInterpolation;
exports._boundSegment = _boundSegment;
exports._boundSegments = _boundSegments;
exports._capitalize = _capitalize;
exports._computeSegments = _computeSegments;
exports._createResolver = _createResolver;
exports._decimalPlaces = _decimalPlaces;
exports._deprecated = _deprecated;
exports._descriptors = _descriptors;
exports._elementsEqual = _elementsEqual;
exports._factorize = _factorize;
exports._filterBetween = _filterBetween;
exports._getParentNode = _getParentNode;
exports._getStartAndCountOfVisiblePoints = _getStartAndCountOfVisiblePoints;
exports._int16Range = _int16Range;
exports._isBetween = _isBetween;
exports._isClickEvent = _isClickEvent;
exports._isDomSupported = _isDomSupported;
exports._isPointInArea = _isPointInArea;
exports._limitValue = _limitValue;
exports._longestText = _longestText;
exports._lookup = _lookup;
exports._lookupByKey = _lookupByKey;
exports._measureText = _measureText;
exports._merger = _merger;
exports._mergerIf = _mergerIf;
exports._normalizeAngle = _normalizeAngle;
exports._parseObjectDataRadialScale = _parseObjectDataRadialScale;
exports._pointInLine = _pointInLine;
exports._readValueToProps = _readValueToProps;
exports._rlookupByKey = _rlookupByKey;
exports._scaleRangesChanged = _scaleRangesChanged;
exports._setMinAndMaxByKey = _setMinAndMaxByKey;
exports._splitKey = _splitKey;
exports._steppedInterpolation = _steppedInterpolation;
exports._steppedLineTo = _steppedLineTo;
exports._textX = _textX;
exports._toLeftRightCenter = _toLeftRightCenter;
exports._updateBezierControlPoints = _updateBezierControlPoints;
exports.addRoundedRectPath = addRoundedRectPath;
exports.almostEquals = almostEquals;
exports.almostWhole = almostWhole;
exports.callback = callback;
exports.clearCanvas = clearCanvas;
exports.clipArea = clipArea;
exports.clone = clone;
exports.color = color;
exports.createContext = createContext;
exports.debounce = debounce;
exports.defaults = defaults;
exports.defined = defined;
exports.descriptors = descriptors;
exports.distanceBetweenPoints = distanceBetweenPoints;
exports.drawPoint = drawPoint;
exports.drawPointLegend = drawPointLegend;
exports.each = each;
exports.effects = effects;
exports.finiteOrDefault = finiteOrDefault;
exports.fontString = fontString;
exports.formatNumber = formatNumber;
exports.getAngleFromPoint = getAngleFromPoint;
exports.getDatasetClipArea = getDatasetClipArea;
exports.getHoverColor = getHoverColor;
exports.getMaximumSize = getMaximumSize;
exports.getRelativePosition = getRelativePosition;
exports.getRtlAdapter = getRtlAdapter;
exports.getStyle = getStyle;
exports.isArray = isArray;
exports.isFunction = isFunction;
exports.isNullOrUndef = isNullOrUndef;
exports.isNumber = isNumber;
exports.isNumberFinite = isNumberFinite;
exports.isObject = isObject;
exports.isPatternOrGradient = isPatternOrGradient;
exports.listenArrayEvents = listenArrayEvents;
exports.log10 = log10;
exports.merge = merge;
exports.mergeIf = mergeIf;
exports.niceNum = niceNum;
exports.noop = noop;
exports.overrideTextDirection = overrideTextDirection;
exports.overrides = overrides;
exports.readUsedSize = readUsedSize;
exports.renderText = renderText;
exports.requestAnimFrame = requestAnimFrame;
exports.resolve = resolve;
exports.resolveObjectKey = resolveObjectKey;
exports.restoreTextDirection = restoreTextDirection;
exports.retinaScale = retinaScale;
exports.setsEqual = setsEqual;
exports.sign = sign;
exports.splineCurve = splineCurve;
exports.splineCurveMonotone = splineCurveMonotone;
exports.supportsEventListenerOptions = supportsEventListenerOptions;
exports.throttled = throttled;
exports.toDegrees = toDegrees;
exports.toDimension = toDimension;
exports.toFont = toFont;
exports.toFontString = toFontString;
exports.toLineHeight = toLineHeight;
exports.toPadding = toPadding;
exports.toPercentage = toPercentage;
exports.toRadians = toRadians;
exports.toTRBL = toTRBL;
exports.toTRBLCorners = toTRBLCorners;
exports.uid = uid;
exports.unclipArea = unclipArea;
exports.unlistenArrayEvents = unlistenArrayEvents;
exports.valueOrDefault = valueOrDefault;
//# sourceMappingURL=helpers.dataset.cjs.map


/***/ }),

/***/ "./node_modules/chroma-js/dist/chroma.cjs":
/*!************************************************!*\
  !*** ./node_modules/chroma-js/dist/chroma.cjs ***!
  \************************************************/
/***/ (function(module) {

/**
 * chroma.js - JavaScript library for color conversions
 *
 * Copyright (c) 2011-2024, Gregor Aisch
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. The name Gregor Aisch may not be used to endorse or promote products
 * derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * -------------------------------------------------------
 *
 * chroma.js includes colors from colorbrewer2.org, which are released under
 * the following license:
 *
 * Copyright (c) 2002 Cynthia Brewer, Mark Harrower,
 * and The Pennsylvania State University.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied. See the License for the specific
 * language governing permissions and limitations under the License.
 *
 * ------------------------------------------------------
 *
 * Named colors are taken from X11 Color Names.
 * http://www.w3.org/TR/css3-color/#svg-color
 *
 * @preserve
 */

(function (global, factory) {
     true ? module.exports = factory() :
    0;
})(this, (function () { 'use strict';

    function limit (x, low, high) {
        if ( low === void 0 ) low = 0;
        if ( high === void 0 ) high = 1;

        return min$3(max$3(low, x), high);
    }

    function clip_rgb (rgb) {
        rgb._clipped = false;
        rgb._unclipped = rgb.slice(0);
        for (var i = 0; i <= 3; i++) {
            if (i < 3) {
                if (rgb[i] < 0 || rgb[i] > 255) { rgb._clipped = true; }
                rgb[i] = limit(rgb[i], 0, 255);
            } else if (i === 3) {
                rgb[i] = limit(rgb[i], 0, 1);
            }
        }
        return rgb;
    }

    // ported from jQuery's $.type
    var classToType = {};
    for (var i$1 = 0, list$1 = [
        'Boolean',
        'Number',
        'String',
        'Function',
        'Array',
        'Date',
        'RegExp',
        'Undefined',
        'Null'
    ]; i$1 < list$1.length; i$1 += 1) {
        var name = list$1[i$1];

        classToType[("[object " + name + "]")] = name.toLowerCase();
    }
    function type (obj) {
        return classToType[Object.prototype.toString.call(obj)] || 'object';
    }

    function unpack (args, keyOrder) {
        if ( keyOrder === void 0 ) keyOrder = null;

        // if called with more than 3 arguments, we return the arguments
        if (args.length >= 3) { return Array.prototype.slice.call(args); }
        // with less than 3 args we check if first arg is object
        // and use the keyOrder string to extract and sort properties
        if (type(args[0]) == 'object' && keyOrder) {
            return keyOrder
                .split('')
                .filter(function (k) { return args[0][k] !== undefined; })
                .map(function (k) { return args[0][k]; });
        }
        // otherwise we just return the first argument
        // (which we suppose is an array of args)
        return args[0];
    }

    function last (args) {
        if (args.length < 2) { return null; }
        var l = args.length - 1;
        if (type(args[l]) == 'string') { return args[l].toLowerCase(); }
        return null;
    }

    var PI$2 = Math.PI;
    var min$3 = Math.min;
    var max$3 = Math.max;

    var TWOPI = PI$2 * 2;
    var PITHIRD = PI$2 / 3;
    var DEG2RAD = PI$2 / 180;
    var RAD2DEG = 180 / PI$2;

    var input = {
        format: {},
        autodetect: []
    };

    var Color = function Color() {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var me = this;
        if (
            type(args[0]) === 'object' &&
            args[0].constructor &&
            args[0].constructor === this.constructor
        ) {
            // the argument is already a Color instance
            return args[0];
        }
        // last argument could be the mode
        var mode = last(args);
        var autodetect = false;
        if (!mode) {
            autodetect = true;
            if (!input.sorted) {
                input.autodetect = input.autodetect.sort(function (a, b) { return b.p - a.p; });
                input.sorted = true;
            }
            // auto-detect format
            for (var i = 0, list = input.autodetect; i < list.length; i += 1) {
                var chk = list[i];

                mode = chk.test.apply(chk, args);
                if (mode) { break; }
            }
        }
        if (input.format[mode]) {
            var rgb = input.format[mode].apply(
                null,
                autodetect ? args : args.slice(0, -1)
            );
            me._rgb = clip_rgb(rgb);
        } else {
            throw new Error('unknown format: ' + args);
        }
        // add alpha channel
        if (me._rgb.length === 3) { me._rgb.push(1); }
    };
    Color.prototype.toString = function toString () {
        if (type(this.hex) == 'function') { return this.hex(); }
        return ("[" + (this._rgb.join(',')) + "]");
    };

    // this gets updated automatically
    var version = '2.6.0';

    var chroma = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( chroma.Color, [ null ].concat( args) ));
    };

    chroma.Color = Color;
    chroma.version = version;

    var cmyk2rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        args = unpack(args, 'cmyk');
        var c = args[0];
        var m = args[1];
        var y = args[2];
        var k = args[3];
        var alpha = args.length > 4 ? args[4] : 1;
        if (k === 1) { return [0, 0, 0, alpha]; }
        return [
            c >= 1 ? 0 : 255 * (1 - c) * (1 - k), // r
            m >= 1 ? 0 : 255 * (1 - m) * (1 - k), // g
            y >= 1 ? 0 : 255 * (1 - y) * (1 - k), // b
            alpha
        ];
    };

    var max$2 = Math.max;

    var rgb2cmyk = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        r = r / 255;
        g = g / 255;
        b = b / 255;
        var k = 1 - max$2(r, max$2(g, b));
        var f = k < 1 ? 1 / (1 - k) : 0;
        var c = (1 - r - k) * f;
        var m = (1 - g - k) * f;
        var y = (1 - b - k) * f;
        return [c, m, y, k];
    };

    Color.prototype.cmyk = function () {
        return rgb2cmyk(this._rgb);
    };

    chroma.cmyk = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color, [ null ].concat( args, ['cmyk']) ));
    };

    input.format.cmyk = cmyk2rgb;

    input.autodetect.push({
        p: 2,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack(args, 'cmyk');
            if (type(args) === 'array' && args.length === 4) {
                return 'cmyk';
            }
        }
    });

    var rnd = function (a) { return Math.round(a * 100) / 100; };

    /*
     * supported arguments:
     * - hsl2css(h,s,l)
     * - hsl2css(h,s,l,a)
     * - hsl2css([h,s,l], mode)
     * - hsl2css([h,s,l,a], mode)
     * - hsl2css({h,s,l,a}, mode)
     */
    var hsl2css = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var hsla = unpack(args, 'hsla');
        var mode = last(args) || 'lsa';
        hsla[0] = rnd(hsla[0] || 0);
        hsla[1] = rnd(hsla[1] * 100) + '%';
        hsla[2] = rnd(hsla[2] * 100) + '%';
        if (mode === 'hsla' || (hsla.length > 3 && hsla[3] < 1)) {
            hsla[3] = hsla.length > 3 ? hsla[3] : 1;
            mode = 'hsla';
        } else {
            hsla.length = 3;
        }
        return (mode + "(" + (hsla.join(',')) + ")");
    };

    /*
     * supported arguments:
     * - rgb2hsl(r,g,b)
     * - rgb2hsl(r,g,b,a)
     * - rgb2hsl([r,g,b])
     * - rgb2hsl([r,g,b,a])
     * - rgb2hsl({r,g,b,a})
     */
    var rgb2hsl$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        args = unpack(args, 'rgba');
        var r = args[0];
        var g = args[1];
        var b = args[2];

        r /= 255;
        g /= 255;
        b /= 255;

        var minRgb = min$3(r, g, b);
        var maxRgb = max$3(r, g, b);

        var l = (maxRgb + minRgb) / 2;
        var s, h;

        if (maxRgb === minRgb) {
            s = 0;
            h = Number.NaN;
        } else {
            s =
                l < 0.5
                    ? (maxRgb - minRgb) / (maxRgb + minRgb)
                    : (maxRgb - minRgb) / (2 - maxRgb - minRgb);
        }

        if (r == maxRgb) { h = (g - b) / (maxRgb - minRgb); }
        else if (g == maxRgb) { h = 2 + (b - r) / (maxRgb - minRgb); }
        else if (b == maxRgb) { h = 4 + (r - g) / (maxRgb - minRgb); }

        h *= 60;
        if (h < 0) { h += 360; }
        if (args.length > 3 && args[3] !== undefined) { return [h, s, l, args[3]]; }
        return [h, s, l];
    };

    var round$6 = Math.round;

    /*
     * supported arguments:
     * - rgb2css(r,g,b)
     * - rgb2css(r,g,b,a)
     * - rgb2css([r,g,b], mode)
     * - rgb2css([r,g,b,a], mode)
     * - rgb2css({r,g,b,a}, mode)
     */
    var rgb2css = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var rgba = unpack(args, 'rgba');
        var mode = last(args) || 'rgb';
        if (mode.substr(0, 3) == 'hsl') {
            return hsl2css(rgb2hsl$1(rgba), mode);
        }
        rgba[0] = round$6(rgba[0]);
        rgba[1] = round$6(rgba[1]);
        rgba[2] = round$6(rgba[2]);
        if (mode === 'rgba' || (rgba.length > 3 && rgba[3] < 1)) {
            rgba[3] = rgba.length > 3 ? rgba[3] : 1;
            mode = 'rgba';
        }
        return (mode + "(" + (rgba.slice(0, mode === 'rgb' ? 3 : 4).join(',')) + ")");
    };

    var round$5 = Math.round;

    var hsl2rgb = function () {
        var assign;

        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];
        args = unpack(args, 'hsl');
        var h = args[0];
        var s = args[1];
        var l = args[2];
        var r, g, b;
        if (s === 0) {
            r = g = b = l * 255;
        } else {
            var t3 = [0, 0, 0];
            var c = [0, 0, 0];
            var t2 = l < 0.5 ? l * (1 + s) : l + s - l * s;
            var t1 = 2 * l - t2;
            var h_ = h / 360;
            t3[0] = h_ + 1 / 3;
            t3[1] = h_;
            t3[2] = h_ - 1 / 3;
            for (var i = 0; i < 3; i++) {
                if (t3[i] < 0) { t3[i] += 1; }
                if (t3[i] > 1) { t3[i] -= 1; }
                if (6 * t3[i] < 1) { c[i] = t1 + (t2 - t1) * 6 * t3[i]; }
                else if (2 * t3[i] < 1) { c[i] = t2; }
                else if (3 * t3[i] < 2) { c[i] = t1 + (t2 - t1) * (2 / 3 - t3[i]) * 6; }
                else { c[i] = t1; }
            }
            (assign = [round$5(c[0] * 255), round$5(c[1] * 255), round$5(c[2] * 255)], r = assign[0], g = assign[1], b = assign[2]);
        }
        if (args.length > 3) {
            // keep alpha channel
            return [r, g, b, args[3]];
        }
        return [r, g, b, 1];
    };

    var RE_RGB = /^rgb\(\s*(-?\d+),\s*(-?\d+)\s*,\s*(-?\d+)\s*\)$/;
    var RE_RGBA =
        /^rgba\(\s*(-?\d+),\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*([01]|[01]?\.\d+)\)$/;
    var RE_RGB_PCT =
        /^rgb\(\s*(-?\d+(?:\.\d+)?)%,\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*\)$/;
    var RE_RGBA_PCT =
        /^rgba\(\s*(-?\d+(?:\.\d+)?)%,\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/;
    var RE_HSL =
        /^hsl\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*\)$/;
    var RE_HSLA =
        /^hsla\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/;

    var round$4 = Math.round;

    var css2rgb = function (css) {
        css = css.toLowerCase().trim();
        var m;

        if (input.format.named) {
            try {
                return input.format.named(css);
                // eslint-disable-next-line
            } catch (e) {}
        }

        // rgb(250,20,0)
        if ((m = css.match(RE_RGB))) {
            var rgb = m.slice(1, 4);
            for (var i = 0; i < 3; i++) {
                rgb[i] = +rgb[i];
            }
            rgb[3] = 1; // default alpha
            return rgb;
        }

        // rgba(250,20,0,0.4)
        if ((m = css.match(RE_RGBA))) {
            var rgb$1 = m.slice(1, 5);
            for (var i$1 = 0; i$1 < 4; i$1++) {
                rgb$1[i$1] = +rgb$1[i$1];
            }
            return rgb$1;
        }

        // rgb(100%,0%,0%)
        if ((m = css.match(RE_RGB_PCT))) {
            var rgb$2 = m.slice(1, 4);
            for (var i$2 = 0; i$2 < 3; i$2++) {
                rgb$2[i$2] = round$4(rgb$2[i$2] * 2.55);
            }
            rgb$2[3] = 1; // default alpha
            return rgb$2;
        }

        // rgba(100%,0%,0%,0.4)
        if ((m = css.match(RE_RGBA_PCT))) {
            var rgb$3 = m.slice(1, 5);
            for (var i$3 = 0; i$3 < 3; i$3++) {
                rgb$3[i$3] = round$4(rgb$3[i$3] * 2.55);
            }
            rgb$3[3] = +rgb$3[3];
            return rgb$3;
        }

        // hsl(0,100%,50%)
        if ((m = css.match(RE_HSL))) {
            var hsl = m.slice(1, 4);
            hsl[1] *= 0.01;
            hsl[2] *= 0.01;
            var rgb$4 = hsl2rgb(hsl);
            rgb$4[3] = 1;
            return rgb$4;
        }

        // hsla(0,100%,50%,0.5)
        if ((m = css.match(RE_HSLA))) {
            var hsl$1 = m.slice(1, 4);
            hsl$1[1] *= 0.01;
            hsl$1[2] *= 0.01;
            var rgb$5 = hsl2rgb(hsl$1);
            rgb$5[3] = +m[4]; // default alpha = 1
            return rgb$5;
        }
    };

    css2rgb.test = function (s) {
        return (
            RE_RGB.test(s) ||
            RE_RGBA.test(s) ||
            RE_RGB_PCT.test(s) ||
            RE_RGBA_PCT.test(s) ||
            RE_HSL.test(s) ||
            RE_HSLA.test(s)
        );
    };

    Color.prototype.css = function (mode) {
        return rgb2css(this._rgb, mode);
    };

    chroma.css = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color, [ null ].concat( args, ['css']) ));
    };

    input.format.css = css2rgb;

    input.autodetect.push({
        p: 5,
        test: function (h) {
            var rest = [], len = arguments.length - 1;
            while ( len-- > 0 ) rest[ len ] = arguments[ len + 1 ];

            if (!rest.length && type(h) === 'string' && css2rgb.test(h)) {
                return 'css';
            }
        }
    });

    input.format.gl = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var rgb = unpack(args, 'rgba');
        rgb[0] *= 255;
        rgb[1] *= 255;
        rgb[2] *= 255;
        return rgb;
    };

    chroma.gl = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color, [ null ].concat( args, ['gl']) ));
    };

    Color.prototype.gl = function () {
        var rgb = this._rgb;
        return [rgb[0] / 255, rgb[1] / 255, rgb[2] / 255, rgb[3]];
    };

    var floor$3 = Math.floor;

    /*
     * this is basically just HSV with some minor tweaks
     *
     * hue.. [0..360]
     * chroma .. [0..1]
     * grayness .. [0..1]
     */

    var hcg2rgb = function () {
        var assign, assign$1, assign$2, assign$3, assign$4, assign$5;

        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];
        args = unpack(args, 'hcg');
        var h = args[0];
        var c = args[1];
        var _g = args[2];
        var r, g, b;
        _g = _g * 255;
        var _c = c * 255;
        if (c === 0) {
            r = g = b = _g;
        } else {
            if (h === 360) { h = 0; }
            if (h > 360) { h -= 360; }
            if (h < 0) { h += 360; }
            h /= 60;
            var i = floor$3(h);
            var f = h - i;
            var p = _g * (1 - c);
            var q = p + _c * (1 - f);
            var t = p + _c * f;
            var v = p + _c;
            switch (i) {
                case 0:
                    (assign = [v, t, p], r = assign[0], g = assign[1], b = assign[2]);
                    break;
                case 1:
                    (assign$1 = [q, v, p], r = assign$1[0], g = assign$1[1], b = assign$1[2]);
                    break;
                case 2:
                    (assign$2 = [p, v, t], r = assign$2[0], g = assign$2[1], b = assign$2[2]);
                    break;
                case 3:
                    (assign$3 = [p, q, v], r = assign$3[0], g = assign$3[1], b = assign$3[2]);
                    break;
                case 4:
                    (assign$4 = [t, p, v], r = assign$4[0], g = assign$4[1], b = assign$4[2]);
                    break;
                case 5:
                    (assign$5 = [v, p, q], r = assign$5[0], g = assign$5[1], b = assign$5[2]);
                    break;
            }
        }
        return [r, g, b, args.length > 3 ? args[3] : 1];
    };

    var rgb2hcg = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        var minRgb = min$3(r, g, b);
        var maxRgb = max$3(r, g, b);
        var delta = maxRgb - minRgb;
        var c = (delta * 100) / 255;
        var _g = (minRgb / (255 - delta)) * 100;
        var h;
        if (delta === 0) {
            h = Number.NaN;
        } else {
            if (r === maxRgb) { h = (g - b) / delta; }
            if (g === maxRgb) { h = 2 + (b - r) / delta; }
            if (b === maxRgb) { h = 4 + (r - g) / delta; }
            h *= 60;
            if (h < 0) { h += 360; }
        }
        return [h, c, _g];
    };

    Color.prototype.hcg = function () {
        return rgb2hcg(this._rgb);
    };

    chroma.hcg = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color, [ null ].concat( args, ['hcg']) ));
    };

    input.format.hcg = hcg2rgb;

    input.autodetect.push({
        p: 1,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack(args, 'hcg');
            if (type(args) === 'array' && args.length === 3) {
                return 'hcg';
            }
        }
    });

    var RE_HEX = /^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;
    var RE_HEXA = /^#?([A-Fa-f0-9]{8}|[A-Fa-f0-9]{4})$/;

    var hex2rgb = function (hex) {
        if (hex.match(RE_HEX)) {
            // remove optional leading #
            if (hex.length === 4 || hex.length === 7) {
                hex = hex.substr(1);
            }
            // expand short-notation to full six-digit
            if (hex.length === 3) {
                hex = hex.split('');
                hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
            }
            var u = parseInt(hex, 16);
            var r = u >> 16;
            var g = (u >> 8) & 0xff;
            var b = u & 0xff;
            return [r, g, b, 1];
        }

        // match rgba hex format, eg #FF000077
        if (hex.match(RE_HEXA)) {
            if (hex.length === 5 || hex.length === 9) {
                // remove optional leading #
                hex = hex.substr(1);
            }
            // expand short-notation to full eight-digit
            if (hex.length === 4) {
                hex = hex.split('');
                hex =
                    hex[0] +
                    hex[0] +
                    hex[1] +
                    hex[1] +
                    hex[2] +
                    hex[2] +
                    hex[3] +
                    hex[3];
            }
            var u$1 = parseInt(hex, 16);
            var r$1 = (u$1 >> 24) & 0xff;
            var g$1 = (u$1 >> 16) & 0xff;
            var b$1 = (u$1 >> 8) & 0xff;
            var a = Math.round(((u$1 & 0xff) / 0xff) * 100) / 100;
            return [r$1, g$1, b$1, a];
        }

        // we used to check for css colors here
        // if _input.css? and rgb = _input.css hex
        //     return rgb

        throw new Error(("unknown hex color: " + hex));
    };

    var round$3 = Math.round;

    var rgb2hex = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack(args, 'rgba');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        var a = ref[3];
        var mode = last(args) || 'auto';
        if (a === undefined) { a = 1; }
        if (mode === 'auto') {
            mode = a < 1 ? 'rgba' : 'rgb';
        }
        r = round$3(r);
        g = round$3(g);
        b = round$3(b);
        var u = (r << 16) | (g << 8) | b;
        var str = '000000' + u.toString(16); //#.toUpperCase();
        str = str.substr(str.length - 6);
        var hxa = '0' + round$3(a * 255).toString(16);
        hxa = hxa.substr(hxa.length - 2);
        switch (mode.toLowerCase()) {
            case 'rgba':
                return ("#" + str + hxa);
            case 'argb':
                return ("#" + hxa + str);
            default:
                return ("#" + str);
        }
    };

    Color.prototype.hex = function (mode) {
        return rgb2hex(this._rgb, mode);
    };

    chroma.hex = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color, [ null ].concat( args, ['hex']) ));
    };

    input.format.hex = hex2rgb;
    input.autodetect.push({
        p: 4,
        test: function (h) {
            var rest = [], len = arguments.length - 1;
            while ( len-- > 0 ) rest[ len ] = arguments[ len + 1 ];

            if (
                !rest.length &&
                type(h) === 'string' &&
                [3, 4, 5, 6, 7, 8, 9].indexOf(h.length) >= 0
            ) {
                return 'hex';
            }
        }
    });

    var cos$4 = Math.cos;

    /*
     * hue [0..360]
     * saturation [0..1]
     * intensity [0..1]
     */
    var hsi2rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        /*
        borrowed from here:
        http://hummer.stanford.edu/museinfo/doc/examples/humdrum/keyscape2/hsi2rgb.cpp
        */
        args = unpack(args, 'hsi');
        var h = args[0];
        var s = args[1];
        var i = args[2];
        var r, g, b;

        if (isNaN(h)) { h = 0; }
        if (isNaN(s)) { s = 0; }
        // normalize hue
        if (h > 360) { h -= 360; }
        if (h < 0) { h += 360; }
        h /= 360;
        if (h < 1 / 3) {
            b = (1 - s) / 3;
            r = (1 + (s * cos$4(TWOPI * h)) / cos$4(PITHIRD - TWOPI * h)) / 3;
            g = 1 - (b + r);
        } else if (h < 2 / 3) {
            h -= 1 / 3;
            r = (1 - s) / 3;
            g = (1 + (s * cos$4(TWOPI * h)) / cos$4(PITHIRD - TWOPI * h)) / 3;
            b = 1 - (r + g);
        } else {
            h -= 2 / 3;
            g = (1 - s) / 3;
            b = (1 + (s * cos$4(TWOPI * h)) / cos$4(PITHIRD - TWOPI * h)) / 3;
            r = 1 - (g + b);
        }
        r = limit(i * r * 3);
        g = limit(i * g * 3);
        b = limit(i * b * 3);
        return [r * 255, g * 255, b * 255, args.length > 3 ? args[3] : 1];
    };

    var min$2 = Math.min;
    var sqrt$4 = Math.sqrt;
    var acos = Math.acos;

    var rgb2hsi = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        /*
        borrowed from here:
        http://hummer.stanford.edu/museinfo/doc/examples/humdrum/keyscape2/rgb2hsi.cpp
        */
        var ref = unpack(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        r /= 255;
        g /= 255;
        b /= 255;
        var h;
        var min_ = min$2(r, g, b);
        var i = (r + g + b) / 3;
        var s = i > 0 ? 1 - min_ / i : 0;
        if (s === 0) {
            h = NaN;
        } else {
            h = (r - g + (r - b)) / 2;
            h /= sqrt$4((r - g) * (r - g) + (r - b) * (g - b));
            h = acos(h);
            if (b > g) {
                h = TWOPI - h;
            }
            h /= TWOPI;
        }
        return [h * 360, s, i];
    };

    Color.prototype.hsi = function () {
        return rgb2hsi(this._rgb);
    };

    chroma.hsi = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color, [ null ].concat( args, ['hsi']) ));
    };

    input.format.hsi = hsi2rgb;

    input.autodetect.push({
        p: 2,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack(args, 'hsi');
            if (type(args) === 'array' && args.length === 3) {
                return 'hsi';
            }
        }
    });

    Color.prototype.hsl = function () {
        return rgb2hsl$1(this._rgb);
    };

    chroma.hsl = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color, [ null ].concat( args, ['hsl']) ));
    };

    input.format.hsl = hsl2rgb;

    input.autodetect.push({
        p: 2,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack(args, 'hsl');
            if (type(args) === 'array' && args.length === 3) {
                return 'hsl';
            }
        }
    });

    var floor$2 = Math.floor;

    var hsv2rgb = function () {
        var assign, assign$1, assign$2, assign$3, assign$4, assign$5;

        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];
        args = unpack(args, 'hsv');
        var h = args[0];
        var s = args[1];
        var v = args[2];
        var r, g, b;
        v *= 255;
        if (s === 0) {
            r = g = b = v;
        } else {
            if (h === 360) { h = 0; }
            if (h > 360) { h -= 360; }
            if (h < 0) { h += 360; }
            h /= 60;

            var i = floor$2(h);
            var f = h - i;
            var p = v * (1 - s);
            var q = v * (1 - s * f);
            var t = v * (1 - s * (1 - f));

            switch (i) {
                case 0:
                    (assign = [v, t, p], r = assign[0], g = assign[1], b = assign[2]);
                    break;
                case 1:
                    (assign$1 = [q, v, p], r = assign$1[0], g = assign$1[1], b = assign$1[2]);
                    break;
                case 2:
                    (assign$2 = [p, v, t], r = assign$2[0], g = assign$2[1], b = assign$2[2]);
                    break;
                case 3:
                    (assign$3 = [p, q, v], r = assign$3[0], g = assign$3[1], b = assign$3[2]);
                    break;
                case 4:
                    (assign$4 = [t, p, v], r = assign$4[0], g = assign$4[1], b = assign$4[2]);
                    break;
                case 5:
                    (assign$5 = [v, p, q], r = assign$5[0], g = assign$5[1], b = assign$5[2]);
                    break;
            }
        }
        return [r, g, b, args.length > 3 ? args[3] : 1];
    };

    var min$1 = Math.min;
    var max$1 = Math.max;

    /*
     * supported arguments:
     * - rgb2hsv(r,g,b)
     * - rgb2hsv([r,g,b])
     * - rgb2hsv({r,g,b})
     */
    var rgb2hsl = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        args = unpack(args, 'rgb');
        var r = args[0];
        var g = args[1];
        var b = args[2];
        var min_ = min$1(r, g, b);
        var max_ = max$1(r, g, b);
        var delta = max_ - min_;
        var h, s, v;
        v = max_ / 255.0;
        if (max_ === 0) {
            h = Number.NaN;
            s = 0;
        } else {
            s = delta / max_;
            if (r === max_) { h = (g - b) / delta; }
            if (g === max_) { h = 2 + (b - r) / delta; }
            if (b === max_) { h = 4 + (r - g) / delta; }
            h *= 60;
            if (h < 0) { h += 360; }
        }
        return [h, s, v];
    };

    Color.prototype.hsv = function () {
        return rgb2hsl(this._rgb);
    };

    chroma.hsv = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color, [ null ].concat( args, ['hsv']) ));
    };

    input.format.hsv = hsv2rgb;

    input.autodetect.push({
        p: 2,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack(args, 'hsv');
            if (type(args) === 'array' && args.length === 3) {
                return 'hsv';
            }
        }
    });

    var LAB_CONSTANTS = {
        // Corresponds roughly to RGB brighter/darker
        Kn: 18,

        // D65 standard referent
        Xn: 0.95047,
        Yn: 1,
        Zn: 1.08883,

        t0: 0.137931034, // 4 / 29
        t1: 0.206896552, // 6 / 29
        t2: 0.12841855, // 3 * t1 * t1
        t3: 0.008856452 // t1 * t1 * t1
    };

    var pow$a = Math.pow;

    /*
     * L* [0..100]
     * a [-100..100]
     * b [-100..100]
     */
    var lab2rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        args = unpack(args, 'lab');
        var l = args[0];
        var a = args[1];
        var b = args[2];
        var x, y, z, r, g, b_;

        y = (l + 16) / 116;
        x = isNaN(a) ? y : y + a / 500;
        z = isNaN(b) ? y : y - b / 200;

        y = LAB_CONSTANTS.Yn * lab_xyz(y);
        x = LAB_CONSTANTS.Xn * lab_xyz(x);
        z = LAB_CONSTANTS.Zn * lab_xyz(z);

        r = xyz_rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z); // D65 -> sRGB
        g = xyz_rgb(-0.969266 * x + 1.8760108 * y + 0.041556 * z);
        b_ = xyz_rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z);

        return [r, g, b_, args.length > 3 ? args[3] : 1];
    };

    var xyz_rgb = function (r) {
        return 255 * (r <= 0.00304 ? 12.92 * r : 1.055 * pow$a(r, 1 / 2.4) - 0.055);
    };

    var lab_xyz = function (t) {
        return t > LAB_CONSTANTS.t1
            ? t * t * t
            : LAB_CONSTANTS.t2 * (t - LAB_CONSTANTS.t0);
    };

    var pow$9 = Math.pow;

    var rgb2lab = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        var ref$1 = rgb2xyz(r, g, b);
        var x = ref$1[0];
        var y = ref$1[1];
        var z = ref$1[2];
        var l = 116 * y - 16;
        return [l < 0 ? 0 : l, 500 * (x - y), 200 * (y - z)];
    };

    var rgb_xyz = function (r) {
        if ((r /= 255) <= 0.04045) { return r / 12.92; }
        return pow$9((r + 0.055) / 1.055, 2.4);
    };

    var xyz_lab = function (t) {
        if (t > LAB_CONSTANTS.t3) { return pow$9(t, 1 / 3); }
        return t / LAB_CONSTANTS.t2 + LAB_CONSTANTS.t0;
    };

    var rgb2xyz = function (r, g, b) {
        r = rgb_xyz(r);
        g = rgb_xyz(g);
        b = rgb_xyz(b);
        var x = xyz_lab(
            (0.4124564 * r + 0.3575761 * g + 0.1804375 * b) / LAB_CONSTANTS.Xn
        );
        var y = xyz_lab(
            (0.2126729 * r + 0.7151522 * g + 0.072175 * b) / LAB_CONSTANTS.Yn
        );
        var z = xyz_lab(
            (0.0193339 * r + 0.119192 * g + 0.9503041 * b) / LAB_CONSTANTS.Zn
        );
        return [x, y, z];
    };

    Color.prototype.lab = function () {
        return rgb2lab(this._rgb);
    };

    chroma.lab = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color, [ null ].concat( args, ['lab']) ));
    };

    input.format.lab = lab2rgb;

    input.autodetect.push({
        p: 2,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack(args, 'lab');
            if (type(args) === 'array' && args.length === 3) {
                return 'lab';
            }
        }
    });

    var sin$3 = Math.sin;
    var cos$3 = Math.cos;

    var lch2lab = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        /*
        Convert from a qualitative parameter h and a quantitative parameter l to a 24-bit pixel.
        These formulas were invented by David Dalrymple to obtain maximum contrast without going
        out of gamut if the parameters are in the range 0-1.

        A saturation multiplier was added by Gregor Aisch
        */
        var ref = unpack(args, 'lch');
        var l = ref[0];
        var c = ref[1];
        var h = ref[2];
        if (isNaN(h)) { h = 0; }
        h = h * DEG2RAD;
        return [l, cos$3(h) * c, sin$3(h) * c];
    };

    var lch2rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        args = unpack(args, 'lch');
        var l = args[0];
        var c = args[1];
        var h = args[2];
        var ref = lch2lab(l, c, h);
        var L = ref[0];
        var a = ref[1];
        var b_ = ref[2];
        var ref$1 = lab2rgb(L, a, b_);
        var r = ref$1[0];
        var g = ref$1[1];
        var b = ref$1[2];
        return [r, g, b, args.length > 3 ? args[3] : 1];
    };

    var hcl2rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var hcl = unpack(args, 'hcl').reverse();
        return lch2rgb.apply(void 0, hcl);
    };

    var sqrt$3 = Math.sqrt;
    var atan2$2 = Math.atan2;
    var round$2 = Math.round;

    var lab2lch = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack(args, 'lab');
        var l = ref[0];
        var a = ref[1];
        var b = ref[2];
        var c = sqrt$3(a * a + b * b);
        var h = (atan2$2(b, a) * RAD2DEG + 360) % 360;
        if (round$2(c * 10000) === 0) { h = Number.NaN; }
        return [l, c, h];
    };

    var rgb2lch = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        var ref$1 = rgb2lab(r, g, b);
        var l = ref$1[0];
        var a = ref$1[1];
        var b_ = ref$1[2];
        return lab2lch(l, a, b_);
    };

    Color.prototype.lch = function () {
        return rgb2lch(this._rgb);
    };
    Color.prototype.hcl = function () {
        return rgb2lch(this._rgb).reverse();
    };

    chroma.lch = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color, [ null ].concat( args, ['lch']) ));
    };
    chroma.hcl = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color, [ null ].concat( args, ['hcl']) ));
    };

    input.format.lch = lch2rgb;
    input.format.hcl = hcl2rgb;
    ['lch', 'hcl'].forEach(function (m) { return input.autodetect.push({
            p: 2,
            test: function () {
                var args = [], len = arguments.length;
                while ( len-- ) args[ len ] = arguments[ len ];

                args = unpack(args, m);
                if (type(args) === 'array' && args.length === 3) {
                    return m;
                }
            }
        }); }
    );

    /**
    	X11 color names

    	http://www.w3.org/TR/css3-color/#svg-color
    */

    var w3cx11 = {
        aliceblue: '#f0f8ff',
        antiquewhite: '#faebd7',
        aqua: '#00ffff',
        aquamarine: '#7fffd4',
        azure: '#f0ffff',
        beige: '#f5f5dc',
        bisque: '#ffe4c4',
        black: '#000000',
        blanchedalmond: '#ffebcd',
        blue: '#0000ff',
        blueviolet: '#8a2be2',
        brown: '#a52a2a',
        burlywood: '#deb887',
        cadetblue: '#5f9ea0',
        chartreuse: '#7fff00',
        chocolate: '#d2691e',
        coral: '#ff7f50',
        cornflowerblue: '#6495ed',
        cornsilk: '#fff8dc',
        crimson: '#dc143c',
        cyan: '#00ffff',
        darkblue: '#00008b',
        darkcyan: '#008b8b',
        darkgoldenrod: '#b8860b',
        darkgray: '#a9a9a9',
        darkgreen: '#006400',
        darkgrey: '#a9a9a9',
        darkkhaki: '#bdb76b',
        darkmagenta: '#8b008b',
        darkolivegreen: '#556b2f',
        darkorange: '#ff8c00',
        darkorchid: '#9932cc',
        darkred: '#8b0000',
        darksalmon: '#e9967a',
        darkseagreen: '#8fbc8f',
        darkslateblue: '#483d8b',
        darkslategray: '#2f4f4f',
        darkslategrey: '#2f4f4f',
        darkturquoise: '#00ced1',
        darkviolet: '#9400d3',
        deeppink: '#ff1493',
        deepskyblue: '#00bfff',
        dimgray: '#696969',
        dimgrey: '#696969',
        dodgerblue: '#1e90ff',
        firebrick: '#b22222',
        floralwhite: '#fffaf0',
        forestgreen: '#228b22',
        fuchsia: '#ff00ff',
        gainsboro: '#dcdcdc',
        ghostwhite: '#f8f8ff',
        gold: '#ffd700',
        goldenrod: '#daa520',
        gray: '#808080',
        green: '#008000',
        greenyellow: '#adff2f',
        grey: '#808080',
        honeydew: '#f0fff0',
        hotpink: '#ff69b4',
        indianred: '#cd5c5c',
        indigo: '#4b0082',
        ivory: '#fffff0',
        khaki: '#f0e68c',
        laserlemon: '#ffff54',
        lavender: '#e6e6fa',
        lavenderblush: '#fff0f5',
        lawngreen: '#7cfc00',
        lemonchiffon: '#fffacd',
        lightblue: '#add8e6',
        lightcoral: '#f08080',
        lightcyan: '#e0ffff',
        lightgoldenrod: '#fafad2',
        lightgoldenrodyellow: '#fafad2',
        lightgray: '#d3d3d3',
        lightgreen: '#90ee90',
        lightgrey: '#d3d3d3',
        lightpink: '#ffb6c1',
        lightsalmon: '#ffa07a',
        lightseagreen: '#20b2aa',
        lightskyblue: '#87cefa',
        lightslategray: '#778899',
        lightslategrey: '#778899',
        lightsteelblue: '#b0c4de',
        lightyellow: '#ffffe0',
        lime: '#00ff00',
        limegreen: '#32cd32',
        linen: '#faf0e6',
        magenta: '#ff00ff',
        maroon: '#800000',
        maroon2: '#7f0000',
        maroon3: '#b03060',
        mediumaquamarine: '#66cdaa',
        mediumblue: '#0000cd',
        mediumorchid: '#ba55d3',
        mediumpurple: '#9370db',
        mediumseagreen: '#3cb371',
        mediumslateblue: '#7b68ee',
        mediumspringgreen: '#00fa9a',
        mediumturquoise: '#48d1cc',
        mediumvioletred: '#c71585',
        midnightblue: '#191970',
        mintcream: '#f5fffa',
        mistyrose: '#ffe4e1',
        moccasin: '#ffe4b5',
        navajowhite: '#ffdead',
        navy: '#000080',
        oldlace: '#fdf5e6',
        olive: '#808000',
        olivedrab: '#6b8e23',
        orange: '#ffa500',
        orangered: '#ff4500',
        orchid: '#da70d6',
        palegoldenrod: '#eee8aa',
        palegreen: '#98fb98',
        paleturquoise: '#afeeee',
        palevioletred: '#db7093',
        papayawhip: '#ffefd5',
        peachpuff: '#ffdab9',
        peru: '#cd853f',
        pink: '#ffc0cb',
        plum: '#dda0dd',
        powderblue: '#b0e0e6',
        purple: '#800080',
        purple2: '#7f007f',
        purple3: '#a020f0',
        rebeccapurple: '#663399',
        red: '#ff0000',
        rosybrown: '#bc8f8f',
        royalblue: '#4169e1',
        saddlebrown: '#8b4513',
        salmon: '#fa8072',
        sandybrown: '#f4a460',
        seagreen: '#2e8b57',
        seashell: '#fff5ee',
        sienna: '#a0522d',
        silver: '#c0c0c0',
        skyblue: '#87ceeb',
        slateblue: '#6a5acd',
        slategray: '#708090',
        slategrey: '#708090',
        snow: '#fffafa',
        springgreen: '#00ff7f',
        steelblue: '#4682b4',
        tan: '#d2b48c',
        teal: '#008080',
        thistle: '#d8bfd8',
        tomato: '#ff6347',
        turquoise: '#40e0d0',
        violet: '#ee82ee',
        wheat: '#f5deb3',
        white: '#ffffff',
        whitesmoke: '#f5f5f5',
        yellow: '#ffff00',
        yellowgreen: '#9acd32'
    };

    Color.prototype.name = function () {
        var hex = rgb2hex(this._rgb, 'rgb');
        for (var i = 0, list = Object.keys(w3cx11); i < list.length; i += 1) {
            var n = list[i];

            if (w3cx11[n] === hex) { return n.toLowerCase(); }
        }
        return hex;
    };

    input.format.named = function (name) {
        name = name.toLowerCase();
        if (w3cx11[name]) { return hex2rgb(w3cx11[name]); }
        throw new Error('unknown color name: ' + name);
    };

    input.autodetect.push({
        p: 5,
        test: function (h) {
            var rest = [], len = arguments.length - 1;
            while ( len-- > 0 ) rest[ len ] = arguments[ len + 1 ];

            if (!rest.length && type(h) === 'string' && w3cx11[h.toLowerCase()]) {
                return 'named';
            }
        }
    });

    var num2rgb = function (num) {
        if (type(num) == 'number' && num >= 0 && num <= 0xffffff) {
            var r = num >> 16;
            var g = (num >> 8) & 0xff;
            var b = num & 0xff;
            return [r, g, b, 1];
        }
        throw new Error('unknown num color: ' + num);
    };

    var rgb2num = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        return (r << 16) + (g << 8) + b;
    };

    Color.prototype.num = function () {
        return rgb2num(this._rgb);
    };

    chroma.num = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color, [ null ].concat( args, ['num']) ));
    };

    input.format.num = num2rgb;

    input.autodetect.push({
        p: 5,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            if (
                args.length === 1 &&
                type(args[0]) === 'number' &&
                args[0] >= 0 &&
                args[0] <= 0xffffff
            ) {
                return 'num';
            }
        }
    });

    var round$1 = Math.round;

    Color.prototype.rgb = function (rnd) {
        if ( rnd === void 0 ) rnd = true;

        if (rnd === false) { return this._rgb.slice(0, 3); }
        return this._rgb.slice(0, 3).map(round$1);
    };

    Color.prototype.rgba = function (rnd) {
        if ( rnd === void 0 ) rnd = true;

        return this._rgb.slice(0, 4).map(function (v, i) {
            return i < 3 ? (rnd === false ? v : round$1(v)) : v;
        });
    };

    chroma.rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color, [ null ].concat( args, ['rgb']) ));
    };

    input.format.rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var rgba = unpack(args, 'rgba');
        if (rgba[3] === undefined) { rgba[3] = 1; }
        return rgba;
    };

    input.autodetect.push({
        p: 3,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack(args, 'rgba');
            if (
                type(args) === 'array' &&
                (args.length === 3 ||
                    (args.length === 4 &&
                        type(args[3]) == 'number' &&
                        args[3] >= 0 &&
                        args[3] <= 1))
            ) {
                return 'rgb';
            }
        }
    });

    /*
     * Based on implementation by Neil Bartlett
     * https://github.com/neilbartlett/color-temperature
     */

    var log$1 = Math.log;

    var temperature2rgb = function (kelvin) {
        var temp = kelvin / 100;
        var r, g, b;
        if (temp < 66) {
            r = 255;
            g =
                temp < 6
                    ? 0
                    : -155.25485562709179 -
                      0.44596950469579133 * (g = temp - 2) +
                      104.49216199393888 * log$1(g);
            b =
                temp < 20
                    ? 0
                    : -254.76935184120902 +
                      0.8274096064007395 * (b = temp - 10) +
                      115.67994401066147 * log$1(b);
        } else {
            r =
                351.97690566805693 +
                0.114206453784165 * (r = temp - 55) -
                40.25366309332127 * log$1(r);
            g =
                325.4494125711974 +
                0.07943456536662342 * (g = temp - 50) -
                28.0852963507957 * log$1(g);
            b = 255;
        }
        return [r, g, b, 1];
    };

    /*
     * Based on implementation by Neil Bartlett
     * https://github.com/neilbartlett/color-temperature
     **/

    var round = Math.round;

    var rgb2temperature = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var rgb = unpack(args, 'rgb');
        var r = rgb[0],
            b = rgb[2];
        var minTemp = 1000;
        var maxTemp = 40000;
        var eps = 0.4;
        var temp;
        while (maxTemp - minTemp > eps) {
            temp = (maxTemp + minTemp) * 0.5;
            var rgb$1 = temperature2rgb(temp);
            if (rgb$1[2] / rgb$1[0] >= b / r) {
                maxTemp = temp;
            } else {
                minTemp = temp;
            }
        }
        return round(temp);
    };

    Color.prototype.temp =
        Color.prototype.kelvin =
        Color.prototype.temperature =
            function () {
                return rgb2temperature(this._rgb);
            };

    chroma.temp =
        chroma.kelvin =
        chroma.temperature =
            function () {
                var args = [], len = arguments.length;
                while ( len-- ) args[ len ] = arguments[ len ];

                return new (Function.prototype.bind.apply( Color, [ null ].concat( args, ['temp']) ));
    };

    input.format.temp =
        input.format.kelvin =
        input.format.temperature =
            temperature2rgb;

    var pow$8 = Math.pow;
    var sign$1 = Math.sign;

    /*
     * L* [0..100]
     * a [-100..100]
     * b [-100..100]
     */
    var oklab2rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        args = unpack(args, 'lab');
        var L = args[0];
        var a = args[1];
        var b = args[2];

        var l = pow$8(L + 0.3963377774 * a + 0.2158037573 * b, 3);
        var m = pow$8(L - 0.1055613458 * a - 0.0638541728 * b, 3);
        var s = pow$8(L - 0.0894841775 * a - 1.291485548 * b, 3);

        return [
            255 * lrgb2rgb(+4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s),
            255 * lrgb2rgb(-1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s),
            255 * lrgb2rgb(-0.0041960863 * l - 0.7034186147 * m + 1.707614701 * s),
            args.length > 3 ? args[3] : 1
        ];
    };

    function lrgb2rgb(c) {
        var abs = Math.abs(c);
        if (abs > 0.0031308) {
            return (sign$1(c) || 1) * (1.055 * pow$8(abs, 1 / 2.4) - 0.055);
        }
        return c * 12.92;
    }

    var cbrt = Math.cbrt;
    var pow$7 = Math.pow;
    var sign = Math.sign;

    var rgb2oklab = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        // OKLab color space implementation taken from
        // https://bottosson.github.io/posts/oklab/
        var ref = unpack(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        var ref$1 = [
            rgb2lrgb(r / 255),
            rgb2lrgb(g / 255),
            rgb2lrgb(b / 255)
        ];
        var lr = ref$1[0];
        var lg = ref$1[1];
        var lb = ref$1[2];
        var l = cbrt(0.4122214708 * lr + 0.5363325363 * lg + 0.0514459929 * lb);
        var m = cbrt(0.2119034982 * lr + 0.6806995451 * lg + 0.1073969566 * lb);
        var s = cbrt(0.0883024619 * lr + 0.2817188376 * lg + 0.6299787005 * lb);

        return [
            0.2104542553 * l + 0.793617785 * m - 0.0040720468 * s,
            1.9779984951 * l - 2.428592205 * m + 0.4505937099 * s,
            0.0259040371 * l + 0.7827717662 * m - 0.808675766 * s
        ];
    };

    function rgb2lrgb(c) {
        var abs = Math.abs(c);
        if (abs < 0.04045) {
            return c / 12.92;
        }
        return (sign(c) || 1) * pow$7((abs + 0.055) / 1.055, 2.4);
    }

    Color.prototype.oklab = function () {
        return rgb2oklab(this._rgb);
    };

    chroma.oklab = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color, [ null ].concat( args, ['oklab']) ));
    };

    input.format.oklab = oklab2rgb;

    input.autodetect.push({
        p: 3,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack(args, 'oklab');
            if (type(args) === 'array' && args.length === 3) {
                return 'oklab';
            }
        }
    });

    var oklch2rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        args = unpack(args, 'lch');
        var l = args[0];
        var c = args[1];
        var h = args[2];
        var ref = lch2lab(l, c, h);
        var L = ref[0];
        var a = ref[1];
        var b_ = ref[2];
        var ref$1 = oklab2rgb(L, a, b_);
        var r = ref$1[0];
        var g = ref$1[1];
        var b = ref$1[2];
        return [r, g, b, args.length > 3 ? args[3] : 1];
    };

    var rgb2oklch = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        var ref$1 = rgb2oklab(r, g, b);
        var l = ref$1[0];
        var a = ref$1[1];
        var b_ = ref$1[2];
        return lab2lch(l, a, b_);
    };

    Color.prototype.oklch = function () {
        return rgb2oklch(this._rgb);
    };

    chroma.oklch = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color, [ null ].concat( args, ['oklch']) ));
    };

    input.format.oklch = oklch2rgb;

    input.autodetect.push({
        p: 3,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack(args, 'oklch');
            if (type(args) === 'array' && args.length === 3) {
                return 'oklch';
            }
        }
    });

    Color.prototype.alpha = function (a, mutate) {
        if ( mutate === void 0 ) mutate = false;

        if (a !== undefined && type(a) === 'number') {
            if (mutate) {
                this._rgb[3] = a;
                return this;
            }
            return new Color([this._rgb[0], this._rgb[1], this._rgb[2], a], 'rgb');
        }
        return this._rgb[3];
    };

    Color.prototype.clipped = function () {
        return this._rgb._clipped || false;
    };

    Color.prototype.darken = function (amount) {
        if ( amount === void 0 ) amount = 1;

        var me = this;
        var lab = me.lab();
        lab[0] -= LAB_CONSTANTS.Kn * amount;
        return new Color(lab, 'lab').alpha(me.alpha(), true);
    };

    Color.prototype.brighten = function (amount) {
        if ( amount === void 0 ) amount = 1;

        return this.darken(-amount);
    };

    Color.prototype.darker = Color.prototype.darken;
    Color.prototype.brighter = Color.prototype.brighten;

    Color.prototype.get = function (mc) {
        var ref = mc.split('.');
        var mode = ref[0];
        var channel = ref[1];
        var src = this[mode]();
        if (channel) {
            var i = mode.indexOf(channel) - (mode.substr(0, 2) === 'ok' ? 2 : 0);
            if (i > -1) { return src[i]; }
            throw new Error(("unknown channel " + channel + " in mode " + mode));
        } else {
            return src;
        }
    };

    var pow$6 = Math.pow;

    var EPS = 1e-7;
    var MAX_ITER = 20;

    Color.prototype.luminance = function (lum, mode) {
        if ( mode === void 0 ) mode = 'rgb';

        if (lum !== undefined && type(lum) === 'number') {
            if (lum === 0) {
                // return pure black
                return new Color([0, 0, 0, this._rgb[3]], 'rgb');
            }
            if (lum === 1) {
                // return pure white
                return new Color([255, 255, 255, this._rgb[3]], 'rgb');
            }
            // compute new color using...
            var cur_lum = this.luminance();
            var max_iter = MAX_ITER;

            var test = function (low, high) {
                var mid = low.interpolate(high, 0.5, mode);
                var lm = mid.luminance();
                if (Math.abs(lum - lm) < EPS || !max_iter--) {
                    // close enough
                    return mid;
                }
                return lm > lum ? test(low, mid) : test(mid, high);
            };

            var rgb = (
                cur_lum > lum
                    ? test(new Color([0, 0, 0]), this)
                    : test(this, new Color([255, 255, 255]))
            ).rgb();
            return new Color(rgb.concat( [this._rgb[3]]));
        }
        return rgb2luminance.apply(void 0, this._rgb.slice(0, 3));
    };

    var rgb2luminance = function (r, g, b) {
        // relative luminance
        // see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
        r = luminance_x(r);
        g = luminance_x(g);
        b = luminance_x(b);
        return 0.2126 * r + 0.7152 * g + 0.0722 * b;
    };

    var luminance_x = function (x) {
        x /= 255;
        return x <= 0.03928 ? x / 12.92 : pow$6((x + 0.055) / 1.055, 2.4);
    };

    var index = {};

    function mix (col1, col2, f) {
        if ( f === void 0 ) f = 0.5;
        var rest = [], len = arguments.length - 3;
        while ( len-- > 0 ) rest[ len ] = arguments[ len + 3 ];

        var mode = rest[0] || 'lrgb';
        if (!index[mode] && !rest.length) {
            // fall back to the first supported mode
            mode = Object.keys(index)[0];
        }
        if (!index[mode]) {
            throw new Error(("interpolation mode " + mode + " is not defined"));
        }
        if (type(col1) !== 'object') { col1 = new Color(col1); }
        if (type(col2) !== 'object') { col2 = new Color(col2); }
        return index[mode](col1, col2, f).alpha(
            col1.alpha() + f * (col2.alpha() - col1.alpha())
        );
    }

    Color.prototype.mix = Color.prototype.interpolate = function (
        col2,
        f
    ) {
        if ( f === void 0 ) f = 0.5;
        var rest = [], len = arguments.length - 2;
        while ( len-- > 0 ) rest[ len ] = arguments[ len + 2 ];

        return mix.apply(void 0, [ this, col2, f ].concat( rest ));
    };

    Color.prototype.premultiply = function (mutate) {
        if ( mutate === void 0 ) mutate = false;

        var rgb = this._rgb;
        var a = rgb[3];
        if (mutate) {
            this._rgb = [rgb[0] * a, rgb[1] * a, rgb[2] * a, a];
            return this;
        } else {
            return new Color([rgb[0] * a, rgb[1] * a, rgb[2] * a, a], 'rgb');
        }
    };

    Color.prototype.saturate = function (amount) {
        if ( amount === void 0 ) amount = 1;

        var me = this;
        var lch = me.lch();
        lch[1] += LAB_CONSTANTS.Kn * amount;
        if (lch[1] < 0) { lch[1] = 0; }
        return new Color(lch, 'lch').alpha(me.alpha(), true);
    };

    Color.prototype.desaturate = function (amount) {
        if ( amount === void 0 ) amount = 1;

        return this.saturate(-amount);
    };

    Color.prototype.set = function (mc, value, mutate) {
        if ( mutate === void 0 ) mutate = false;

        var ref = mc.split('.');
        var mode = ref[0];
        var channel = ref[1];
        var src = this[mode]();
        if (channel) {
            var i = mode.indexOf(channel) - (mode.substr(0, 2) === 'ok' ? 2 : 0);
            if (i > -1) {
                if (type(value) == 'string') {
                    switch (value.charAt(0)) {
                        case '+':
                            src[i] += +value;
                            break;
                        case '-':
                            src[i] += +value;
                            break;
                        case '*':
                            src[i] *= +value.substr(1);
                            break;
                        case '/':
                            src[i] /= +value.substr(1);
                            break;
                        default:
                            src[i] = +value;
                    }
                } else if (type(value) === 'number') {
                    src[i] = value;
                } else {
                    throw new Error("unsupported value for Color.set");
                }
                var out = new Color(src, mode);
                if (mutate) {
                    this._rgb = out._rgb;
                    return this;
                }
                return out;
            }
            throw new Error(("unknown channel " + channel + " in mode " + mode));
        } else {
            return src;
        }
    };

    Color.prototype.tint = function (f) {
        if ( f === void 0 ) f = 0.5;
        var rest = [], len = arguments.length - 1;
        while ( len-- > 0 ) rest[ len ] = arguments[ len + 1 ];

        return mix.apply(void 0, [ this, 'white', f ].concat( rest ));
    };

    Color.prototype.shade = function (f) {
        if ( f === void 0 ) f = 0.5;
        var rest = [], len = arguments.length - 1;
        while ( len-- > 0 ) rest[ len ] = arguments[ len + 1 ];

        return mix.apply(void 0, [ this, 'black', f ].concat( rest ));
    };

    var rgb = function (col1, col2, f) {
        var xyz0 = col1._rgb;
        var xyz1 = col2._rgb;
        return new Color(
            xyz0[0] + f * (xyz1[0] - xyz0[0]),
            xyz0[1] + f * (xyz1[1] - xyz0[1]),
            xyz0[2] + f * (xyz1[2] - xyz0[2]),
            'rgb'
        );
    };

    // register interpolator
    index.rgb = rgb;

    var sqrt$2 = Math.sqrt;
    var pow$5 = Math.pow;

    var lrgb = function (col1, col2, f) {
        var ref = col1._rgb;
        var x1 = ref[0];
        var y1 = ref[1];
        var z1 = ref[2];
        var ref$1 = col2._rgb;
        var x2 = ref$1[0];
        var y2 = ref$1[1];
        var z2 = ref$1[2];
        return new Color(
            sqrt$2(pow$5(x1, 2) * (1 - f) + pow$5(x2, 2) * f),
            sqrt$2(pow$5(y1, 2) * (1 - f) + pow$5(y2, 2) * f),
            sqrt$2(pow$5(z1, 2) * (1 - f) + pow$5(z2, 2) * f),
            'rgb'
        );
    };

    // register interpolator
    index.lrgb = lrgb;

    var lab = function (col1, col2, f) {
        var xyz0 = col1.lab();
        var xyz1 = col2.lab();
        return new Color(
            xyz0[0] + f * (xyz1[0] - xyz0[0]),
            xyz0[1] + f * (xyz1[1] - xyz0[1]),
            xyz0[2] + f * (xyz1[2] - xyz0[2]),
            'lab'
        );
    };

    // register interpolator
    index.lab = lab;

    function interpolate_hsx (col1, col2, f, m) {
        var assign, assign$1;

        var xyz0, xyz1;
        if (m === 'hsl') {
            xyz0 = col1.hsl();
            xyz1 = col2.hsl();
        } else if (m === 'hsv') {
            xyz0 = col1.hsv();
            xyz1 = col2.hsv();
        } else if (m === 'hcg') {
            xyz0 = col1.hcg();
            xyz1 = col2.hcg();
        } else if (m === 'hsi') {
            xyz0 = col1.hsi();
            xyz1 = col2.hsi();
        } else if (m === 'lch' || m === 'hcl') {
            m = 'hcl';
            xyz0 = col1.hcl();
            xyz1 = col2.hcl();
        } else if (m === 'oklch') {
            xyz0 = col1.oklch().reverse();
            xyz1 = col2.oklch().reverse();
        }

        var hue0, hue1, sat0, sat1, lbv0, lbv1;
        if (m.substr(0, 1) === 'h' || m === 'oklch') {
            (assign = xyz0, hue0 = assign[0], sat0 = assign[1], lbv0 = assign[2]);
            (assign$1 = xyz1, hue1 = assign$1[0], sat1 = assign$1[1], lbv1 = assign$1[2]);
        }

        var sat, hue, lbv, dh;

        if (!isNaN(hue0) && !isNaN(hue1)) {
            // both colors have hue
            if (hue1 > hue0 && hue1 - hue0 > 180) {
                dh = hue1 - (hue0 + 360);
            } else if (hue1 < hue0 && hue0 - hue1 > 180) {
                dh = hue1 + 360 - hue0;
            } else {
                dh = hue1 - hue0;
            }
            hue = hue0 + f * dh;
        } else if (!isNaN(hue0)) {
            hue = hue0;
            if ((lbv1 == 1 || lbv1 == 0) && m != 'hsv') { sat = sat0; }
        } else if (!isNaN(hue1)) {
            hue = hue1;
            if ((lbv0 == 1 || lbv0 == 0) && m != 'hsv') { sat = sat1; }
        } else {
            hue = Number.NaN;
        }

        if (sat === undefined) { sat = sat0 + f * (sat1 - sat0); }
        lbv = lbv0 + f * (lbv1 - lbv0);
        return m === 'oklch'
            ? new Color([lbv, sat, hue], m)
            : new Color([hue, sat, lbv], m);
    }

    var lch = function (col1, col2, f) {
        return interpolate_hsx(col1, col2, f, 'lch');
    };

    // register interpolator
    index.lch = lch;
    index.hcl = lch;

    var num = function (col1, col2, f) {
        var c1 = col1.num();
        var c2 = col2.num();
        return new Color(c1 + f * (c2 - c1), 'num');
    };

    // register interpolator
    index.num = num;

    var hcg = function (col1, col2, f) {
        return interpolate_hsx(col1, col2, f, 'hcg');
    };

    // register interpolator
    index.hcg = hcg;

    var hsi = function (col1, col2, f) {
        return interpolate_hsx(col1, col2, f, 'hsi');
    };

    // register interpolator
    index.hsi = hsi;

    var hsl = function (col1, col2, f) {
        return interpolate_hsx(col1, col2, f, 'hsl');
    };

    // register interpolator
    index.hsl = hsl;

    var hsv = function (col1, col2, f) {
        return interpolate_hsx(col1, col2, f, 'hsv');
    };

    // register interpolator
    index.hsv = hsv;

    var oklab = function (col1, col2, f) {
        var xyz0 = col1.oklab();
        var xyz1 = col2.oklab();
        return new Color(
            xyz0[0] + f * (xyz1[0] - xyz0[0]),
            xyz0[1] + f * (xyz1[1] - xyz0[1]),
            xyz0[2] + f * (xyz1[2] - xyz0[2]),
            'oklab'
        );
    };

    // register interpolator
    index.oklab = oklab;

    var oklch = function (col1, col2, f) {
        return interpolate_hsx(col1, col2, f, 'oklch');
    };

    // register interpolator
    index.oklch = oklch;

    var pow$4 = Math.pow;
    var sqrt$1 = Math.sqrt;
    var PI$1 = Math.PI;
    var cos$2 = Math.cos;
    var sin$2 = Math.sin;
    var atan2$1 = Math.atan2;

    function average (colors, mode, weights) {
        if ( mode === void 0 ) mode = 'lrgb';
        if ( weights === void 0 ) weights = null;

        var l = colors.length;
        if (!weights) { weights = Array.from(new Array(l)).map(function () { return 1; }); }
        // normalize weights
        var k =
            l /
            weights.reduce(function (a, b) {
                return a + b;
            });
        weights.forEach(function (w, i) {
            weights[i] *= k;
        });
        // convert colors to Color objects
        colors = colors.map(function (c) { return new Color(c); });
        if (mode === 'lrgb') {
            return _average_lrgb(colors, weights);
        }
        var first = colors.shift();
        var xyz = first.get(mode);
        var cnt = [];
        var dx = 0;
        var dy = 0;
        // initial color
        for (var i = 0; i < xyz.length; i++) {
            xyz[i] = (xyz[i] || 0) * weights[0];
            cnt.push(isNaN(xyz[i]) ? 0 : weights[0]);
            if (mode.charAt(i) === 'h' && !isNaN(xyz[i])) {
                var A = (xyz[i] / 180) * PI$1;
                dx += cos$2(A) * weights[0];
                dy += sin$2(A) * weights[0];
            }
        }

        var alpha = first.alpha() * weights[0];
        colors.forEach(function (c, ci) {
            var xyz2 = c.get(mode);
            alpha += c.alpha() * weights[ci + 1];
            for (var i = 0; i < xyz.length; i++) {
                if (!isNaN(xyz2[i])) {
                    cnt[i] += weights[ci + 1];
                    if (mode.charAt(i) === 'h') {
                        var A = (xyz2[i] / 180) * PI$1;
                        dx += cos$2(A) * weights[ci + 1];
                        dy += sin$2(A) * weights[ci + 1];
                    } else {
                        xyz[i] += xyz2[i] * weights[ci + 1];
                    }
                }
            }
        });

        for (var i$1 = 0; i$1 < xyz.length; i$1++) {
            if (mode.charAt(i$1) === 'h') {
                var A$1 = (atan2$1(dy / cnt[i$1], dx / cnt[i$1]) / PI$1) * 180;
                while (A$1 < 0) { A$1 += 360; }
                while (A$1 >= 360) { A$1 -= 360; }
                xyz[i$1] = A$1;
            } else {
                xyz[i$1] = xyz[i$1] / cnt[i$1];
            }
        }
        alpha /= l;
        return new Color(xyz, mode).alpha(alpha > 0.99999 ? 1 : alpha, true);
    }
    var _average_lrgb = function (colors, weights) {
        var l = colors.length;
        var xyz = [0, 0, 0, 0];
        for (var i = 0; i < colors.length; i++) {
            var col = colors[i];
            var f = weights[i] / l;
            var rgb = col._rgb;
            xyz[0] += pow$4(rgb[0], 2) * f;
            xyz[1] += pow$4(rgb[1], 2) * f;
            xyz[2] += pow$4(rgb[2], 2) * f;
            xyz[3] += rgb[3] * f;
        }
        xyz[0] = sqrt$1(xyz[0]);
        xyz[1] = sqrt$1(xyz[1]);
        xyz[2] = sqrt$1(xyz[2]);
        if (xyz[3] > 0.9999999) { xyz[3] = 1; }
        return new Color(clip_rgb(xyz));
    };

    // minimal multi-purpose interface


    var pow$3 = Math.pow;

    function scale (colors) {
        // constructor
        var _mode = 'rgb';
        var _nacol = chroma('#ccc');
        var _spread = 0;
        // const _fixed = false;
        var _domain = [0, 1];
        var _pos = [];
        var _padding = [0, 0];
        var _classes = false;
        var _colors = [];
        var _out = false;
        var _min = 0;
        var _max = 1;
        var _correctLightness = false;
        var _colorCache = {};
        var _useCache = true;
        var _gamma = 1;

        // private methods

        var setColors = function (colors) {
            colors = colors || ['#fff', '#000'];
            if (
                colors &&
                type(colors) === 'string' &&
                chroma.brewer &&
                chroma.brewer[colors.toLowerCase()]
            ) {
                colors = chroma.brewer[colors.toLowerCase()];
            }
            if (type(colors) === 'array') {
                // handle single color
                if (colors.length === 1) {
                    colors = [colors[0], colors[0]];
                }
                // make a copy of the colors
                colors = colors.slice(0);
                // convert to chroma classes
                for (var c = 0; c < colors.length; c++) {
                    colors[c] = chroma(colors[c]);
                }
                // auto-fill color position
                _pos.length = 0;
                for (var c$1 = 0; c$1 < colors.length; c$1++) {
                    _pos.push(c$1 / (colors.length - 1));
                }
            }
            resetCache();
            return (_colors = colors);
        };

        var getClass = function (value) {
            if (_classes != null) {
                var n = _classes.length - 1;
                var i = 0;
                while (i < n && value >= _classes[i]) {
                    i++;
                }
                return i - 1;
            }
            return 0;
        };

        var tMapLightness = function (t) { return t; };
        var tMapDomain = function (t) { return t; };

        // const classifyValue = function(value) {
        //     let val = value;
        //     if (_classes.length > 2) {
        //         const n = _classes.length-1;
        //         const i = getClass(value);
        //         const minc = _classes[0] + ((_classes[1]-_classes[0]) * (0 + (_spread * 0.5)));  // center of 1st class
        //         const maxc = _classes[n-1] + ((_classes[n]-_classes[n-1]) * (1 - (_spread * 0.5)));  // center of last class
        //         val = _min + ((((_classes[i] + ((_classes[i+1] - _classes[i]) * 0.5)) - minc) / (maxc-minc)) * (_max - _min));
        //     }
        //     return val;
        // };

        var getColor = function (val, bypassMap) {
            var col, t;
            if (bypassMap == null) {
                bypassMap = false;
            }
            if (isNaN(val) || val === null) {
                return _nacol;
            }
            if (!bypassMap) {
                if (_classes && _classes.length > 2) {
                    // find the class
                    var c = getClass(val);
                    t = c / (_classes.length - 2);
                } else if (_max !== _min) {
                    // just interpolate between min/max
                    t = (val - _min) / (_max - _min);
                } else {
                    t = 1;
                }
            } else {
                t = val;
            }

            // domain map
            t = tMapDomain(t);

            if (!bypassMap) {
                t = tMapLightness(t); // lightness correction
            }

            if (_gamma !== 1) {
                t = pow$3(t, _gamma);
            }

            t = _padding[0] + t * (1 - _padding[0] - _padding[1]);

            t = limit(t, 0, 1);

            var k = Math.floor(t * 10000);

            if (_useCache && _colorCache[k]) {
                col = _colorCache[k];
            } else {
                if (type(_colors) === 'array') {
                    //for i in [0.._pos.length-1]
                    for (var i = 0; i < _pos.length; i++) {
                        var p = _pos[i];
                        if (t <= p) {
                            col = _colors[i];
                            break;
                        }
                        if (t >= p && i === _pos.length - 1) {
                            col = _colors[i];
                            break;
                        }
                        if (t > p && t < _pos[i + 1]) {
                            t = (t - p) / (_pos[i + 1] - p);
                            col = chroma.interpolate(
                                _colors[i],
                                _colors[i + 1],
                                t,
                                _mode
                            );
                            break;
                        }
                    }
                } else if (type(_colors) === 'function') {
                    col = _colors(t);
                }
                if (_useCache) {
                    _colorCache[k] = col;
                }
            }
            return col;
        };

        var resetCache = function () { return (_colorCache = {}); };

        setColors(colors);

        // public interface

        var f = function (v) {
            var c = chroma(getColor(v));
            if (_out && c[_out]) {
                return c[_out]();
            } else {
                return c;
            }
        };

        f.classes = function (classes) {
            if (classes != null) {
                if (type(classes) === 'array') {
                    _classes = classes;
                    _domain = [classes[0], classes[classes.length - 1]];
                } else {
                    var d = chroma.analyze(_domain);
                    if (classes === 0) {
                        _classes = [d.min, d.max];
                    } else {
                        _classes = chroma.limits(d, 'e', classes);
                    }
                }
                return f;
            }
            return _classes;
        };

        f.domain = function (domain) {
            if (!arguments.length) {
                return _domain;
            }
            _min = domain[0];
            _max = domain[domain.length - 1];
            _pos = [];
            var k = _colors.length;
            if (domain.length === k && _min !== _max) {
                // update positions
                for (var i = 0, list = Array.from(domain); i < list.length; i += 1) {
                    var d = list[i];

                    _pos.push((d - _min) / (_max - _min));
                }
            } else {
                for (var c = 0; c < k; c++) {
                    _pos.push(c / (k - 1));
                }
                if (domain.length > 2) {
                    // set domain map
                    var tOut = domain.map(function (d, i) { return i / (domain.length - 1); });
                    var tBreaks = domain.map(function (d) { return (d - _min) / (_max - _min); });
                    if (!tBreaks.every(function (val, i) { return tOut[i] === val; })) {
                        tMapDomain = function (t) {
                            if (t <= 0 || t >= 1) { return t; }
                            var i = 0;
                            while (t >= tBreaks[i + 1]) { i++; }
                            var f =
                                (t - tBreaks[i]) / (tBreaks[i + 1] - tBreaks[i]);
                            var out = tOut[i] + f * (tOut[i + 1] - tOut[i]);
                            return out;
                        };
                    }
                }
            }
            _domain = [_min, _max];
            return f;
        };

        f.mode = function (_m) {
            if (!arguments.length) {
                return _mode;
            }
            _mode = _m;
            resetCache();
            return f;
        };

        f.range = function (colors, _pos) {
            setColors(colors);
            return f;
        };

        f.out = function (_o) {
            _out = _o;
            return f;
        };

        f.spread = function (val) {
            if (!arguments.length) {
                return _spread;
            }
            _spread = val;
            return f;
        };

        f.correctLightness = function (v) {
            if (v == null) {
                v = true;
            }
            _correctLightness = v;
            resetCache();
            if (_correctLightness) {
                tMapLightness = function (t) {
                    var L0 = getColor(0, true).lab()[0];
                    var L1 = getColor(1, true).lab()[0];
                    var pol = L0 > L1;
                    var L_actual = getColor(t, true).lab()[0];
                    var L_ideal = L0 + (L1 - L0) * t;
                    var L_diff = L_actual - L_ideal;
                    var t0 = 0;
                    var t1 = 1;
                    var max_iter = 20;
                    while (Math.abs(L_diff) > 1e-2 && max_iter-- > 0) {
                        (function () {
                            if (pol) {
                                L_diff *= -1;
                            }
                            if (L_diff < 0) {
                                t0 = t;
                                t += (t1 - t) * 0.5;
                            } else {
                                t1 = t;
                                t += (t0 - t) * 0.5;
                            }
                            L_actual = getColor(t, true).lab()[0];
                            return (L_diff = L_actual - L_ideal);
                        })();
                    }
                    return t;
                };
            } else {
                tMapLightness = function (t) { return t; };
            }
            return f;
        };

        f.padding = function (p) {
            if (p != null) {
                if (type(p) === 'number') {
                    p = [p, p];
                }
                _padding = p;
                return f;
            } else {
                return _padding;
            }
        };

        f.colors = function (numColors, out) {
            // If no arguments are given, return the original colors that were provided
            if (arguments.length < 2) {
                out = 'hex';
            }
            var result = [];

            if (arguments.length === 0) {
                result = _colors.slice(0);
            } else if (numColors === 1) {
                result = [f(0.5)];
            } else if (numColors > 1) {
                var dm = _domain[0];
                var dd = _domain[1] - dm;
                result = __range__(0, numColors).map(function (i) { return f(dm + (i / (numColors - 1)) * dd); }
                );
            } else {
                // returns all colors based on the defined classes
                colors = [];
                var samples = [];
                if (_classes && _classes.length > 2) {
                    for (
                        var i = 1, end = _classes.length, asc = 1 <= end;
                        asc ? i < end : i > end;
                        asc ? i++ : i--
                    ) {
                        samples.push((_classes[i - 1] + _classes[i]) * 0.5);
                    }
                } else {
                    samples = _domain;
                }
                result = samples.map(function (v) { return f(v); });
            }

            if (chroma[out]) {
                result = result.map(function (c) { return c[out](); });
            }
            return result;
        };

        f.cache = function (c) {
            if (c != null) {
                _useCache = c;
                return f;
            } else {
                return _useCache;
            }
        };

        f.gamma = function (g) {
            if (g != null) {
                _gamma = g;
                return f;
            } else {
                return _gamma;
            }
        };

        f.nodata = function (d) {
            if (d != null) {
                _nacol = chroma(d);
                return f;
            } else {
                return _nacol;
            }
        };

        return f;
    }

    function __range__(left, right, inclusive) {
        var range = [];
        var ascending = left < right;
        var end = right ;
        for (var i = left; ascending ? i < end : i > end; ascending ? i++ : i--) {
            range.push(i);
        }
        return range;
    }

    //
    // interpolates between a set of colors uzing a bezier spline
    //


    // nth row of the pascal triangle
    var binom_row = function (n) {
        var row = [1, 1];
        for (var i = 1; i < n; i++) {
            var newrow = [1];
            for (var j = 1; j <= row.length; j++) {
                newrow[j] = (row[j] || 0) + row[j - 1];
            }
            row = newrow;
        }
        return row;
    };

    var bezier = function (colors) {
        var assign, assign$1, assign$2;

        var I, lab0, lab1, lab2;
        colors = colors.map(function (c) { return new Color(c); });
        if (colors.length === 2) {
            // linear interpolation
            (assign = colors.map(function (c) { return c.lab(); }), lab0 = assign[0], lab1 = assign[1]);
            I = function (t) {
                var lab = [0, 1, 2].map(function (i) { return lab0[i] + t * (lab1[i] - lab0[i]); });
                return new Color(lab, 'lab');
            };
        } else if (colors.length === 3) {
            // quadratic bezier interpolation
            (assign$1 = colors.map(function (c) { return c.lab(); }), lab0 = assign$1[0], lab1 = assign$1[1], lab2 = assign$1[2]);
            I = function (t) {
                var lab = [0, 1, 2].map(
                    function (i) { return (1 - t) * (1 - t) * lab0[i] +
                        2 * (1 - t) * t * lab1[i] +
                        t * t * lab2[i]; }
                );
                return new Color(lab, 'lab');
            };
        } else if (colors.length === 4) {
            // cubic bezier interpolation
            var lab3;
            (assign$2 = colors.map(function (c) { return c.lab(); }), lab0 = assign$2[0], lab1 = assign$2[1], lab2 = assign$2[2], lab3 = assign$2[3]);
            I = function (t) {
                var lab = [0, 1, 2].map(
                    function (i) { return (1 - t) * (1 - t) * (1 - t) * lab0[i] +
                        3 * (1 - t) * (1 - t) * t * lab1[i] +
                        3 * (1 - t) * t * t * lab2[i] +
                        t * t * t * lab3[i]; }
                );
                return new Color(lab, 'lab');
            };
        } else if (colors.length >= 5) {
            // general case (degree n bezier)
            var labs, row, n;
            labs = colors.map(function (c) { return c.lab(); });
            n = colors.length - 1;
            row = binom_row(n);
            I = function (t) {
                var u = 1 - t;
                var lab = [0, 1, 2].map(function (i) { return labs.reduce(
                        function (sum, el, j) { return sum + row[j] * Math.pow( u, (n - j) ) * Math.pow( t, j ) * el[i]; },
                        0
                    ); }
                );
                return new Color(lab, 'lab');
            };
        } else {
            throw new RangeError('No point in running bezier with only one color.');
        }
        return I;
    };

    function bezier$1 (colors) {
        var f = bezier(colors);
        f.scale = function () { return scale(f); };
        return f;
    }

    /*
     * interpolates between a set of colors uzing a bezier spline
     * blend mode formulas taken from https://web.archive.org/web/20180110014946/http://www.venture-ware.com/kevin/coding/lets-learn-math-photoshop-blend-modes/
     */


    var blend = function (bottom, top, mode) {
        if (!blend[mode]) {
            throw new Error('unknown blend mode ' + mode);
        }
        return blend[mode](bottom, top);
    };

    var blend_f = function (f) { return function (bottom, top) {
        var c0 = chroma(top).rgb();
        var c1 = chroma(bottom).rgb();
        return chroma.rgb(f(c0, c1));
    }; };

    var each = function (f) { return function (c0, c1) {
        var out = [];
        out[0] = f(c0[0], c1[0]);
        out[1] = f(c0[1], c1[1]);
        out[2] = f(c0[2], c1[2]);
        return out;
    }; };

    var normal = function (a) { return a; };
    var multiply = function (a, b) { return (a * b) / 255; };
    var darken = function (a, b) { return (a > b ? b : a); };
    var lighten = function (a, b) { return (a > b ? a : b); };
    var screen = function (a, b) { return 255 * (1 - (1 - a / 255) * (1 - b / 255)); };
    var overlay = function (a, b) { return b < 128 ? (2 * a * b) / 255 : 255 * (1 - 2 * (1 - a / 255) * (1 - b / 255)); };
    var burn = function (a, b) { return 255 * (1 - (1 - b / 255) / (a / 255)); };
    var dodge = function (a, b) {
        if (a === 255) { return 255; }
        a = (255 * (b / 255)) / (1 - a / 255);
        return a > 255 ? 255 : a;
    };

    // # add = (a,b) ->
    // #     if (a + b > 255) then 255 else a + b

    blend.normal = blend_f(each(normal));
    blend.multiply = blend_f(each(multiply));
    blend.screen = blend_f(each(screen));
    blend.overlay = blend_f(each(overlay));
    blend.darken = blend_f(each(darken));
    blend.lighten = blend_f(each(lighten));
    blend.dodge = blend_f(each(dodge));
    blend.burn = blend_f(each(burn));

    // cubehelix interpolation
    // based on D.A. Green "A colour scheme for the display of astronomical intensity images"
    // http://astron-soc.in/bulletin/11June/289392011.pdf
    var pow$2 = Math.pow;
    var sin$1 = Math.sin;
    var cos$1 = Math.cos;

    function cubehelix (
        start,
        rotations,
        hue,
        gamma,
        lightness
    ) {
        if ( start === void 0 ) start = 300;
        if ( rotations === void 0 ) rotations = -1.5;
        if ( hue === void 0 ) hue = 1;
        if ( gamma === void 0 ) gamma = 1;
        if ( lightness === void 0 ) lightness = [0, 1];

        var dh = 0,
            dl;
        if (type(lightness) === 'array') {
            dl = lightness[1] - lightness[0];
        } else {
            dl = 0;
            lightness = [lightness, lightness];
        }
        var f = function (fract) {
            var a = TWOPI * ((start + 120) / 360 + rotations * fract);
            var l = pow$2(lightness[0] + dl * fract, gamma);
            var h = dh !== 0 ? hue[0] + fract * dh : hue;
            var amp = (h * l * (1 - l)) / 2;
            var cos_a = cos$1(a);
            var sin_a = sin$1(a);
            var r = l + amp * (-0.14861 * cos_a + 1.78277 * sin_a);
            var g = l + amp * (-0.29227 * cos_a - 0.90649 * sin_a);
            var b = l + amp * (+1.97294 * cos_a);
            return chroma(clip_rgb([r * 255, g * 255, b * 255, 1]));
        };
        f.start = function (s) {
            if (s == null) {
                return start;
            }
            start = s;
            return f;
        };
        f.rotations = function (r) {
            if (r == null) {
                return rotations;
            }
            rotations = r;
            return f;
        };
        f.gamma = function (g) {
            if (g == null) {
                return gamma;
            }
            gamma = g;
            return f;
        };
        f.hue = function (h) {
            if (h == null) {
                return hue;
            }
            hue = h;
            if (type(hue) === 'array') {
                dh = hue[1] - hue[0];
                if (dh === 0) {
                    hue = hue[1];
                }
            } else {
                dh = 0;
            }
            return f;
        };
        f.lightness = function (h) {
            if (h == null) {
                return lightness;
            }
            if (type(h) === 'array') {
                lightness = h;
                dl = h[1] - h[0];
            } else {
                lightness = [h, h];
                dl = 0;
            }
            return f;
        };
        f.scale = function () { return chroma.scale(f); };
        f.hue(hue);
        return f;
    }

    var digits = '0123456789abcdef';

    var floor$1 = Math.floor;
    var random = Math.random;

    function random$1 () {
        var code = '#';
        for (var i = 0; i < 6; i++) {
            code += digits.charAt(floor$1(random() * 16));
        }
        return new Color(code, 'hex');
    }

    var log = Math.log;
    var pow$1 = Math.pow;
    var floor = Math.floor;
    var abs$1 = Math.abs;

    function analyze(data, key) {
        if ( key === void 0 ) key = null;

        var r = {
            min: Number.MAX_VALUE,
            max: Number.MAX_VALUE * -1,
            sum: 0,
            values: [],
            count: 0
        };
        if (type(data) === 'object') {
            data = Object.values(data);
        }
        data.forEach(function (val) {
            if (key && type(val) === 'object') { val = val[key]; }
            if (val !== undefined && val !== null && !isNaN(val)) {
                r.values.push(val);
                r.sum += val;
                if (val < r.min) { r.min = val; }
                if (val > r.max) { r.max = val; }
                r.count += 1;
            }
        });

        r.domain = [r.min, r.max];

        r.limits = function (mode, num) { return limits(r, mode, num); };

        return r;
    }

    function limits(data, mode, num) {
        if ( mode === void 0 ) mode = 'equal';
        if ( num === void 0 ) num = 7;

        if (type(data) == 'array') {
            data = analyze(data);
        }
        var min = data.min;
        var max = data.max;
        var values = data.values.sort(function (a, b) { return a - b; });

        if (num === 1) {
            return [min, max];
        }

        var limits = [];

        if (mode.substr(0, 1) === 'c') {
            // continuous
            limits.push(min);
            limits.push(max);
        }

        if (mode.substr(0, 1) === 'e') {
            // equal interval
            limits.push(min);
            for (var i = 1; i < num; i++) {
                limits.push(min + (i / num) * (max - min));
            }
            limits.push(max);
        } else if (mode.substr(0, 1) === 'l') {
            // log scale
            if (min <= 0) {
                throw new Error(
                    'Logarithmic scales are only possible for values > 0'
                );
            }
            var min_log = Math.LOG10E * log(min);
            var max_log = Math.LOG10E * log(max);
            limits.push(min);
            for (var i$1 = 1; i$1 < num; i$1++) {
                limits.push(pow$1(10, min_log + (i$1 / num) * (max_log - min_log)));
            }
            limits.push(max);
        } else if (mode.substr(0, 1) === 'q') {
            // quantile scale
            limits.push(min);
            for (var i$2 = 1; i$2 < num; i$2++) {
                var p = ((values.length - 1) * i$2) / num;
                var pb = floor(p);
                if (pb === p) {
                    limits.push(values[pb]);
                } else {
                    // p > pb
                    var pr = p - pb;
                    limits.push(values[pb] * (1 - pr) + values[pb + 1] * pr);
                }
            }
            limits.push(max);
        } else if (mode.substr(0, 1) === 'k') {
            // k-means clustering
            /*
            implementation based on
            http://code.google.com/p/figue/source/browse/trunk/figue.js#336
            simplified for 1-d input values
            */
            var cluster;
            var n = values.length;
            var assignments = new Array(n);
            var clusterSizes = new Array(num);
            var repeat = true;
            var nb_iters = 0;
            var centroids = null;

            // get seed values
            centroids = [];
            centroids.push(min);
            for (var i$3 = 1; i$3 < num; i$3++) {
                centroids.push(min + (i$3 / num) * (max - min));
            }
            centroids.push(max);

            while (repeat) {
                // assignment step
                for (var j = 0; j < num; j++) {
                    clusterSizes[j] = 0;
                }
                for (var i$4 = 0; i$4 < n; i$4++) {
                    var value = values[i$4];
                    var mindist = Number.MAX_VALUE;
                    var best = (void 0);
                    for (var j$1 = 0; j$1 < num; j$1++) {
                        var dist = abs$1(centroids[j$1] - value);
                        if (dist < mindist) {
                            mindist = dist;
                            best = j$1;
                        }
                        clusterSizes[best]++;
                        assignments[i$4] = best;
                    }
                }

                // update centroids step
                var newCentroids = new Array(num);
                for (var j$2 = 0; j$2 < num; j$2++) {
                    newCentroids[j$2] = null;
                }
                for (var i$5 = 0; i$5 < n; i$5++) {
                    cluster = assignments[i$5];
                    if (newCentroids[cluster] === null) {
                        newCentroids[cluster] = values[i$5];
                    } else {
                        newCentroids[cluster] += values[i$5];
                    }
                }
                for (var j$3 = 0; j$3 < num; j$3++) {
                    newCentroids[j$3] *= 1 / clusterSizes[j$3];
                }

                // check convergence
                repeat = false;
                for (var j$4 = 0; j$4 < num; j$4++) {
                    if (newCentroids[j$4] !== centroids[j$4]) {
                        repeat = true;
                        break;
                    }
                }

                centroids = newCentroids;
                nb_iters++;

                if (nb_iters > 200) {
                    repeat = false;
                }
            }

            // finished k-means clustering
            // the next part is borrowed from gabrielflor.it
            var kClusters = {};
            for (var j$5 = 0; j$5 < num; j$5++) {
                kClusters[j$5] = [];
            }
            for (var i$6 = 0; i$6 < n; i$6++) {
                cluster = assignments[i$6];
                kClusters[cluster].push(values[i$6]);
            }
            var tmpKMeansBreaks = [];
            for (var j$6 = 0; j$6 < num; j$6++) {
                tmpKMeansBreaks.push(kClusters[j$6][0]);
                tmpKMeansBreaks.push(kClusters[j$6][kClusters[j$6].length - 1]);
            }
            tmpKMeansBreaks = tmpKMeansBreaks.sort(function (a, b) { return a - b; });
            limits.push(tmpKMeansBreaks[0]);
            for (var i$7 = 1; i$7 < tmpKMeansBreaks.length; i$7 += 2) {
                var v = tmpKMeansBreaks[i$7];
                if (!isNaN(v) && limits.indexOf(v) === -1) {
                    limits.push(v);
                }
            }
        }
        return limits;
    }

    function contrast (a, b) {
        // WCAG contrast ratio
        // see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef
        a = new Color(a);
        b = new Color(b);
        var l1 = a.luminance();
        var l2 = b.luminance();
        return l1 > l2 ? (l1 + 0.05) / (l2 + 0.05) : (l2 + 0.05) / (l1 + 0.05);
    }

    var sqrt = Math.sqrt;
    var pow = Math.pow;
    var min = Math.min;
    var max = Math.max;
    var atan2 = Math.atan2;
    var abs = Math.abs;
    var cos = Math.cos;
    var sin = Math.sin;
    var exp = Math.exp;
    var PI = Math.PI;

    function deltaE (a, b, Kl, Kc, Kh) {
        if ( Kl === void 0 ) Kl = 1;
        if ( Kc === void 0 ) Kc = 1;
        if ( Kh === void 0 ) Kh = 1;

        // Delta E (CIE 2000)
        // see http://www.brucelindbloom.com/index.html?Eqn_DeltaE_CIE2000.html
        var rad2deg = function (rad) {
            return (360 * rad) / (2 * PI);
        };
        var deg2rad = function (deg) {
            return (2 * PI * deg) / 360;
        };
        a = new Color(a);
        b = new Color(b);
        var ref = Array.from(a.lab());
        var L1 = ref[0];
        var a1 = ref[1];
        var b1 = ref[2];
        var ref$1 = Array.from(b.lab());
        var L2 = ref$1[0];
        var a2 = ref$1[1];
        var b2 = ref$1[2];
        var avgL = (L1 + L2) / 2;
        var C1 = sqrt(pow(a1, 2) + pow(b1, 2));
        var C2 = sqrt(pow(a2, 2) + pow(b2, 2));
        var avgC = (C1 + C2) / 2;
        var G = 0.5 * (1 - sqrt(pow(avgC, 7) / (pow(avgC, 7) + pow(25, 7))));
        var a1p = a1 * (1 + G);
        var a2p = a2 * (1 + G);
        var C1p = sqrt(pow(a1p, 2) + pow(b1, 2));
        var C2p = sqrt(pow(a2p, 2) + pow(b2, 2));
        var avgCp = (C1p + C2p) / 2;
        var arctan1 = rad2deg(atan2(b1, a1p));
        var arctan2 = rad2deg(atan2(b2, a2p));
        var h1p = arctan1 >= 0 ? arctan1 : arctan1 + 360;
        var h2p = arctan2 >= 0 ? arctan2 : arctan2 + 360;
        var avgHp =
            abs(h1p - h2p) > 180 ? (h1p + h2p + 360) / 2 : (h1p + h2p) / 2;
        var T =
            1 -
            0.17 * cos(deg2rad(avgHp - 30)) +
            0.24 * cos(deg2rad(2 * avgHp)) +
            0.32 * cos(deg2rad(3 * avgHp + 6)) -
            0.2 * cos(deg2rad(4 * avgHp - 63));
        var deltaHp = h2p - h1p;
        deltaHp =
            abs(deltaHp) <= 180
                ? deltaHp
                : h2p <= h1p
                  ? deltaHp + 360
                  : deltaHp - 360;
        deltaHp = 2 * sqrt(C1p * C2p) * sin(deg2rad(deltaHp) / 2);
        var deltaL = L2 - L1;
        var deltaCp = C2p - C1p;
        var sl = 1 + (0.015 * pow(avgL - 50, 2)) / sqrt(20 + pow(avgL - 50, 2));
        var sc = 1 + 0.045 * avgCp;
        var sh = 1 + 0.015 * avgCp * T;
        var deltaTheta = 30 * exp(-pow((avgHp - 275) / 25, 2));
        var Rc = 2 * sqrt(pow(avgCp, 7) / (pow(avgCp, 7) + pow(25, 7)));
        var Rt = -Rc * sin(2 * deg2rad(deltaTheta));
        var result = sqrt(
            pow(deltaL / (Kl * sl), 2) +
                pow(deltaCp / (Kc * sc), 2) +
                pow(deltaHp / (Kh * sh), 2) +
                Rt * (deltaCp / (Kc * sc)) * (deltaHp / (Kh * sh))
        );
        return max(0, min(100, result));
    }

    // simple Euclidean distance
    function distance (a, b, mode) {
        if ( mode === void 0 ) mode = 'lab';

        // Delta E (CIE 1976)
        // see http://www.brucelindbloom.com/index.html?Equations.html
        a = new Color(a);
        b = new Color(b);
        var l1 = a.get(mode);
        var l2 = b.get(mode);
        var sum_sq = 0;
        for (var i in l1) {
            var d = (l1[i] || 0) - (l2[i] || 0);
            sum_sq += d * d;
        }
        return Math.sqrt(sum_sq);
    }

    function valid () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        try {
            new (Function.prototype.bind.apply( Color, [ null ].concat( args) ));
            return true;
            // eslint-disable-next-line
        } catch (e) {
            return false;
        }
    }

    // some pre-defined color scales:

    var scales = {
        cool: function cool() {
            return scale([chroma.hsl(180, 1, 0.9), chroma.hsl(250, 0.7, 0.4)]);
        },
        hot: function hot() {
            return scale(['#000', '#f00', '#ff0', '#fff']).mode(
                'rgb'
            );
        }
    };

    /**
        ColorBrewer colors for chroma.js

        Copyright (c) 2002 Cynthia Brewer, Mark Harrower, and The
        Pennsylvania State University.

        Licensed under the Apache License, Version 2.0 (the "License");
        you may not use this file except in compliance with the License.
        You may obtain a copy of the License at
        http://www.apache.org/licenses/LICENSE-2.0

        Unless required by applicable law or agreed to in writing, software distributed
        under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
        CONDITIONS OF ANY KIND, either express or implied. See the License for the
        specific language governing permissions and limitations under the License.
    */

    var colorbrewer = {
        // sequential
        OrRd: ['#fff7ec', '#fee8c8', '#fdd49e', '#fdbb84', '#fc8d59', '#ef6548', '#d7301f', '#b30000', '#7f0000'],
        PuBu: ['#fff7fb', '#ece7f2', '#d0d1e6', '#a6bddb', '#74a9cf', '#3690c0', '#0570b0', '#045a8d', '#023858'],
        BuPu: ['#f7fcfd', '#e0ecf4', '#bfd3e6', '#9ebcda', '#8c96c6', '#8c6bb1', '#88419d', '#810f7c', '#4d004b'],
        Oranges: ['#fff5eb', '#fee6ce', '#fdd0a2', '#fdae6b', '#fd8d3c', '#f16913', '#d94801', '#a63603', '#7f2704'],
        BuGn: ['#f7fcfd', '#e5f5f9', '#ccece6', '#99d8c9', '#66c2a4', '#41ae76', '#238b45', '#006d2c', '#00441b'],
        YlOrBr: ['#ffffe5', '#fff7bc', '#fee391', '#fec44f', '#fe9929', '#ec7014', '#cc4c02', '#993404', '#662506'],
        YlGn: ['#ffffe5', '#f7fcb9', '#d9f0a3', '#addd8e', '#78c679', '#41ab5d', '#238443', '#006837', '#004529'],
        Reds: ['#fff5f0', '#fee0d2', '#fcbba1', '#fc9272', '#fb6a4a', '#ef3b2c', '#cb181d', '#a50f15', '#67000d'],
        RdPu: ['#fff7f3', '#fde0dd', '#fcc5c0', '#fa9fb5', '#f768a1', '#dd3497', '#ae017e', '#7a0177', '#49006a'],
        Greens: ['#f7fcf5', '#e5f5e0', '#c7e9c0', '#a1d99b', '#74c476', '#41ab5d', '#238b45', '#006d2c', '#00441b'],
        YlGnBu: ['#ffffd9', '#edf8b1', '#c7e9b4', '#7fcdbb', '#41b6c4', '#1d91c0', '#225ea8', '#253494', '#081d58'],
        Purples: ['#fcfbfd', '#efedf5', '#dadaeb', '#bcbddc', '#9e9ac8', '#807dba', '#6a51a3', '#54278f', '#3f007d'],
        GnBu: ['#f7fcf0', '#e0f3db', '#ccebc5', '#a8ddb5', '#7bccc4', '#4eb3d3', '#2b8cbe', '#0868ac', '#084081'],
        Greys: ['#ffffff', '#f0f0f0', '#d9d9d9', '#bdbdbd', '#969696', '#737373', '#525252', '#252525', '#000000'],
        YlOrRd: ['#ffffcc', '#ffeda0', '#fed976', '#feb24c', '#fd8d3c', '#fc4e2a', '#e31a1c', '#bd0026', '#800026'],
        PuRd: ['#f7f4f9', '#e7e1ef', '#d4b9da', '#c994c7', '#df65b0', '#e7298a', '#ce1256', '#980043', '#67001f'],
        Blues: ['#f7fbff', '#deebf7', '#c6dbef', '#9ecae1', '#6baed6', '#4292c6', '#2171b5', '#08519c', '#08306b'],
        PuBuGn: ['#fff7fb', '#ece2f0', '#d0d1e6', '#a6bddb', '#67a9cf', '#3690c0', '#02818a', '#016c59', '#014636'],
        Viridis: ['#440154', '#482777', '#3f4a8a', '#31678e', '#26838f', '#1f9d8a', '#6cce5a', '#b6de2b', '#fee825'],

        // diverging
        Spectral: ['#9e0142', '#d53e4f', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#e6f598', '#abdda4', '#66c2a5', '#3288bd', '#5e4fa2'],
        RdYlGn: ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#d9ef8b', '#a6d96a', '#66bd63', '#1a9850', '#006837'],
        RdBu: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#f7f7f7', '#d1e5f0', '#92c5de', '#4393c3', '#2166ac', '#053061'],
        PiYG: ['#8e0152', '#c51b7d', '#de77ae', '#f1b6da', '#fde0ef', '#f7f7f7', '#e6f5d0', '#b8e186', '#7fbc41', '#4d9221', '#276419'],
        PRGn: ['#40004b', '#762a83', '#9970ab', '#c2a5cf', '#e7d4e8', '#f7f7f7', '#d9f0d3', '#a6dba0', '#5aae61', '#1b7837', '#00441b'],
        RdYlBu: ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee090', '#ffffbf', '#e0f3f8', '#abd9e9', '#74add1', '#4575b4', '#313695'],
        BrBG: ['#543005', '#8c510a', '#bf812d', '#dfc27d', '#f6e8c3', '#f5f5f5', '#c7eae5', '#80cdc1', '#35978f', '#01665e', '#003c30'],
        RdGy: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#ffffff', '#e0e0e0', '#bababa', '#878787', '#4d4d4d', '#1a1a1a'],
        PuOr: ['#7f3b08', '#b35806', '#e08214', '#fdb863', '#fee0b6', '#f7f7f7', '#d8daeb', '#b2abd2', '#8073ac', '#542788', '#2d004b'],

        // qualitative
        Set2: ['#66c2a5', '#fc8d62', '#8da0cb', '#e78ac3', '#a6d854', '#ffd92f', '#e5c494', '#b3b3b3'],
        Accent: ['#7fc97f', '#beaed4', '#fdc086', '#ffff99', '#386cb0', '#f0027f', '#bf5b17', '#666666'],
        Set1: ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33', '#a65628', '#f781bf', '#999999'],
        Set3: ['#8dd3c7', '#ffffb3', '#bebada', '#fb8072', '#80b1d3', '#fdb462', '#b3de69', '#fccde5', '#d9d9d9', '#bc80bd', '#ccebc5', '#ffed6f'],
        Dark2: ['#1b9e77', '#d95f02', '#7570b3', '#e7298a', '#66a61e', '#e6ab02', '#a6761d', '#666666'],
        Paired: ['#a6cee3', '#1f78b4', '#b2df8a', '#33a02c', '#fb9a99', '#e31a1c', '#fdbf6f', '#ff7f00', '#cab2d6', '#6a3d9a', '#ffff99', '#b15928'],
        Pastel2: ['#b3e2cd', '#fdcdac', '#cbd5e8', '#f4cae4', '#e6f5c9', '#fff2ae', '#f1e2cc', '#cccccc'],
        Pastel1: ['#fbb4ae', '#b3cde3', '#ccebc5', '#decbe4', '#fed9a6', '#ffffcc', '#e5d8bd', '#fddaec', '#f2f2f2']
    };

    // add lowercase aliases for case-insensitive matches
    for (var i = 0, list = Object.keys(colorbrewer); i < list.length; i += 1) {
        var key = list[i];

        colorbrewer[key.toLowerCase()] = colorbrewer[key];
    }

    Object.assign(chroma, {
        average: average,
        bezier: bezier$1,
        blend: blend,
        cubehelix: cubehelix,
        mix: mix,
        interpolate: mix,
        random: random$1,
        scale: scale,
        analyze: analyze,
        contrast: contrast,
        deltaE: deltaE,
        distance: distance,
        limits: limits,
        valid: valid,
        scales: scales,
        input: input,
        colors: w3cx11,
        brewer: colorbrewer
    });

    return chroma;

}));


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./css/dark-theme.css":
/*!******************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./css/dark-theme.css ***!
  \******************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/* Dark Theme CSS for RoadTrafficSimulator */
:root {
  --bg-primary: #1a1a1a;
  --bg-secondary: #2d2d2d;
  --bg-panel: #333333;
  --border-color: #404040;
  --text-primary: #ffffff;
  --text-secondary: #b0b0b0;
  --btn-primary-bg: #375a7f;
  --btn-primary-hover: #2e4c6d;
  --btn-success-bg: #00bc8c;
  --btn-success-hover: #00a085;
  --btn-info-bg: #3498db;
  --btn-info-hover: #2980b9;
  --btn-warning-bg: #f39c12;
  --btn-warning-hover: #e67e22;
  --btn-secondary-bg: #444444;
  --btn-secondary-hover: #555555;
  --btn-danger-bg: #e74c3c;
  --btn-danger-hover: #c0392b;
}

/* Make sure the dark theme is always applied */
body, html {
  background-color: var(--bg-primary) !important;
  color: var(--text-primary) !important;
}

#app-container {
  background-color: var(--bg-primary) !important;
}

.simulation-page,
.builder-page {
  background-color: var(--bg-primary) !important;
}

.page-header {
  background-color: var(--bg-secondary) !important;
  border-bottom: 1px solid var(--border-color) !important;
}

.page-header h2 {
  color: var(--text-primary) !important;
}

.sidebar {
  background-color: var(--bg-secondary) !important;
  border-right: 1px solid var(--border-color) !important;
}

.panel {
  background-color: var(--bg-panel) !important;
  border: 1px solid var(--border-color) !important;
  color: var(--text-primary) !important;
}

.panel h3 {
  color: var(--text-primary) !important;
  border-bottom: 1px solid var(--border-color) !important;
}

.visualizer-area {
  background-color: var(--bg-primary) !important;
}

.visualizer-area canvas {
  background-color: var(--bg-primary) !important;
  border: 1px solid var(--border-color) !important;
}

/* Button styles */
.btn-primary { 
  background-color: var(--btn-primary-bg) !important; 
  color: var(--text-primary) !important; 
  border: 1px solid var(--btn-primary-bg) !important;
}
.btn-primary:hover { 
  background-color: var(--btn-primary-hover) !important; 
}

.btn-success { 
  background-color: var(--btn-success-bg) !important; 
  color: var(--text-primary) !important; 
  border: 1px solid var(--btn-success-bg) !important;
}
.btn-success:hover { 
  background-color: var(--btn-success-hover) !important; 
}

.btn-info { 
  background-color: var(--btn-info-bg) !important; 
  color: var(--text-primary) !important; 
  border: 1px solid var(--btn-info-bg) !important;
}
.btn-info:hover { 
  background-color: var(--btn-info-hover) !important; 
}

.btn-warning { 
  background-color: var(--btn-warning-bg) !important; 
  color: #212529 !important; 
  border: 1px solid var(--btn-warning-bg) !important;
}
.btn-warning:hover { 
  background-color: var(--btn-warning-hover) !important; 
}

.btn-secondary { 
  background-color: var(--btn-secondary-bg) !important; 
  color: var(--text-primary) !important; 
  border: 1px solid var(--border-color) !important;
}
.btn-secondary:hover { 
  background-color: var(--btn-secondary-hover) !important; 
}

.btn-danger { 
  background-color: var(--btn-danger-bg) !important; 
  color: var(--text-primary) !important; 
  border: 1px solid var(--btn-danger-bg) !important;
}
.btn-danger:hover { 
  background-color: var(--btn-danger-hover) !important; 
}

/* Make all form inputs match dark theme */
input, select, textarea, .form-control {
  background-color: #404040 !important;
  color: var(--text-primary) !important;
  border: 1px solid var(--border-color) !important;
}

input:focus, select:focus, textarea:focus, .form-control:focus {
  border-color: var(--btn-primary-bg) !important;
  box-shadow: 0 0 0 2px rgba(55, 90, 127, 0.25) !important;
}

/* Ensure dark theme for all dialogs */
.modal, .modal-content, .dialog {
  background-color: var(--bg-secondary) !important;
  color: var(--text-primary) !important;
  border: 1px solid var(--border-color) !important;
}

/* Handle text colors */
h1, h2, h3, h4, h5, h6, p, span, div, label {
  color: var(--text-primary) !important;
}

.text-muted {
  color: var(--text-secondary) !important;
}
`, "",{"version":3,"sources":["webpack://./css/dark-theme.css"],"names":[],"mappings":"AAAA,4CAA4C;AAC5C;EACE,qBAAqB;EACrB,uBAAuB;EACvB,mBAAmB;EACnB,uBAAuB;EACvB,uBAAuB;EACvB,yBAAyB;EACzB,yBAAyB;EACzB,4BAA4B;EAC5B,yBAAyB;EACzB,4BAA4B;EAC5B,sBAAsB;EACtB,yBAAyB;EACzB,yBAAyB;EACzB,4BAA4B;EAC5B,2BAA2B;EAC3B,8BAA8B;EAC9B,wBAAwB;EACxB,2BAA2B;AAC7B;;AAEA,+CAA+C;AAC/C;EACE,8CAA8C;EAC9C,qCAAqC;AACvC;;AAEA;EACE,8CAA8C;AAChD;;AAEA;;EAEE,8CAA8C;AAChD;;AAEA;EACE,gDAAgD;EAChD,uDAAuD;AACzD;;AAEA;EACE,qCAAqC;AACvC;;AAEA;EACE,gDAAgD;EAChD,sDAAsD;AACxD;;AAEA;EACE,4CAA4C;EAC5C,gDAAgD;EAChD,qCAAqC;AACvC;;AAEA;EACE,qCAAqC;EACrC,uDAAuD;AACzD;;AAEA;EACE,8CAA8C;AAChD;;AAEA;EACE,8CAA8C;EAC9C,gDAAgD;AAClD;;AAEA,kBAAkB;AAClB;EACE,kDAAkD;EAClD,qCAAqC;EACrC,kDAAkD;AACpD;AACA;EACE,qDAAqD;AACvD;;AAEA;EACE,kDAAkD;EAClD,qCAAqC;EACrC,kDAAkD;AACpD;AACA;EACE,qDAAqD;AACvD;;AAEA;EACE,+CAA+C;EAC/C,qCAAqC;EACrC,+CAA+C;AACjD;AACA;EACE,kDAAkD;AACpD;;AAEA;EACE,kDAAkD;EAClD,yBAAyB;EACzB,kDAAkD;AACpD;AACA;EACE,qDAAqD;AACvD;;AAEA;EACE,oDAAoD;EACpD,qCAAqC;EACrC,gDAAgD;AAClD;AACA;EACE,uDAAuD;AACzD;;AAEA;EACE,iDAAiD;EACjD,qCAAqC;EACrC,iDAAiD;AACnD;AACA;EACE,oDAAoD;AACtD;;AAEA,0CAA0C;AAC1C;EACE,oCAAoC;EACpC,qCAAqC;EACrC,gDAAgD;AAClD;;AAEA;EACE,8CAA8C;EAC9C,wDAAwD;AAC1D;;AAEA,sCAAsC;AACtC;EACE,gDAAgD;EAChD,qCAAqC;EACrC,gDAAgD;AAClD;;AAEA,uBAAuB;AACvB;EACE,qCAAqC;AACvC;;AAEA;EACE,uCAAuC;AACzC","sourcesContent":["/* Dark Theme CSS for RoadTrafficSimulator */\n:root {\n  --bg-primary: #1a1a1a;\n  --bg-secondary: #2d2d2d;\n  --bg-panel: #333333;\n  --border-color: #404040;\n  --text-primary: #ffffff;\n  --text-secondary: #b0b0b0;\n  --btn-primary-bg: #375a7f;\n  --btn-primary-hover: #2e4c6d;\n  --btn-success-bg: #00bc8c;\n  --btn-success-hover: #00a085;\n  --btn-info-bg: #3498db;\n  --btn-info-hover: #2980b9;\n  --btn-warning-bg: #f39c12;\n  --btn-warning-hover: #e67e22;\n  --btn-secondary-bg: #444444;\n  --btn-secondary-hover: #555555;\n  --btn-danger-bg: #e74c3c;\n  --btn-danger-hover: #c0392b;\n}\n\n/* Make sure the dark theme is always applied */\nbody, html {\n  background-color: var(--bg-primary) !important;\n  color: var(--text-primary) !important;\n}\n\n#app-container {\n  background-color: var(--bg-primary) !important;\n}\n\n.simulation-page,\n.builder-page {\n  background-color: var(--bg-primary) !important;\n}\n\n.page-header {\n  background-color: var(--bg-secondary) !important;\n  border-bottom: 1px solid var(--border-color) !important;\n}\n\n.page-header h2 {\n  color: var(--text-primary) !important;\n}\n\n.sidebar {\n  background-color: var(--bg-secondary) !important;\n  border-right: 1px solid var(--border-color) !important;\n}\n\n.panel {\n  background-color: var(--bg-panel) !important;\n  border: 1px solid var(--border-color) !important;\n  color: var(--text-primary) !important;\n}\n\n.panel h3 {\n  color: var(--text-primary) !important;\n  border-bottom: 1px solid var(--border-color) !important;\n}\n\n.visualizer-area {\n  background-color: var(--bg-primary) !important;\n}\n\n.visualizer-area canvas {\n  background-color: var(--bg-primary) !important;\n  border: 1px solid var(--border-color) !important;\n}\n\n/* Button styles */\n.btn-primary { \n  background-color: var(--btn-primary-bg) !important; \n  color: var(--text-primary) !important; \n  border: 1px solid var(--btn-primary-bg) !important;\n}\n.btn-primary:hover { \n  background-color: var(--btn-primary-hover) !important; \n}\n\n.btn-success { \n  background-color: var(--btn-success-bg) !important; \n  color: var(--text-primary) !important; \n  border: 1px solid var(--btn-success-bg) !important;\n}\n.btn-success:hover { \n  background-color: var(--btn-success-hover) !important; \n}\n\n.btn-info { \n  background-color: var(--btn-info-bg) !important; \n  color: var(--text-primary) !important; \n  border: 1px solid var(--btn-info-bg) !important;\n}\n.btn-info:hover { \n  background-color: var(--btn-info-hover) !important; \n}\n\n.btn-warning { \n  background-color: var(--btn-warning-bg) !important; \n  color: #212529 !important; \n  border: 1px solid var(--btn-warning-bg) !important;\n}\n.btn-warning:hover { \n  background-color: var(--btn-warning-hover) !important; \n}\n\n.btn-secondary { \n  background-color: var(--btn-secondary-bg) !important; \n  color: var(--text-primary) !important; \n  border: 1px solid var(--border-color) !important;\n}\n.btn-secondary:hover { \n  background-color: var(--btn-secondary-hover) !important; \n}\n\n.btn-danger { \n  background-color: var(--btn-danger-bg) !important; \n  color: var(--text-primary) !important; \n  border: 1px solid var(--btn-danger-bg) !important;\n}\n.btn-danger:hover { \n  background-color: var(--btn-danger-hover) !important; \n}\n\n/* Make all form inputs match dark theme */\ninput, select, textarea, .form-control {\n  background-color: #404040 !important;\n  color: var(--text-primary) !important;\n  border: 1px solid var(--border-color) !important;\n}\n\ninput:focus, select:focus, textarea:focus, .form-control:focus {\n  border-color: var(--btn-primary-bg) !important;\n  box-shadow: 0 0 0 2px rgba(55, 90, 127, 0.25) !important;\n}\n\n/* Ensure dark theme for all dialogs */\n.modal, .modal-content, .dialog {\n  background-color: var(--bg-secondary) !important;\n  color: var(--text-primary) !important;\n  border: 1px solid var(--border-color) !important;\n}\n\n/* Handle text colors */\nh1, h2, h3, h4, h5, h6, p, span, div, label {\n  color: var(--text-primary) !important;\n}\n\n.text-muted {\n  color: var(--text-secondary) !important;\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./css/dat-gui.css":
/*!***************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./css/dat-gui.css ***!
  \***************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/* dat-gui overrides for single panel layout */

.dg {
    color: #93a1a1 !important;
    text-shadow: none !important;
    z-index: 1000 !important;
    position: fixed !important;
    top: 10px !important;
    right: 10px !important;
    max-width: 280px !important;
    width: 280px !important;
    background: rgba(0, 43, 54, 0.95) !important;
    border: 2px solid #073642 !important;
    border-radius: 6px !important;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4) !important;
}

/* Main container - single panel */
.dg.main {
    overflow: visible !important;
    height: auto !important;
    max-height: 85vh !important;
    overflow-y: auto !important;
}

/* List styling for clean single panel */
.dg ul {
    list-style: none !important;
    margin: 0 !important;
    padding: 8px !important;
    clear: both !important;
    position: relative !important;
}

/* Individual control items */
.dg li {
    clear: both !important;
    position: relative !important;
    line-height: 32px !important;
    height: auto !important;
    min-height: 32px !important;
    background: #002b36 !important;
    border-bottom: 1px solid #073642 !important;
    margin-bottom: 3px !important;
    border-radius: 4px !important;
    padding: 2px 4px !important;
}

.dg li:last-child {
    border-bottom: none !important;
    margin-bottom: 0 !important;
}

/* Remove folder styling since we're not using folders */
.dg .folder {
    border: none !important;
    margin: 0 !important;
    padding: 0 !important;
    background: transparent !important;
}
/* Close button styling */
.dg.main .close-button {
    background-color: #002b36 !important;
    border-radius: 4px !important;
}

.dg.main .close-button:hover,
.dg .cr.function:hover,
.dg .cr.boolean:hover {
    background: #073642 !important;
}

/* Input field styling */
.dg .c input[type=text] {
    background: #073642 !important;
    color: #93a1a1 !important;
    border: 1px solid #586e75 !important;
    border-radius: 3px !important;
    padding: 2px 4px !important;
}

.dg .c input[type=text]:hover {
    background: #586e75 !important;
    border-color: #93a1a1 !important;
}

.dg .c input[type=text]:focus {
    background: #073642 !important;
    border-color: #268bd2 !important;
    outline: none !important;
}

/* Slider styling */
.dg .c .slider {
    background: #073642 !important;
    border-radius: 3px !important;
}

.dg .c .slider:hover {
    background: #586e75 !important;
}

/* Button styling for functions */
.dg .cr.function {
    border-radius: 3px !important;
    background: #002b36 !important;
}

.dg .cr.function:hover {
    background: #073642 !important;
}

/* Property name styling */
.dg .property-name {
    color: #93a1a1 !important;
    font-weight: normal !important;
}

/* Control row padding */
.dg .cr {
    padding: 4px 8px !important;
}

/* Number input styling */
.dg .c input[type=number] {
    background: #073642 !important;
    color: #93a1a1 !important;
    border: 1px solid #586e75 !important;
    border-radius: 3px !important;
}

/* Checkbox styling */
.dg .c input[type=checkbox] {
    margin-right: 8px !important;
}

/* Slider styling */
.dg .c .slider {
    background: #073642 !important;
}

.dg .c .slider:hover {
    background: #586e75 !important;
}
`, "",{"version":3,"sources":["webpack://./css/dat-gui.css"],"names":[],"mappings":"AAAA,8CAA8C;;AAE9C;IACI,yBAAyB;IACzB,4BAA4B;IAC5B,wBAAwB;IACxB,0BAA0B;IAC1B,oBAAoB;IACpB,sBAAsB;IACtB,2BAA2B;IAC3B,uBAAuB;IACvB,4CAA4C;IAC5C,oCAAoC;IACpC,6BAA6B;IAC7B,oDAAoD;AACxD;;AAEA,kCAAkC;AAClC;IACI,4BAA4B;IAC5B,uBAAuB;IACvB,2BAA2B;IAC3B,2BAA2B;AAC/B;;AAEA,wCAAwC;AACxC;IACI,2BAA2B;IAC3B,oBAAoB;IACpB,uBAAuB;IACvB,sBAAsB;IACtB,6BAA6B;AACjC;;AAEA,6BAA6B;AAC7B;IACI,sBAAsB;IACtB,6BAA6B;IAC7B,4BAA4B;IAC5B,uBAAuB;IACvB,2BAA2B;IAC3B,8BAA8B;IAC9B,2CAA2C;IAC3C,6BAA6B;IAC7B,6BAA6B;IAC7B,2BAA2B;AAC/B;;AAEA;IACI,8BAA8B;IAC9B,2BAA2B;AAC/B;;AAEA,wDAAwD;AACxD;IACI,uBAAuB;IACvB,oBAAoB;IACpB,qBAAqB;IACrB,kCAAkC;AACtC;AACA,yBAAyB;AACzB;IACI,oCAAoC;IACpC,6BAA6B;AACjC;;AAEA;;;IAGI,8BAA8B;AAClC;;AAEA,wBAAwB;AACxB;IACI,8BAA8B;IAC9B,yBAAyB;IACzB,oCAAoC;IACpC,6BAA6B;IAC7B,2BAA2B;AAC/B;;AAEA;IACI,8BAA8B;IAC9B,gCAAgC;AACpC;;AAEA;IACI,8BAA8B;IAC9B,gCAAgC;IAChC,wBAAwB;AAC5B;;AAEA,mBAAmB;AACnB;IACI,8BAA8B;IAC9B,6BAA6B;AACjC;;AAEA;IACI,8BAA8B;AAClC;;AAEA,iCAAiC;AACjC;IACI,6BAA6B;IAC7B,8BAA8B;AAClC;;AAEA;IACI,8BAA8B;AAClC;;AAEA,0BAA0B;AAC1B;IACI,yBAAyB;IACzB,8BAA8B;AAClC;;AAEA,wBAAwB;AACxB;IACI,2BAA2B;AAC/B;;AAEA,yBAAyB;AACzB;IACI,8BAA8B;IAC9B,yBAAyB;IACzB,oCAAoC;IACpC,6BAA6B;AACjC;;AAEA,qBAAqB;AACrB;IACI,4BAA4B;AAChC;;AAEA,mBAAmB;AACnB;IACI,8BAA8B;AAClC;;AAEA;IACI,8BAA8B;AAClC","sourcesContent":["/* dat-gui overrides for single panel layout */\n\n.dg {\n    color: #93a1a1 !important;\n    text-shadow: none !important;\n    z-index: 1000 !important;\n    position: fixed !important;\n    top: 10px !important;\n    right: 10px !important;\n    max-width: 280px !important;\n    width: 280px !important;\n    background: rgba(0, 43, 54, 0.95) !important;\n    border: 2px solid #073642 !important;\n    border-radius: 6px !important;\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4) !important;\n}\n\n/* Main container - single panel */\n.dg.main {\n    overflow: visible !important;\n    height: auto !important;\n    max-height: 85vh !important;\n    overflow-y: auto !important;\n}\n\n/* List styling for clean single panel */\n.dg ul {\n    list-style: none !important;\n    margin: 0 !important;\n    padding: 8px !important;\n    clear: both !important;\n    position: relative !important;\n}\n\n/* Individual control items */\n.dg li {\n    clear: both !important;\n    position: relative !important;\n    line-height: 32px !important;\n    height: auto !important;\n    min-height: 32px !important;\n    background: #002b36 !important;\n    border-bottom: 1px solid #073642 !important;\n    margin-bottom: 3px !important;\n    border-radius: 4px !important;\n    padding: 2px 4px !important;\n}\n\n.dg li:last-child {\n    border-bottom: none !important;\n    margin-bottom: 0 !important;\n}\n\n/* Remove folder styling since we're not using folders */\n.dg .folder {\n    border: none !important;\n    margin: 0 !important;\n    padding: 0 !important;\n    background: transparent !important;\n}\n/* Close button styling */\n.dg.main .close-button {\n    background-color: #002b36 !important;\n    border-radius: 4px !important;\n}\n\n.dg.main .close-button:hover,\n.dg .cr.function:hover,\n.dg .cr.boolean:hover {\n    background: #073642 !important;\n}\n\n/* Input field styling */\n.dg .c input[type=text] {\n    background: #073642 !important;\n    color: #93a1a1 !important;\n    border: 1px solid #586e75 !important;\n    border-radius: 3px !important;\n    padding: 2px 4px !important;\n}\n\n.dg .c input[type=text]:hover {\n    background: #586e75 !important;\n    border-color: #93a1a1 !important;\n}\n\n.dg .c input[type=text]:focus {\n    background: #073642 !important;\n    border-color: #268bd2 !important;\n    outline: none !important;\n}\n\n/* Slider styling */\n.dg .c .slider {\n    background: #073642 !important;\n    border-radius: 3px !important;\n}\n\n.dg .c .slider:hover {\n    background: #586e75 !important;\n}\n\n/* Button styling for functions */\n.dg .cr.function {\n    border-radius: 3px !important;\n    background: #002b36 !important;\n}\n\n.dg .cr.function:hover {\n    background: #073642 !important;\n}\n\n/* Property name styling */\n.dg .property-name {\n    color: #93a1a1 !important;\n    font-weight: normal !important;\n}\n\n/* Control row padding */\n.dg .cr {\n    padding: 4px 8px !important;\n}\n\n/* Number input styling */\n.dg .c input[type=number] {\n    background: #073642 !important;\n    color: #93a1a1 !important;\n    border: 1px solid #586e75 !important;\n    border-radius: 3px !important;\n}\n\n/* Checkbox styling */\n.dg .c input[type=checkbox] {\n    margin-right: 8px !important;\n}\n\n/* Slider styling */\n.dg .c .slider {\n    background: #073642 !important;\n}\n\n.dg .c .slider:hover {\n    background: #586e75 !important;\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./css/kpi-visualization.css":
/*!*************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./css/kpi-visualization.css ***!
  \*************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/* KPI Visualization Component Styles */

.kpi-visualization {
  padding: 20px;
  background: #1a1a1a;
  color: #ffffff;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
}

/* Header */
.kpi-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 24px;
  padding-bottom: 16px;
  border-bottom: 1px solid #404040;
}

.kpi-header h3 {
  margin: 0;
  color: #ffffff;
  font-size: 24px;
  font-weight: 600;
}

.kpi-controls {
  display: flex;
  gap: 8px;
}

.kpi-controls .btn {
  padding: 6px 12px;
  font-size: 12px;
  border-radius: 4px;
  border: none;
  cursor: pointer;
  transition: all 0.2s ease;
}

.kpi-controls .btn:hover {
  opacity: 0.8;
  transform: translateY(-1px);
}

/* Summary Cards */
.kpi-summary {
  margin-bottom: 32px;
}

.summary-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 16px;
  margin-bottom: 24px;
}

.summary-card {
  background: #2d2d2d;
  border: 1px solid #404040;
  border-radius: 8px;
  padding: 20px;
  text-align: center;
  transition: all 0.2s ease;
}

.summary-card:hover {
  border-color: #2196F3;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(33, 150, 243, 0.2);
}

.summary-card .card-value {
  font-size: 32px;
  font-weight: 700;
  color: #2196F3;
  margin-bottom: 8px;
}

.summary-card .card-label {
  font-size: 14px;
  color: #cccccc;
  margin-bottom: 4px;
}

.summary-card .card-change {
  font-size: 12px;
  font-weight: 500;
}

.summary-card .card-change.positive {
  color: #4CAF50;
}

.summary-card .card-change.negative {
  color: #F44336;
}

.summary-card .card-change.neutral {
  color: #999999;
}

/* Charts */
.kpi-charts {
  margin-bottom: 32px;
}

.chart-section h4 {
  margin-bottom: 20px;
  color: #ffffff;
  font-size: 20px;
  font-weight: 600;
}

.chart-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
  gap: 20px;
}

.chart-container {
  background: #2d2d2d;
  border: 1px solid #404040;
  border-radius: 8px;
  padding: 16px;
  height: 300px;
  position: relative;
}

.chart-container canvas {
  width: 100% !important;
  height: 100% !important;
}

/* Tables */
.kpi-tables {
  margin-bottom: 32px;
}

.table-section {
  margin-bottom: 32px;
}

.table-section h4 {
  margin-bottom: 16px;
  color: #ffffff;
  font-size: 18px;
  font-weight: 600;
}

.table-controls {
  display: flex;
  gap: 12px;
  margin-bottom: 16px;
  align-items: center;
}

.table-controls .form-control {
  background: #2d2d2d;
  border: 1px solid #404040;
  border-radius: 4px;
  padding: 8px 12px;
  color: #ffffff;
  font-size: 14px;
}

.table-controls .form-control:focus {
  outline: none;
  border-color: #2196F3;
  box-shadow: 0 0 0 2px rgba(33, 150, 243, 0.2);
}

.table-controls input.form-control {
  flex: 1;
  max-width: 300px;
}

.table-controls select.form-control {
  min-width: 150px;
}

.table-wrapper {
  background: #2d2d2d;
  border: 1px solid #404040;
  border-radius: 8px;
  overflow: hidden;
}

.interactive-table {
  width: 100%;
  border-collapse: collapse;
  background: transparent;
}

.interactive-table thead {
  background: #404040;
}

.interactive-table th {
  padding: 12px 16px;
  text-align: left;
  font-weight: 600;
  color: #ffffff;
  border-bottom: 1px solid #555555;
  cursor: pointer;
  transition: background-color 0.2s ease;
  position: relative;
}

.interactive-table th:hover {
  background: #4a4a4a;
}

.interactive-table th[data-sort]::after {
  content: '↕';
  position: absolute;
  right: 8px;
  opacity: 0.6;
  font-size: 12px;
}

.interactive-table th[data-sort]:hover::after {
  opacity: 1;
}

.interactive-table td {
  padding: 12px 16px;
  border-bottom: 1px solid #404040;
  color: #cccccc;
  font-size: 14px;
}

.interactive-table tbody tr:hover {
  background: rgba(33, 150, 243, 0.1);
}

.interactive-table tbody tr:nth-child(even) {
  background: rgba(255, 255, 255, 0.02);
}

.interactive-table tbody tr:nth-child(even):hover {
  background: rgba(33, 150, 243, 0.1);
}

/* Congestion indicators */
.congestion-indicator {
  display: inline-block;
  padding: 4px 8px;
  border-radius: 12px;
  color: #ffffff;
  font-weight: 500;
  font-size: 12px;
  min-width: 50px;
  text-align: center;
}

/* Comparison Panel */
.comparison-panel {
  background: #2d2d2d;
  border: 1px solid #404040;
  border-radius: 8px;
  padding: 20px;
  margin-bottom: 24px;
}

.comparison-panel h4 {
  margin-bottom: 16px;
  color: #ffffff;
  font-size: 18px;
  font-weight: 600;
}

.comparison-controls {
  display: flex;
  gap: 12px;
  margin-bottom: 20px;
  align-items: center;
}

.comparison-controls .form-control {
  background: #1a1a1a;
  border: 1px solid #404040;
  border-radius: 4px;
  padding: 8px 12px;
  color: #ffffff;
  font-size: 14px;
  flex: 1;
  max-width: 300px;
}

.comparison-table {
  width: 100%;
  border-collapse: collapse;
  background: #1a1a1a;
  border-radius: 6px;
  overflow: hidden;
}

.comparison-table th,
.comparison-table td {
  padding: 12px 16px;
  text-align: left;
  border-bottom: 1px solid #404040;
}

.comparison-table th {
  background: #404040;
  font-weight: 600;
  color: #ffffff;
}

.comparison-table td {
  color: #cccccc;
}

.comparison-table .diff-positive {
  color: #4CAF50;
  font-weight: 600;
}

.comparison-table .diff-negative {
  color: #F44336;
  font-weight: 600;
}

.comparison-table .diff-neutral {
  color: #999999;
}

/* Validation Panel */
.validation-panel {
  background: #2d2d2d;
  border: 1px solid #404040;
  border-radius: 8px;
  padding: 20px;
  margin-bottom: 24px;
}

.validation-panel h4 {
  margin-bottom: 16px;
  color: #ffffff;
  font-size: 18px;
  font-weight: 600;
}

.validation-formatted {
  background: #1a1a1a;
  border: 1px solid #404040;
  border-radius: 6px;
  padding: 16px;
  max-height: 400px;
  overflow-y: auto;
}

.validation-section {
  margin-bottom: 24px;
  padding-bottom: 16px;
  border-bottom: 1px solid #404040;
}

.validation-section:last-child {
  border-bottom: none;
  margin-bottom: 0;
}

.validation-section h4 {
  color: #2196F3;
  margin-bottom: 12px;
  font-size: 16px;
}

.validation-section h5 {
  color: #ffffff;
  margin-bottom: 8px;
  font-size: 14px;
}

.export-validation-summary {
  background: #2d2d2d;
  border: 1px solid #404040;
  border-radius: 4px;
  padding: 12px;
  margin-bottom: 16px;
}

.export-validation-summary p {
  margin: 0;
  color: #cccccc;
}

.validation-discrepancies {
  background: rgba(244, 67, 54, 0.1);
  border: 1px solid #F44336;
  border-radius: 4px;
  padding: 12px;
}

.validation-discrepancies ul {
  margin: 8px 0 0 0;
  padding-left: 20px;
}

.validation-discrepancies li {
  color: #F44336;
  margin-bottom: 4px;
}

.validation-success {
  background: rgba(76, 175, 80, 0.1);
  border: 1px solid #4CAF50;
  border-radius: 4px;
  padding: 12px;
}

.validation-success p {
  margin: 4px 0;
  color: #4CAF50;
}

.validation-formatted .validation-table {
  width: 100%;
  border-collapse: collapse;
}

.validation-formatted .validation-table th,
.validation-formatted .validation-table td {
  padding: 8px 12px;
  text-align: left;
  border-bottom: 1px solid #404040;
  color: #cccccc;
}

.validation-formatted .validation-table th {
  background: #404040;
  font-weight: 600;
  color: #ffffff;
}

.validation-formatted .validation-error {
  background: rgba(244, 67, 54, 0.1);
  color: #F44336;
}

.validation-formatted .validation-success {
  background: rgba(76, 175, 80, 0.1);
  color: #4CAF50;
}

/* Messages */
.kpi-message {
  text-align: center;
  padding: 40px 20px;
  color: #999999;
  font-size: 16px;
}

.validation-message {
  text-align: center;
  padding: 20px;
  color: #999999;
  font-style: italic;
}

/* Toast notifications */
.toast {
  display: block;
  opacity: 1;
  min-width: 200px;
  text-align: center;
}

/* Responsive design */
@media (max-width: 768px) {
  .kpi-header {
    flex-direction: column;
    align-items: flex-start;
    gap: 16px;
  }
  
  .kpi-controls {
    width: 100%;
    justify-content: flex-start;
    flex-wrap: wrap;
  }
  
  .summary-grid {
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 12px;
  }
  
  .chart-grid {
    grid-template-columns: 1fr;
    gap: 16px;
  }
  
  .chart-container {
    height: 250px;
  }
  
  .table-controls {
    flex-direction: column;
    align-items: stretch;
  }
  
  .table-wrapper {
    overflow-x: auto;
  }
  
  .comparison-controls {
    flex-direction: column;
    align-items: stretch;
  }
}

@media (max-width: 480px) {
  .kpi-visualization {
    padding: 12px;
  }
  
  .summary-grid {
    grid-template-columns: 1fr;
  }
  
  .interactive-table th,
  .interactive-table td {
    padding: 8px 12px;
    font-size: 12px;
  }
  
  .chart-container {
    height: 200px;
    padding: 12px;
  }
}

/* Animation for chart updates */
@keyframes chartFadeIn {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.chart-container {
  animation: chartFadeIn 0.5s ease-out;
}

/* Scrollbar styling for dark theme */
.table-wrapper::-webkit-scrollbar,
.validation-formatted::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

.table-wrapper::-webkit-scrollbar-track,
.validation-formatted::-webkit-scrollbar-track {
  background: #1a1a1a;
}

.table-wrapper::-webkit-scrollbar-thumb,
.validation-formatted::-webkit-scrollbar-thumb {
  background: #404040;
  border-radius: 4px;
}

.table-wrapper::-webkit-scrollbar-thumb:hover,
.validation-formatted::-webkit-scrollbar-thumb:hover {
  background: #555555;
}
`, "",{"version":3,"sources":["webpack://./css/kpi-visualization.css"],"names":[],"mappings":"AAAA,uCAAuC;;AAEvC;EACE,aAAa;EACb,mBAAmB;EACnB,cAAc;EACd,yGAAyG;AAC3G;;AAEA,WAAW;AACX;EACE,aAAa;EACb,8BAA8B;EAC9B,mBAAmB;EACnB,mBAAmB;EACnB,oBAAoB;EACpB,gCAAgC;AAClC;;AAEA;EACE,SAAS;EACT,cAAc;EACd,eAAe;EACf,gBAAgB;AAClB;;AAEA;EACE,aAAa;EACb,QAAQ;AACV;;AAEA;EACE,iBAAiB;EACjB,eAAe;EACf,kBAAkB;EAClB,YAAY;EACZ,eAAe;EACf,yBAAyB;AAC3B;;AAEA;EACE,YAAY;EACZ,2BAA2B;AAC7B;;AAEA,kBAAkB;AAClB;EACE,mBAAmB;AACrB;;AAEA;EACE,aAAa;EACb,2DAA2D;EAC3D,SAAS;EACT,mBAAmB;AACrB;;AAEA;EACE,mBAAmB;EACnB,yBAAyB;EACzB,kBAAkB;EAClB,aAAa;EACb,kBAAkB;EAClB,yBAAyB;AAC3B;;AAEA;EACE,qBAAqB;EACrB,2BAA2B;EAC3B,8CAA8C;AAChD;;AAEA;EACE,eAAe;EACf,gBAAgB;EAChB,cAAc;EACd,kBAAkB;AACpB;;AAEA;EACE,eAAe;EACf,cAAc;EACd,kBAAkB;AACpB;;AAEA;EACE,eAAe;EACf,gBAAgB;AAClB;;AAEA;EACE,cAAc;AAChB;;AAEA;EACE,cAAc;AAChB;;AAEA;EACE,cAAc;AAChB;;AAEA,WAAW;AACX;EACE,mBAAmB;AACrB;;AAEA;EACE,mBAAmB;EACnB,cAAc;EACd,eAAe;EACf,gBAAgB;AAClB;;AAEA;EACE,aAAa;EACb,2DAA2D;EAC3D,SAAS;AACX;;AAEA;EACE,mBAAmB;EACnB,yBAAyB;EACzB,kBAAkB;EAClB,aAAa;EACb,aAAa;EACb,kBAAkB;AACpB;;AAEA;EACE,sBAAsB;EACtB,uBAAuB;AACzB;;AAEA,WAAW;AACX;EACE,mBAAmB;AACrB;;AAEA;EACE,mBAAmB;AACrB;;AAEA;EACE,mBAAmB;EACnB,cAAc;EACd,eAAe;EACf,gBAAgB;AAClB;;AAEA;EACE,aAAa;EACb,SAAS;EACT,mBAAmB;EACnB,mBAAmB;AACrB;;AAEA;EACE,mBAAmB;EACnB,yBAAyB;EACzB,kBAAkB;EAClB,iBAAiB;EACjB,cAAc;EACd,eAAe;AACjB;;AAEA;EACE,aAAa;EACb,qBAAqB;EACrB,6CAA6C;AAC/C;;AAEA;EACE,OAAO;EACP,gBAAgB;AAClB;;AAEA;EACE,gBAAgB;AAClB;;AAEA;EACE,mBAAmB;EACnB,yBAAyB;EACzB,kBAAkB;EAClB,gBAAgB;AAClB;;AAEA;EACE,WAAW;EACX,yBAAyB;EACzB,uBAAuB;AACzB;;AAEA;EACE,mBAAmB;AACrB;;AAEA;EACE,kBAAkB;EAClB,gBAAgB;EAChB,gBAAgB;EAChB,cAAc;EACd,gCAAgC;EAChC,eAAe;EACf,sCAAsC;EACtC,kBAAkB;AACpB;;AAEA;EACE,mBAAmB;AACrB;;AAEA;EACE,YAAY;EACZ,kBAAkB;EAClB,UAAU;EACV,YAAY;EACZ,eAAe;AACjB;;AAEA;EACE,UAAU;AACZ;;AAEA;EACE,kBAAkB;EAClB,gCAAgC;EAChC,cAAc;EACd,eAAe;AACjB;;AAEA;EACE,mCAAmC;AACrC;;AAEA;EACE,qCAAqC;AACvC;;AAEA;EACE,mCAAmC;AACrC;;AAEA,0BAA0B;AAC1B;EACE,qBAAqB;EACrB,gBAAgB;EAChB,mBAAmB;EACnB,cAAc;EACd,gBAAgB;EAChB,eAAe;EACf,eAAe;EACf,kBAAkB;AACpB;;AAEA,qBAAqB;AACrB;EACE,mBAAmB;EACnB,yBAAyB;EACzB,kBAAkB;EAClB,aAAa;EACb,mBAAmB;AACrB;;AAEA;EACE,mBAAmB;EACnB,cAAc;EACd,eAAe;EACf,gBAAgB;AAClB;;AAEA;EACE,aAAa;EACb,SAAS;EACT,mBAAmB;EACnB,mBAAmB;AACrB;;AAEA;EACE,mBAAmB;EACnB,yBAAyB;EACzB,kBAAkB;EAClB,iBAAiB;EACjB,cAAc;EACd,eAAe;EACf,OAAO;EACP,gBAAgB;AAClB;;AAEA;EACE,WAAW;EACX,yBAAyB;EACzB,mBAAmB;EACnB,kBAAkB;EAClB,gBAAgB;AAClB;;AAEA;;EAEE,kBAAkB;EAClB,gBAAgB;EAChB,gCAAgC;AAClC;;AAEA;EACE,mBAAmB;EACnB,gBAAgB;EAChB,cAAc;AAChB;;AAEA;EACE,cAAc;AAChB;;AAEA;EACE,cAAc;EACd,gBAAgB;AAClB;;AAEA;EACE,cAAc;EACd,gBAAgB;AAClB;;AAEA;EACE,cAAc;AAChB;;AAEA,qBAAqB;AACrB;EACE,mBAAmB;EACnB,yBAAyB;EACzB,kBAAkB;EAClB,aAAa;EACb,mBAAmB;AACrB;;AAEA;EACE,mBAAmB;EACnB,cAAc;EACd,eAAe;EACf,gBAAgB;AAClB;;AAEA;EACE,mBAAmB;EACnB,yBAAyB;EACzB,kBAAkB;EAClB,aAAa;EACb,iBAAiB;EACjB,gBAAgB;AAClB;;AAEA;EACE,mBAAmB;EACnB,oBAAoB;EACpB,gCAAgC;AAClC;;AAEA;EACE,mBAAmB;EACnB,gBAAgB;AAClB;;AAEA;EACE,cAAc;EACd,mBAAmB;EACnB,eAAe;AACjB;;AAEA;EACE,cAAc;EACd,kBAAkB;EAClB,eAAe;AACjB;;AAEA;EACE,mBAAmB;EACnB,yBAAyB;EACzB,kBAAkB;EAClB,aAAa;EACb,mBAAmB;AACrB;;AAEA;EACE,SAAS;EACT,cAAc;AAChB;;AAEA;EACE,kCAAkC;EAClC,yBAAyB;EACzB,kBAAkB;EAClB,aAAa;AACf;;AAEA;EACE,iBAAiB;EACjB,kBAAkB;AACpB;;AAEA;EACE,cAAc;EACd,kBAAkB;AACpB;;AAEA;EACE,kCAAkC;EAClC,yBAAyB;EACzB,kBAAkB;EAClB,aAAa;AACf;;AAEA;EACE,aAAa;EACb,cAAc;AAChB;;AAEA;EACE,WAAW;EACX,yBAAyB;AAC3B;;AAEA;;EAEE,iBAAiB;EACjB,gBAAgB;EAChB,gCAAgC;EAChC,cAAc;AAChB;;AAEA;EACE,mBAAmB;EACnB,gBAAgB;EAChB,cAAc;AAChB;;AAEA;EACE,kCAAkC;EAClC,cAAc;AAChB;;AAEA;EACE,kCAAkC;EAClC,cAAc;AAChB;;AAEA,aAAa;AACb;EACE,kBAAkB;EAClB,kBAAkB;EAClB,cAAc;EACd,eAAe;AACjB;;AAEA;EACE,kBAAkB;EAClB,aAAa;EACb,cAAc;EACd,kBAAkB;AACpB;;AAEA,wBAAwB;AACxB;EACE,cAAc;EACd,UAAU;EACV,gBAAgB;EAChB,kBAAkB;AACpB;;AAEA,sBAAsB;AACtB;EACE;IACE,sBAAsB;IACtB,uBAAuB;IACvB,SAAS;EACX;;EAEA;IACE,WAAW;IACX,2BAA2B;IAC3B,eAAe;EACjB;;EAEA;IACE,2DAA2D;IAC3D,SAAS;EACX;;EAEA;IACE,0BAA0B;IAC1B,SAAS;EACX;;EAEA;IACE,aAAa;EACf;;EAEA;IACE,sBAAsB;IACtB,oBAAoB;EACtB;;EAEA;IACE,gBAAgB;EAClB;;EAEA;IACE,sBAAsB;IACtB,oBAAoB;EACtB;AACF;;AAEA;EACE;IACE,aAAa;EACf;;EAEA;IACE,0BAA0B;EAC5B;;EAEA;;IAEE,iBAAiB;IACjB,eAAe;EACjB;;EAEA;IACE,aAAa;IACb,aAAa;EACf;AACF;;AAEA,gCAAgC;AAChC;EACE;IACE,UAAU;IACV,2BAA2B;EAC7B;EACA;IACE,UAAU;IACV,wBAAwB;EAC1B;AACF;;AAEA;EACE,oCAAoC;AACtC;;AAEA,qCAAqC;AACrC;;EAEE,UAAU;EACV,WAAW;AACb;;AAEA;;EAEE,mBAAmB;AACrB;;AAEA;;EAEE,mBAAmB;EACnB,kBAAkB;AACpB;;AAEA;;EAEE,mBAAmB;AACrB","sourcesContent":["/* KPI Visualization Component Styles */\r\n\r\n.kpi-visualization {\r\n  padding: 20px;\r\n  background: #1a1a1a;\r\n  color: #ffffff;\r\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;\r\n}\r\n\r\n/* Header */\r\n.kpi-header {\r\n  display: flex;\r\n  justify-content: space-between;\r\n  align-items: center;\r\n  margin-bottom: 24px;\r\n  padding-bottom: 16px;\r\n  border-bottom: 1px solid #404040;\r\n}\r\n\r\n.kpi-header h3 {\r\n  margin: 0;\r\n  color: #ffffff;\r\n  font-size: 24px;\r\n  font-weight: 600;\r\n}\r\n\r\n.kpi-controls {\r\n  display: flex;\r\n  gap: 8px;\r\n}\r\n\r\n.kpi-controls .btn {\r\n  padding: 6px 12px;\r\n  font-size: 12px;\r\n  border-radius: 4px;\r\n  border: none;\r\n  cursor: pointer;\r\n  transition: all 0.2s ease;\r\n}\r\n\r\n.kpi-controls .btn:hover {\r\n  opacity: 0.8;\r\n  transform: translateY(-1px);\r\n}\r\n\r\n/* Summary Cards */\r\n.kpi-summary {\r\n  margin-bottom: 32px;\r\n}\r\n\r\n.summary-grid {\r\n  display: grid;\r\n  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\r\n  gap: 16px;\r\n  margin-bottom: 24px;\r\n}\r\n\r\n.summary-card {\r\n  background: #2d2d2d;\r\n  border: 1px solid #404040;\r\n  border-radius: 8px;\r\n  padding: 20px;\r\n  text-align: center;\r\n  transition: all 0.2s ease;\r\n}\r\n\r\n.summary-card:hover {\r\n  border-color: #2196F3;\r\n  transform: translateY(-2px);\r\n  box-shadow: 0 4px 12px rgba(33, 150, 243, 0.2);\r\n}\r\n\r\n.summary-card .card-value {\r\n  font-size: 32px;\r\n  font-weight: 700;\r\n  color: #2196F3;\r\n  margin-bottom: 8px;\r\n}\r\n\r\n.summary-card .card-label {\r\n  font-size: 14px;\r\n  color: #cccccc;\r\n  margin-bottom: 4px;\r\n}\r\n\r\n.summary-card .card-change {\r\n  font-size: 12px;\r\n  font-weight: 500;\r\n}\r\n\r\n.summary-card .card-change.positive {\r\n  color: #4CAF50;\r\n}\r\n\r\n.summary-card .card-change.negative {\r\n  color: #F44336;\r\n}\r\n\r\n.summary-card .card-change.neutral {\r\n  color: #999999;\r\n}\r\n\r\n/* Charts */\r\n.kpi-charts {\r\n  margin-bottom: 32px;\r\n}\r\n\r\n.chart-section h4 {\r\n  margin-bottom: 20px;\r\n  color: #ffffff;\r\n  font-size: 20px;\r\n  font-weight: 600;\r\n}\r\n\r\n.chart-grid {\r\n  display: grid;\r\n  grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));\r\n  gap: 20px;\r\n}\r\n\r\n.chart-container {\r\n  background: #2d2d2d;\r\n  border: 1px solid #404040;\r\n  border-radius: 8px;\r\n  padding: 16px;\r\n  height: 300px;\r\n  position: relative;\r\n}\r\n\r\n.chart-container canvas {\r\n  width: 100% !important;\r\n  height: 100% !important;\r\n}\r\n\r\n/* Tables */\r\n.kpi-tables {\r\n  margin-bottom: 32px;\r\n}\r\n\r\n.table-section {\r\n  margin-bottom: 32px;\r\n}\r\n\r\n.table-section h4 {\r\n  margin-bottom: 16px;\r\n  color: #ffffff;\r\n  font-size: 18px;\r\n  font-weight: 600;\r\n}\r\n\r\n.table-controls {\r\n  display: flex;\r\n  gap: 12px;\r\n  margin-bottom: 16px;\r\n  align-items: center;\r\n}\r\n\r\n.table-controls .form-control {\r\n  background: #2d2d2d;\r\n  border: 1px solid #404040;\r\n  border-radius: 4px;\r\n  padding: 8px 12px;\r\n  color: #ffffff;\r\n  font-size: 14px;\r\n}\r\n\r\n.table-controls .form-control:focus {\r\n  outline: none;\r\n  border-color: #2196F3;\r\n  box-shadow: 0 0 0 2px rgba(33, 150, 243, 0.2);\r\n}\r\n\r\n.table-controls input.form-control {\r\n  flex: 1;\r\n  max-width: 300px;\r\n}\r\n\r\n.table-controls select.form-control {\r\n  min-width: 150px;\r\n}\r\n\r\n.table-wrapper {\r\n  background: #2d2d2d;\r\n  border: 1px solid #404040;\r\n  border-radius: 8px;\r\n  overflow: hidden;\r\n}\r\n\r\n.interactive-table {\r\n  width: 100%;\r\n  border-collapse: collapse;\r\n  background: transparent;\r\n}\r\n\r\n.interactive-table thead {\r\n  background: #404040;\r\n}\r\n\r\n.interactive-table th {\r\n  padding: 12px 16px;\r\n  text-align: left;\r\n  font-weight: 600;\r\n  color: #ffffff;\r\n  border-bottom: 1px solid #555555;\r\n  cursor: pointer;\r\n  transition: background-color 0.2s ease;\r\n  position: relative;\r\n}\r\n\r\n.interactive-table th:hover {\r\n  background: #4a4a4a;\r\n}\r\n\r\n.interactive-table th[data-sort]::after {\r\n  content: '↕';\r\n  position: absolute;\r\n  right: 8px;\r\n  opacity: 0.6;\r\n  font-size: 12px;\r\n}\r\n\r\n.interactive-table th[data-sort]:hover::after {\r\n  opacity: 1;\r\n}\r\n\r\n.interactive-table td {\r\n  padding: 12px 16px;\r\n  border-bottom: 1px solid #404040;\r\n  color: #cccccc;\r\n  font-size: 14px;\r\n}\r\n\r\n.interactive-table tbody tr:hover {\r\n  background: rgba(33, 150, 243, 0.1);\r\n}\r\n\r\n.interactive-table tbody tr:nth-child(even) {\r\n  background: rgba(255, 255, 255, 0.02);\r\n}\r\n\r\n.interactive-table tbody tr:nth-child(even):hover {\r\n  background: rgba(33, 150, 243, 0.1);\r\n}\r\n\r\n/* Congestion indicators */\r\n.congestion-indicator {\r\n  display: inline-block;\r\n  padding: 4px 8px;\r\n  border-radius: 12px;\r\n  color: #ffffff;\r\n  font-weight: 500;\r\n  font-size: 12px;\r\n  min-width: 50px;\r\n  text-align: center;\r\n}\r\n\r\n/* Comparison Panel */\r\n.comparison-panel {\r\n  background: #2d2d2d;\r\n  border: 1px solid #404040;\r\n  border-radius: 8px;\r\n  padding: 20px;\r\n  margin-bottom: 24px;\r\n}\r\n\r\n.comparison-panel h4 {\r\n  margin-bottom: 16px;\r\n  color: #ffffff;\r\n  font-size: 18px;\r\n  font-weight: 600;\r\n}\r\n\r\n.comparison-controls {\r\n  display: flex;\r\n  gap: 12px;\r\n  margin-bottom: 20px;\r\n  align-items: center;\r\n}\r\n\r\n.comparison-controls .form-control {\r\n  background: #1a1a1a;\r\n  border: 1px solid #404040;\r\n  border-radius: 4px;\r\n  padding: 8px 12px;\r\n  color: #ffffff;\r\n  font-size: 14px;\r\n  flex: 1;\r\n  max-width: 300px;\r\n}\r\n\r\n.comparison-table {\r\n  width: 100%;\r\n  border-collapse: collapse;\r\n  background: #1a1a1a;\r\n  border-radius: 6px;\r\n  overflow: hidden;\r\n}\r\n\r\n.comparison-table th,\r\n.comparison-table td {\r\n  padding: 12px 16px;\r\n  text-align: left;\r\n  border-bottom: 1px solid #404040;\r\n}\r\n\r\n.comparison-table th {\r\n  background: #404040;\r\n  font-weight: 600;\r\n  color: #ffffff;\r\n}\r\n\r\n.comparison-table td {\r\n  color: #cccccc;\r\n}\r\n\r\n.comparison-table .diff-positive {\r\n  color: #4CAF50;\r\n  font-weight: 600;\r\n}\r\n\r\n.comparison-table .diff-negative {\r\n  color: #F44336;\r\n  font-weight: 600;\r\n}\r\n\r\n.comparison-table .diff-neutral {\r\n  color: #999999;\r\n}\r\n\r\n/* Validation Panel */\r\n.validation-panel {\r\n  background: #2d2d2d;\r\n  border: 1px solid #404040;\r\n  border-radius: 8px;\r\n  padding: 20px;\r\n  margin-bottom: 24px;\r\n}\r\n\r\n.validation-panel h4 {\r\n  margin-bottom: 16px;\r\n  color: #ffffff;\r\n  font-size: 18px;\r\n  font-weight: 600;\r\n}\r\n\r\n.validation-formatted {\r\n  background: #1a1a1a;\r\n  border: 1px solid #404040;\r\n  border-radius: 6px;\r\n  padding: 16px;\r\n  max-height: 400px;\r\n  overflow-y: auto;\r\n}\r\n\r\n.validation-section {\r\n  margin-bottom: 24px;\r\n  padding-bottom: 16px;\r\n  border-bottom: 1px solid #404040;\r\n}\r\n\r\n.validation-section:last-child {\r\n  border-bottom: none;\r\n  margin-bottom: 0;\r\n}\r\n\r\n.validation-section h4 {\r\n  color: #2196F3;\r\n  margin-bottom: 12px;\r\n  font-size: 16px;\r\n}\r\n\r\n.validation-section h5 {\r\n  color: #ffffff;\r\n  margin-bottom: 8px;\r\n  font-size: 14px;\r\n}\r\n\r\n.export-validation-summary {\r\n  background: #2d2d2d;\r\n  border: 1px solid #404040;\r\n  border-radius: 4px;\r\n  padding: 12px;\r\n  margin-bottom: 16px;\r\n}\r\n\r\n.export-validation-summary p {\r\n  margin: 0;\r\n  color: #cccccc;\r\n}\r\n\r\n.validation-discrepancies {\r\n  background: rgba(244, 67, 54, 0.1);\r\n  border: 1px solid #F44336;\r\n  border-radius: 4px;\r\n  padding: 12px;\r\n}\r\n\r\n.validation-discrepancies ul {\r\n  margin: 8px 0 0 0;\r\n  padding-left: 20px;\r\n}\r\n\r\n.validation-discrepancies li {\r\n  color: #F44336;\r\n  margin-bottom: 4px;\r\n}\r\n\r\n.validation-success {\r\n  background: rgba(76, 175, 80, 0.1);\r\n  border: 1px solid #4CAF50;\r\n  border-radius: 4px;\r\n  padding: 12px;\r\n}\r\n\r\n.validation-success p {\r\n  margin: 4px 0;\r\n  color: #4CAF50;\r\n}\r\n\r\n.validation-formatted .validation-table {\r\n  width: 100%;\r\n  border-collapse: collapse;\r\n}\r\n\r\n.validation-formatted .validation-table th,\r\n.validation-formatted .validation-table td {\r\n  padding: 8px 12px;\r\n  text-align: left;\r\n  border-bottom: 1px solid #404040;\r\n  color: #cccccc;\r\n}\r\n\r\n.validation-formatted .validation-table th {\r\n  background: #404040;\r\n  font-weight: 600;\r\n  color: #ffffff;\r\n}\r\n\r\n.validation-formatted .validation-error {\r\n  background: rgba(244, 67, 54, 0.1);\r\n  color: #F44336;\r\n}\r\n\r\n.validation-formatted .validation-success {\r\n  background: rgba(76, 175, 80, 0.1);\r\n  color: #4CAF50;\r\n}\r\n\r\n/* Messages */\r\n.kpi-message {\r\n  text-align: center;\r\n  padding: 40px 20px;\r\n  color: #999999;\r\n  font-size: 16px;\r\n}\r\n\r\n.validation-message {\r\n  text-align: center;\r\n  padding: 20px;\r\n  color: #999999;\r\n  font-style: italic;\r\n}\r\n\r\n/* Toast notifications */\r\n.toast {\r\n  display: block;\r\n  opacity: 1;\r\n  min-width: 200px;\r\n  text-align: center;\r\n}\r\n\r\n/* Responsive design */\r\n@media (max-width: 768px) {\r\n  .kpi-header {\r\n    flex-direction: column;\r\n    align-items: flex-start;\r\n    gap: 16px;\r\n  }\r\n  \r\n  .kpi-controls {\r\n    width: 100%;\r\n    justify-content: flex-start;\r\n    flex-wrap: wrap;\r\n  }\r\n  \r\n  .summary-grid {\r\n    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));\r\n    gap: 12px;\r\n  }\r\n  \r\n  .chart-grid {\r\n    grid-template-columns: 1fr;\r\n    gap: 16px;\r\n  }\r\n  \r\n  .chart-container {\r\n    height: 250px;\r\n  }\r\n  \r\n  .table-controls {\r\n    flex-direction: column;\r\n    align-items: stretch;\r\n  }\r\n  \r\n  .table-wrapper {\r\n    overflow-x: auto;\r\n  }\r\n  \r\n  .comparison-controls {\r\n    flex-direction: column;\r\n    align-items: stretch;\r\n  }\r\n}\r\n\r\n@media (max-width: 480px) {\r\n  .kpi-visualization {\r\n    padding: 12px;\r\n  }\r\n  \r\n  .summary-grid {\r\n    grid-template-columns: 1fr;\r\n  }\r\n  \r\n  .interactive-table th,\r\n  .interactive-table td {\r\n    padding: 8px 12px;\r\n    font-size: 12px;\r\n  }\r\n  \r\n  .chart-container {\r\n    height: 200px;\r\n    padding: 12px;\r\n  }\r\n}\r\n\r\n/* Animation for chart updates */\r\n@keyframes chartFadeIn {\r\n  from {\r\n    opacity: 0;\r\n    transform: translateY(20px);\r\n  }\r\n  to {\r\n    opacity: 1;\r\n    transform: translateY(0);\r\n  }\r\n}\r\n\r\n.chart-container {\r\n  animation: chartFadeIn 0.5s ease-out;\r\n}\r\n\r\n/* Scrollbar styling for dark theme */\r\n.table-wrapper::-webkit-scrollbar,\r\n.validation-formatted::-webkit-scrollbar {\r\n  width: 8px;\r\n  height: 8px;\r\n}\r\n\r\n.table-wrapper::-webkit-scrollbar-track,\r\n.validation-formatted::-webkit-scrollbar-track {\r\n  background: #1a1a1a;\r\n}\r\n\r\n.table-wrapper::-webkit-scrollbar-thumb,\r\n.validation-formatted::-webkit-scrollbar-thumb {\r\n  background: #404040;\r\n  border-radius: 4px;\r\n}\r\n\r\n.table-wrapper::-webkit-scrollbar-thumb:hover,\r\n.validation-formatted::-webkit-scrollbar-thumb:hover {\r\n  background: #555555;\r\n}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./css/style.css":
/*!*************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./css/style.css ***!
  \*************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `body, html {
    padding: 0;
    margin: 0;
    background: #1a1a1a; /* Dark background */
    color: #ffffff; /* White text */
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
    height: 100%;
    width: 100%;
    overflow: hidden; /* Default to hidden */
}

/* Style for pages where we want to allow scrolling */
body.allow-scroll {
    overflow: auto;
}

#app-container {
    display: flex;
    flex-direction: column;
    height: 100vh;
    width: 100vw;
    overflow: hidden; /* Prevent overflow by default */
    background: #1a1a1a; /* Dark background */
}

/* Allow scrolling on home page */
.allow-scroll #app-container {
    overflow: auto;
}

#nav-container {
    flex-shrink: 0;
    position: relative;
    z-index: 100;
    background: #2d2d2d; /* Dark navigation */
    border-bottom: 1px solid #404040;
}

#main-content {
    flex: 1;
    overflow: hidden; /* Hide overflow by default */
    position: relative;
    height: calc(100vh - 60px); /* Reserve space for navigation */
    background: #1a1a1a;
}

/* Allow scrolling for home page */
.allow-scroll #main-content {
    overflow: auto;
}

/* Ensure pages fill their container completely */
.builder-page,
.simulation-page {
    height: 100%;
    width: 100%;
    overflow: hidden;
    position: relative;
    background: #1a1a1a;
}

#canvas {
    padding: 0;
    margin: 0;
    position: relative;
    z-index: 1;
    pointer-events: auto;
    display: block;
    background: #2d2d2d;
    border: 1px solid #404040;
    width: 100%;
    height: 100%;
}

.visualizer-area {
    flex: 1;
    position: relative;
    min-height: 600px;
    background: #2d2d2d;
    display: flex;
    align-items: center;
    justify-content: center;
}

.visualizer-area canvas {
    width: 100% !important;
    height: 100% !important;
    max-width: 100% !important;
    max-height: 100% !important;
    background: #2d2d2d !important;
    border: 1px solid #404040;
    display: block !important;
}

.builder-content,
.simulation-content {
    display: flex;
    height: 100%;
}

.sidebar {
    width: 280px;
    background: #2d2d2d;
    border-right: 1px solid #404040;
    overflow-y: auto;
    pointer-events: auto;
    z-index: 10;
}

/* Ensure buttons are always clickable */
button, .btn {
    pointer-events: auto;
    cursor: pointer;
    position: relative;
    z-index: 20;
}

/* Debug helper - can be removed later */
/* * { background-color: rgba(255, 0, 0, 0.1); } */
/* * * { background-color: rgba(0, 255, 0, 0.2); } */
/* * * * { background-color: rgba(0, 0, 255, 0.3); } */

/* KPI Metrics Styles */
.metrics-table-container {
    margin-top: 10px;
    max-height: 300px;
    overflow-y: auto;
    border: 1px solid #404040;
    border-radius: 4px;
    background: #2d2d2d;
}

.metrics-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.85em;
}

.metrics-table th,
.metrics-table td {
    padding: 6px 8px;
    border: 1px solid #404040;
    text-align: left;
}

.metrics-table th {
    background-color: #333;
    position: sticky;
    top: 0;
    z-index: 1;
}

.metrics-table tr:nth-child(even) {
    background-color: #2a2a2a;
}

.metrics-table tr:hover {
    background-color: #3a3a3a;
}

/* Color coding for congestion */
.congested-row {
    background-color: rgba(255, 99, 71, 0.2) !important; /* Tomato with transparency */
}

.moderate-row {
    background-color: rgba(255, 165, 0, 0.2) !important; /* Orange with transparency */
}

/* KPI validation styles */
.kpi-validation {
    background-color: #2d2d2d;
    border: 1px solid #404040;
    border-radius: 4px;
    padding: 15px;
    margin-top: 10px;
    overflow-y: auto;
    max-height: 80vh;
}

.kpi-validation h3 {
    margin-top: 0;
    border-bottom: 1px solid #404040;
    padding-bottom: 10px;
    color: #f0f0f0;
}

.validation-table {
    width: 100%;
    border-collapse: collapse;
    margin: 10px 0;
}

.validation-table th, 
.validation-table td {
    padding: 6px 8px;
    border: 1px solid #404040;
    text-align: left;
}

.validation-table th {
    background-color: #333;
}

.validation-error {
    background-color: rgba(255, 99, 71, 0.2) !important;
}

.validation-success {
    background-color: rgba(50, 205, 50, 0.2) !important;
}

/* Modal styles for validation and layout selector */
.modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.7);
    overflow: auto;
}

.modal-content {
    background-color: #2d2d2d;
    margin: 10% auto;
    padding: 0;
    border: 1px solid #404040;
    border-radius: 4px;
    width: 80%;
    max-width: 800px;
    max-height: 80vh;
    display: flex;
    flex-direction: column;
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}

.modal-header {
    padding: 15px;
    border-bottom: 1px solid #404040;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.modal-header h2 {
    margin: 0;
    color: #f0f0f0;
}

.modal-body {
    padding: 15px;
    overflow-y: auto;
    flex: 1;
}

.modal-footer {
    padding: 15px;
    border-top: 1px solid #404040;
    display: flex;
    justify-content: flex-end;
}

.close {
    color: #aaa;
    float: right;
    font-size: 28px;
    font-weight: bold;
    cursor: pointer;
}

.close:hover,
.close:focus {
    color: #fff;
    text-decoration: none;
}

/* Analytics panel styles */
.analytics-section {
    margin-bottom: 15px;
    padding-bottom: 10px;
    border-bottom: 1px solid #404040;
}

.analytics-section:last-child {
    border-bottom: none;
}

.analytics-section h4 {
    margin-bottom: 10px;
    color: #f0f0f0;
}

.metric {
    display: flex;
    justify-content: space-between;
    margin-bottom: 5px;
    font-size: 0.9em;
}

.metric .label {
    color: #bbb;
}

.metric .value {
    font-weight: 500;
}

/* Color coding for congestion index */
.good {
    color: #4caf50 !important;
}

.warning {
    color: #ff9800 !important;
}

.critical {
    color: #f44336 !important;
}

.analytics-actions {
    display: flex;
    gap: 10px;
    margin-top: 15px;
}

/* Layout selector styles */
.layout-options {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
    gap: 15px;
}

.layout-option {
    background: #333;
    padding: 15px;
    border-radius: 4px;
    border: 1px solid #404040;
}

.layout-option h4 {
    margin-top: 0;
    margin-bottom: 5px;
}

.layout-meta {
    font-size: 0.9em;
    color: #bbb;
    margin-bottom: 10px;
}

.load-layout-btn {
    width: 100%;
    margin-top: 10px;
}
`, "",{"version":3,"sources":["webpack://./css/style.css"],"names":[],"mappings":"AAAA;IACI,UAAU;IACV,SAAS;IACT,mBAAmB,EAAE,oBAAoB;IACzC,cAAc,EAAE,eAAe;IAC/B,yGAAyG;IACzG,YAAY;IACZ,WAAW;IACX,gBAAgB,EAAE,sBAAsB;AAC5C;;AAEA,qDAAqD;AACrD;IACI,cAAc;AAClB;;AAEA;IACI,aAAa;IACb,sBAAsB;IACtB,aAAa;IACb,YAAY;IACZ,gBAAgB,EAAE,gCAAgC;IAClD,mBAAmB,EAAE,oBAAoB;AAC7C;;AAEA,iCAAiC;AACjC;IACI,cAAc;AAClB;;AAEA;IACI,cAAc;IACd,kBAAkB;IAClB,YAAY;IACZ,mBAAmB,EAAE,oBAAoB;IACzC,gCAAgC;AACpC;;AAEA;IACI,OAAO;IACP,gBAAgB,EAAE,6BAA6B;IAC/C,kBAAkB;IAClB,0BAA0B,EAAE,iCAAiC;IAC7D,mBAAmB;AACvB;;AAEA,kCAAkC;AAClC;IACI,cAAc;AAClB;;AAEA,iDAAiD;AACjD;;IAEI,YAAY;IACZ,WAAW;IACX,gBAAgB;IAChB,kBAAkB;IAClB,mBAAmB;AACvB;;AAEA;IACI,UAAU;IACV,SAAS;IACT,kBAAkB;IAClB,UAAU;IACV,oBAAoB;IACpB,cAAc;IACd,mBAAmB;IACnB,yBAAyB;IACzB,WAAW;IACX,YAAY;AAChB;;AAEA;IACI,OAAO;IACP,kBAAkB;IAClB,iBAAiB;IACjB,mBAAmB;IACnB,aAAa;IACb,mBAAmB;IACnB,uBAAuB;AAC3B;;AAEA;IACI,sBAAsB;IACtB,uBAAuB;IACvB,0BAA0B;IAC1B,2BAA2B;IAC3B,8BAA8B;IAC9B,yBAAyB;IACzB,yBAAyB;AAC7B;;AAEA;;IAEI,aAAa;IACb,YAAY;AAChB;;AAEA;IACI,YAAY;IACZ,mBAAmB;IACnB,+BAA+B;IAC/B,gBAAgB;IAChB,oBAAoB;IACpB,WAAW;AACf;;AAEA,wCAAwC;AACxC;IACI,oBAAoB;IACpB,eAAe;IACf,kBAAkB;IAClB,WAAW;AACf;;AAEA,wCAAwC;AACxC,kDAAkD;AAClD,oDAAoD;AACpD,sDAAsD;;AAEtD,uBAAuB;AACvB;IACI,gBAAgB;IAChB,iBAAiB;IACjB,gBAAgB;IAChB,yBAAyB;IACzB,kBAAkB;IAClB,mBAAmB;AACvB;;AAEA;IACI,WAAW;IACX,yBAAyB;IACzB,iBAAiB;AACrB;;AAEA;;IAEI,gBAAgB;IAChB,yBAAyB;IACzB,gBAAgB;AACpB;;AAEA;IACI,sBAAsB;IACtB,gBAAgB;IAChB,MAAM;IACN,UAAU;AACd;;AAEA;IACI,yBAAyB;AAC7B;;AAEA;IACI,yBAAyB;AAC7B;;AAEA,gCAAgC;AAChC;IACI,mDAAmD,EAAE,6BAA6B;AACtF;;AAEA;IACI,mDAAmD,EAAE,6BAA6B;AACtF;;AAEA,0BAA0B;AAC1B;IACI,yBAAyB;IACzB,yBAAyB;IACzB,kBAAkB;IAClB,aAAa;IACb,gBAAgB;IAChB,gBAAgB;IAChB,gBAAgB;AACpB;;AAEA;IACI,aAAa;IACb,gCAAgC;IAChC,oBAAoB;IACpB,cAAc;AAClB;;AAEA;IACI,WAAW;IACX,yBAAyB;IACzB,cAAc;AAClB;;AAEA;;IAEI,gBAAgB;IAChB,yBAAyB;IACzB,gBAAgB;AACpB;;AAEA;IACI,sBAAsB;AAC1B;;AAEA;IACI,mDAAmD;AACvD;;AAEA;IACI,mDAAmD;AACvD;;AAEA,oDAAoD;AACpD;IACI,aAAa;IACb,eAAe;IACf,aAAa;IACb,OAAO;IACP,MAAM;IACN,WAAW;IACX,YAAY;IACZ,iCAAiC;IACjC,cAAc;AAClB;;AAEA;IACI,yBAAyB;IACzB,gBAAgB;IAChB,UAAU;IACV,yBAAyB;IACzB,kBAAkB;IAClB,UAAU;IACV,gBAAgB;IAChB,gBAAgB;IAChB,aAAa;IACb,sBAAsB;IACtB,qCAAqC;AACzC;;AAEA;IACI,aAAa;IACb,gCAAgC;IAChC,aAAa;IACb,8BAA8B;IAC9B,mBAAmB;AACvB;;AAEA;IACI,SAAS;IACT,cAAc;AAClB;;AAEA;IACI,aAAa;IACb,gBAAgB;IAChB,OAAO;AACX;;AAEA;IACI,aAAa;IACb,6BAA6B;IAC7B,aAAa;IACb,yBAAyB;AAC7B;;AAEA;IACI,WAAW;IACX,YAAY;IACZ,eAAe;IACf,iBAAiB;IACjB,eAAe;AACnB;;AAEA;;IAEI,WAAW;IACX,qBAAqB;AACzB;;AAEA,2BAA2B;AAC3B;IACI,mBAAmB;IACnB,oBAAoB;IACpB,gCAAgC;AACpC;;AAEA;IACI,mBAAmB;AACvB;;AAEA;IACI,mBAAmB;IACnB,cAAc;AAClB;;AAEA;IACI,aAAa;IACb,8BAA8B;IAC9B,kBAAkB;IAClB,gBAAgB;AACpB;;AAEA;IACI,WAAW;AACf;;AAEA;IACI,gBAAgB;AACpB;;AAEA,sCAAsC;AACtC;IACI,yBAAyB;AAC7B;;AAEA;IACI,yBAAyB;AAC7B;;AAEA;IACI,yBAAyB;AAC7B;;AAEA;IACI,aAAa;IACb,SAAS;IACT,gBAAgB;AACpB;;AAEA,2BAA2B;AAC3B;IACI,aAAa;IACb,4DAA4D;IAC5D,SAAS;AACb;;AAEA;IACI,gBAAgB;IAChB,aAAa;IACb,kBAAkB;IAClB,yBAAyB;AAC7B;;AAEA;IACI,aAAa;IACb,kBAAkB;AACtB;;AAEA;IACI,gBAAgB;IAChB,WAAW;IACX,mBAAmB;AACvB;;AAEA;IACI,WAAW;IACX,gBAAgB;AACpB","sourcesContent":["body, html {\r\n    padding: 0;\r\n    margin: 0;\r\n    background: #1a1a1a; /* Dark background */\r\n    color: #ffffff; /* White text */\r\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;\r\n    height: 100%;\r\n    width: 100%;\r\n    overflow: hidden; /* Default to hidden */\r\n}\r\n\r\n/* Style for pages where we want to allow scrolling */\r\nbody.allow-scroll {\r\n    overflow: auto;\r\n}\r\n\r\n#app-container {\r\n    display: flex;\r\n    flex-direction: column;\r\n    height: 100vh;\r\n    width: 100vw;\r\n    overflow: hidden; /* Prevent overflow by default */\r\n    background: #1a1a1a; /* Dark background */\r\n}\r\n\r\n/* Allow scrolling on home page */\r\n.allow-scroll #app-container {\r\n    overflow: auto;\r\n}\r\n\r\n#nav-container {\r\n    flex-shrink: 0;\r\n    position: relative;\r\n    z-index: 100;\r\n    background: #2d2d2d; /* Dark navigation */\r\n    border-bottom: 1px solid #404040;\r\n}\r\n\r\n#main-content {\r\n    flex: 1;\r\n    overflow: hidden; /* Hide overflow by default */\r\n    position: relative;\r\n    height: calc(100vh - 60px); /* Reserve space for navigation */\r\n    background: #1a1a1a;\r\n}\r\n\r\n/* Allow scrolling for home page */\r\n.allow-scroll #main-content {\r\n    overflow: auto;\r\n}\r\n\r\n/* Ensure pages fill their container completely */\r\n.builder-page,\r\n.simulation-page {\r\n    height: 100%;\r\n    width: 100%;\r\n    overflow: hidden;\r\n    position: relative;\r\n    background: #1a1a1a;\r\n}\r\n\r\n#canvas {\r\n    padding: 0;\r\n    margin: 0;\r\n    position: relative;\r\n    z-index: 1;\r\n    pointer-events: auto;\r\n    display: block;\r\n    background: #2d2d2d;\r\n    border: 1px solid #404040;\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n\r\n.visualizer-area {\r\n    flex: 1;\r\n    position: relative;\r\n    min-height: 600px;\r\n    background: #2d2d2d;\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: center;\r\n}\r\n\r\n.visualizer-area canvas {\r\n    width: 100% !important;\r\n    height: 100% !important;\r\n    max-width: 100% !important;\r\n    max-height: 100% !important;\r\n    background: #2d2d2d !important;\r\n    border: 1px solid #404040;\r\n    display: block !important;\r\n}\r\n\r\n.builder-content,\r\n.simulation-content {\r\n    display: flex;\r\n    height: 100%;\r\n}\r\n\r\n.sidebar {\r\n    width: 280px;\r\n    background: #2d2d2d;\r\n    border-right: 1px solid #404040;\r\n    overflow-y: auto;\r\n    pointer-events: auto;\r\n    z-index: 10;\r\n}\r\n\r\n/* Ensure buttons are always clickable */\r\nbutton, .btn {\r\n    pointer-events: auto;\r\n    cursor: pointer;\r\n    position: relative;\r\n    z-index: 20;\r\n}\r\n\r\n/* Debug helper - can be removed later */\r\n/* * { background-color: rgba(255, 0, 0, 0.1); } */\r\n/* * * { background-color: rgba(0, 255, 0, 0.2); } */\r\n/* * * * { background-color: rgba(0, 0, 255, 0.3); } */\r\n\r\n/* KPI Metrics Styles */\r\n.metrics-table-container {\r\n    margin-top: 10px;\r\n    max-height: 300px;\r\n    overflow-y: auto;\r\n    border: 1px solid #404040;\r\n    border-radius: 4px;\r\n    background: #2d2d2d;\r\n}\r\n\r\n.metrics-table {\r\n    width: 100%;\r\n    border-collapse: collapse;\r\n    font-size: 0.85em;\r\n}\r\n\r\n.metrics-table th,\r\n.metrics-table td {\r\n    padding: 6px 8px;\r\n    border: 1px solid #404040;\r\n    text-align: left;\r\n}\r\n\r\n.metrics-table th {\r\n    background-color: #333;\r\n    position: sticky;\r\n    top: 0;\r\n    z-index: 1;\r\n}\r\n\r\n.metrics-table tr:nth-child(even) {\r\n    background-color: #2a2a2a;\r\n}\r\n\r\n.metrics-table tr:hover {\r\n    background-color: #3a3a3a;\r\n}\r\n\r\n/* Color coding for congestion */\r\n.congested-row {\r\n    background-color: rgba(255, 99, 71, 0.2) !important; /* Tomato with transparency */\r\n}\r\n\r\n.moderate-row {\r\n    background-color: rgba(255, 165, 0, 0.2) !important; /* Orange with transparency */\r\n}\r\n\r\n/* KPI validation styles */\r\n.kpi-validation {\r\n    background-color: #2d2d2d;\r\n    border: 1px solid #404040;\r\n    border-radius: 4px;\r\n    padding: 15px;\r\n    margin-top: 10px;\r\n    overflow-y: auto;\r\n    max-height: 80vh;\r\n}\r\n\r\n.kpi-validation h3 {\r\n    margin-top: 0;\r\n    border-bottom: 1px solid #404040;\r\n    padding-bottom: 10px;\r\n    color: #f0f0f0;\r\n}\r\n\r\n.validation-table {\r\n    width: 100%;\r\n    border-collapse: collapse;\r\n    margin: 10px 0;\r\n}\r\n\r\n.validation-table th, \r\n.validation-table td {\r\n    padding: 6px 8px;\r\n    border: 1px solid #404040;\r\n    text-align: left;\r\n}\r\n\r\n.validation-table th {\r\n    background-color: #333;\r\n}\r\n\r\n.validation-error {\r\n    background-color: rgba(255, 99, 71, 0.2) !important;\r\n}\r\n\r\n.validation-success {\r\n    background-color: rgba(50, 205, 50, 0.2) !important;\r\n}\r\n\r\n/* Modal styles for validation and layout selector */\r\n.modal {\r\n    display: none;\r\n    position: fixed;\r\n    z-index: 1000;\r\n    left: 0;\r\n    top: 0;\r\n    width: 100%;\r\n    height: 100%;\r\n    background-color: rgba(0,0,0,0.7);\r\n    overflow: auto;\r\n}\r\n\r\n.modal-content {\r\n    background-color: #2d2d2d;\r\n    margin: 10% auto;\r\n    padding: 0;\r\n    border: 1px solid #404040;\r\n    border-radius: 4px;\r\n    width: 80%;\r\n    max-width: 800px;\r\n    max-height: 80vh;\r\n    display: flex;\r\n    flex-direction: column;\r\n    box-shadow: 0 4px 8px rgba(0,0,0,0.2);\r\n}\r\n\r\n.modal-header {\r\n    padding: 15px;\r\n    border-bottom: 1px solid #404040;\r\n    display: flex;\r\n    justify-content: space-between;\r\n    align-items: center;\r\n}\r\n\r\n.modal-header h2 {\r\n    margin: 0;\r\n    color: #f0f0f0;\r\n}\r\n\r\n.modal-body {\r\n    padding: 15px;\r\n    overflow-y: auto;\r\n    flex: 1;\r\n}\r\n\r\n.modal-footer {\r\n    padding: 15px;\r\n    border-top: 1px solid #404040;\r\n    display: flex;\r\n    justify-content: flex-end;\r\n}\r\n\r\n.close {\r\n    color: #aaa;\r\n    float: right;\r\n    font-size: 28px;\r\n    font-weight: bold;\r\n    cursor: pointer;\r\n}\r\n\r\n.close:hover,\r\n.close:focus {\r\n    color: #fff;\r\n    text-decoration: none;\r\n}\r\n\r\n/* Analytics panel styles */\r\n.analytics-section {\r\n    margin-bottom: 15px;\r\n    padding-bottom: 10px;\r\n    border-bottom: 1px solid #404040;\r\n}\r\n\r\n.analytics-section:last-child {\r\n    border-bottom: none;\r\n}\r\n\r\n.analytics-section h4 {\r\n    margin-bottom: 10px;\r\n    color: #f0f0f0;\r\n}\r\n\r\n.metric {\r\n    display: flex;\r\n    justify-content: space-between;\r\n    margin-bottom: 5px;\r\n    font-size: 0.9em;\r\n}\r\n\r\n.metric .label {\r\n    color: #bbb;\r\n}\r\n\r\n.metric .value {\r\n    font-weight: 500;\r\n}\r\n\r\n/* Color coding for congestion index */\r\n.good {\r\n    color: #4caf50 !important;\r\n}\r\n\r\n.warning {\r\n    color: #ff9800 !important;\r\n}\r\n\r\n.critical {\r\n    color: #f44336 !important;\r\n}\r\n\r\n.analytics-actions {\r\n    display: flex;\r\n    gap: 10px;\r\n    margin-top: 15px;\r\n}\r\n\r\n/* Layout selector styles */\r\n.layout-options {\r\n    display: grid;\r\n    grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));\r\n    gap: 15px;\r\n}\r\n\r\n.layout-option {\r\n    background: #333;\r\n    padding: 15px;\r\n    border-radius: 4px;\r\n    border: 1px solid #404040;\r\n}\r\n\r\n.layout-option h4 {\r\n    margin-top: 0;\r\n    margin-bottom: 5px;\r\n}\r\n\r\n.layout-meta {\r\n    font-size: 0.9em;\r\n    color: #bbb;\r\n    margin-bottom: 10px;\r\n}\r\n\r\n.load-layout-btn {\r\n    width: 100%;\r\n    margin-top: 10px;\r\n}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = [];

  // return the list of modules as css string
  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";
      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }
      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }
      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }
      content += cssWithMappingToString(item);
      if (needLayer) {
        content += "}";
      }
      if (item[2]) {
        content += "}";
      }
      if (item[4]) {
        content += "}";
      }
      return content;
    }).join("");
  };

  // import a list of modules into the list
  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }
    var alreadyImportedModules = {};
    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];
        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }
    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);
      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }
      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }
      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }
      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }
      list.push(item);
    }
  };
  return list;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/sourceMaps.js":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";


module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];
  if (!cssMapping) {
    return content;
  }
  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    return [content].concat([sourceMapping]).join("\n");
  }
  return [content].join("\n");
};

/***/ }),

/***/ "./node_modules/jquery-mousewheel/jquery.mousewheel.js":
/*!*************************************************************!*\
  !*** ./node_modules/jquery-mousewheel/jquery.mousewheel.js ***!
  \*************************************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery Mousewheel 3.2.2
 * Copyright OpenJS Foundation and other contributors
 */

( function( factory ) {
    "use strict";

    if ( true ) {

        // AMD. Register as an anonymous module.
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js") ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else // removed by dead control flow
{}
} )( function( $ ) {
    "use strict";

    var nullLowestDeltaTimeout, lowestDelta,
        modernEvents = !!$.fn.on,
        toFix  = [ "wheel", "mousewheel", "DOMMouseScroll", "MozMousePixelScroll" ],
        toBind = ( "onwheel" in window.document || window.document.documentMode >= 9 ) ?
            [ "wheel" ] : [ "mousewheel", "DomMouseScroll", "MozMousePixelScroll" ],
        slice  = Array.prototype.slice;

    if ( $.event.fixHooks ) {
        for ( var i = toFix.length; i; ) {
            $.event.fixHooks[ toFix[ --i ] ] = $.event.mouseHooks;
        }
    }

    var special = $.event.special.mousewheel = {
        version: "3.2.2",

        setup: function() {
            if ( this.addEventListener ) {
                for ( var i = toBind.length; i; ) {
                    this.addEventListener( toBind[ --i ], handler, false );
                }
            } else {
                this.onmousewheel = handler;
            }

            // Store the line height and page height for this particular element
            $.data( this, "mousewheel-line-height", special.getLineHeight( this ) );
            $.data( this, "mousewheel-page-height", special.getPageHeight( this ) );
        },

        teardown: function() {
            if ( this.removeEventListener ) {
                for ( var i = toBind.length; i; ) {
                    this.removeEventListener( toBind[ --i ], handler, false );
                }
            } else {
                this.onmousewheel = null;
            }

            // Clean up the data we added to the element
            $.removeData( this, "mousewheel-line-height" );
            $.removeData( this, "mousewheel-page-height" );
        },

        getLineHeight: function( elem ) {
            var $elem = $( elem ),
                $parent = $elem[ "offsetParent" in $.fn ? "offsetParent" : "parent" ]();
            if ( !$parent.length ) {
                $parent = $( "body" );
            }
            return parseInt( $parent.css( "fontSize" ), 10 ) ||
                parseInt( $elem.css( "fontSize" ), 10 ) || 16;
        },

        getPageHeight: function( elem ) {
            return $( elem ).height();
        },

        settings: {
            adjustOldDeltas: true, // see shouldAdjustOldDeltas() below
            normalizeOffset: true  // calls getBoundingClientRect for each event
        }
    };

    $.fn.extend( {
        mousewheel: function( fn ) {
            return fn ?
                this[ modernEvents ? "on" : "bind" ]( "mousewheel", fn ) :
                this.trigger( "mousewheel" );
        },

        unmousewheel: function( fn ) {
            return this[ modernEvents ? "off" : "unbind" ]( "mousewheel", fn );
        }
    } );


    function handler( event ) {
        var orgEvent   = event || window.event,
            args       = slice.call( arguments, 1 ),
            delta      = 0,
            deltaX     = 0,
            deltaY     = 0,
            absDelta   = 0;
        event = $.event.fix( orgEvent );
        event.type = "mousewheel";

        // Old school scrollwheel delta
        if ( "detail" in orgEvent ) {
            deltaY = orgEvent.detail * -1;
        }
        if ( "wheelDelta" in orgEvent ) {
            deltaY = orgEvent.wheelDelta;
        }
        if ( "wheelDeltaY" in orgEvent ) {
            deltaY = orgEvent.wheelDeltaY;
        }
        if ( "wheelDeltaX" in orgEvent ) {
            deltaX = orgEvent.wheelDeltaX * -1;
        }

        // Firefox < 17 horizontal scrolling related to DOMMouseScroll event
        if ( "axis" in orgEvent && orgEvent.axis === orgEvent.HORIZONTAL_AXIS ) {
            deltaX = deltaY * -1;
            deltaY = 0;
        }

        // Set delta to be deltaY or deltaX if deltaY is 0 for backwards compatability
        delta = deltaY === 0 ? deltaX : deltaY;

        // New school wheel delta (wheel event)
        if ( "deltaY" in orgEvent ) {
            deltaY = orgEvent.deltaY * -1;
            delta  = deltaY;
        }
        if ( "deltaX" in orgEvent ) {
            deltaX = orgEvent.deltaX;
            if ( deltaY === 0 ) {
                delta  = deltaX * -1;
            }
        }

        // No change actually happened, no reason to go any further
        if ( deltaY === 0 && deltaX === 0 ) {
            return;
        }

        // Need to convert lines and pages to pixels if we aren't already in pixels
        // There are three delta modes:
        //   * deltaMode 0 is by pixels, nothing to do
        //   * deltaMode 1 is by lines
        //   * deltaMode 2 is by pages
        if ( orgEvent.deltaMode === 1 ) {
            var lineHeight = $.data( this, "mousewheel-line-height" );
            delta  *= lineHeight;
            deltaY *= lineHeight;
            deltaX *= lineHeight;
        } else if ( orgEvent.deltaMode === 2 ) {
            var pageHeight = $.data( this, "mousewheel-page-height" );
            delta  *= pageHeight;
            deltaY *= pageHeight;
            deltaX *= pageHeight;
        }

        // Store lowest absolute delta to normalize the delta values
        absDelta = Math.max( Math.abs( deltaY ), Math.abs( deltaX ) );

        if ( !lowestDelta || absDelta < lowestDelta ) {
            lowestDelta = absDelta;

            // Adjust older deltas if necessary
            if ( shouldAdjustOldDeltas( orgEvent, absDelta ) ) {
                lowestDelta /= 40;
            }
        }

        // Adjust older deltas if necessary
        if ( shouldAdjustOldDeltas( orgEvent, absDelta ) ) {

            // Divide all the things by 40!
            delta  /= 40;
            deltaX /= 40;
            deltaY /= 40;
        }

        // Get a whole, normalized value for the deltas
        delta  = Math[ delta  >= 1 ? "floor" : "ceil" ]( delta  / lowestDelta );
        deltaX = Math[ deltaX >= 1 ? "floor" : "ceil" ]( deltaX / lowestDelta );
        deltaY = Math[ deltaY >= 1 ? "floor" : "ceil" ]( deltaY / lowestDelta );

        // Normalise offsetX and offsetY properties
        if ( special.settings.normalizeOffset && this.getBoundingClientRect ) {
            var boundingRect = this.getBoundingClientRect();
            event.offsetX = event.clientX - boundingRect.left;
            event.offsetY = event.clientY - boundingRect.top;
        }

        // Add information to the event object
        event.deltaX = deltaX;
        event.deltaY = deltaY;
        event.deltaFactor = lowestDelta;

        // Go ahead and set deltaMode to 0 since we converted to pixels
        // Although this is a little odd since we overwrite the deltaX/Y
        // properties with normalized deltas.
        event.deltaMode = 0;

        // Add event and delta to the front of the arguments
        args.unshift( event, delta, deltaX, deltaY );

        // Clear out lowestDelta after sometime to better
        // handle multiple device types that give different
        // a different lowestDelta
        // Ex: trackpad = 3 and mouse wheel = 120
        if ( nullLowestDeltaTimeout ) {
            window.clearTimeout( nullLowestDeltaTimeout );
        }
        nullLowestDeltaTimeout = window.setTimeout( function() {
            lowestDelta = null;
        }, 200 );

        return ( $.event.dispatch || $.event.handle ).apply( this, args );
    }

    function shouldAdjustOldDeltas( orgEvent, absDelta ) {

        // If this is an older event and the delta is divisible by 120,
        // then we are assuming that the browser is treating this as an
        // older mouse wheel event and that we should divide the deltas
        // by 40 to try and get a more usable deltaFactor.
        // Side note, this actually impacts the reported scroll distance
        // in older browsers and can cause scrolling to be slower than native.
        // Turn this off by setting $.event.special.mousewheel.settings.adjustOldDeltas to false.
        return special.settings.adjustOldDeltas && orgEvent.type === "mousewheel" &&
            absDelta % 120 === 0;
    }

} );


/***/ }),

/***/ "./node_modules/jquery/dist/jquery.js":
/*!********************************************!*\
  !*** ./node_modules/jquery/dist/jquery.js ***!
  \********************************************/
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery JavaScript Library v3.7.1
 * https://jquery.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2023-08-28T13:37Z
 */
( function( global, factory ) {

	"use strict";

	if (  true && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket trac-14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var flat = arr.flat ? function( array ) {
	return arr.flat.call( array );
} : function( array ) {
	return arr.concat.apply( [], array );
};


var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

		// Support: Chrome <=57, Firefox <=52
		// In some browsers, typeof returns "function" for HTML <object> elements
		// (i.e., `typeof document.createElement( "object" ) === "function"`).
		// We don't want to classify *any* DOM node as a function.
		// Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5
		// Plus for old WebKit, typeof returns "function" for HTML collections
		// (e.g., `typeof document.getElementsByTagName("div") === "function"`). (gh-4756)
		return typeof obj === "function" && typeof obj.nodeType !== "number" &&
			typeof obj.item !== "function";
	};


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};


var document = window.document;



	var preservedScriptAttributes = {
		type: true,
		src: true,
		nonce: true,
		noModule: true
	};

	function DOMEval( code, node, doc ) {
		doc = doc || document;

		var i, val,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {

				// Support: Firefox 64+, Edge 18+
				// Some browsers don't support the "nonce" property on scripts.
				// On the other hand, just using `getAttribute` is not enough as
				// the `nonce` attribute is reset to an empty string whenever it
				// becomes browsing-context connected.
				// See https://github.com/whatwg/html/issues/2369
				// See https://html.spec.whatwg.org/#nonce-attributes
				// The `node.getAttribute` check was added for the sake of
				// `jQuery.globalEval` so that it can fake a nonce-containing node
				// via an object.
				val = node[ i ] || node.getAttribute && node.getAttribute( i );
				if ( val ) {
					script.setAttribute( i, val );
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var version = "3.7.1",

	rhtmlSuffix = /HTML$/i,

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	even: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return ( i + 1 ) % 2;
		} ) );
	},

	odd: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return i % 2;
		} ) );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				copy = options[ name ];

				// Prevent Object.prototype pollution
				// Prevent never-ending loop
				if ( name === "__proto__" || target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {
					src = target[ name ];

					// Ensure proper type for the source value
					if ( copyIsArray && !Array.isArray( src ) ) {
						clone = [];
					} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
						clone = {};
					} else {
						clone = src;
					}
					copyIsArray = false;

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a provided context; falls back to the global one
	// if not specified.
	globalEval: function( code, options, doc ) {
		DOMEval( code, { nonce: options && options.nonce }, doc );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},


	// Retrieve the text value of an array of DOM nodes
	text: function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;

		if ( !nodeType ) {

			// If no nodeType, this is expected to be an array
			while ( ( node = elem[ i++ ] ) ) {

				// Do not traverse comment nodes
				ret += jQuery.text( node );
			}
		}
		if ( nodeType === 1 || nodeType === 11 ) {
			return elem.textContent;
		}
		if ( nodeType === 9 ) {
			return elem.documentElement.textContent;
		}
		if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}

		// Do not include comment or processing instruction nodes

		return ret;
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
						[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	isXMLDoc: function( elem ) {
		var namespace = elem && elem.namespaceURI,
			docElem = elem && ( elem.ownerDocument || elem ).documentElement;

		// Assume HTML when documentElement doesn't yet exist, such as inside
		// document fragments.
		return !rhtmlSuffix.test( namespace || docElem && docElem.nodeName || "HTML" );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return flat( ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( _i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}


function nodeName( elem, name ) {

	return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

}
var pop = arr.pop;


var sort = arr.sort;


var splice = arr.splice;


var whitespace = "[\\x20\\t\\r\\n\\f]";


var rtrimCSS = new RegExp(
	"^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$",
	"g"
);




// Note: an element does not contain itself
jQuery.contains = function( a, b ) {
	var bup = b && b.parentNode;

	return a === bup || !!( bup && bup.nodeType === 1 && (

		// Support: IE 9 - 11+
		// IE doesn't have `contains` on SVG.
		a.contains ?
			a.contains( bup ) :
			a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
	) );
};




// CSS string/identifier serialization
// https://drafts.csswg.org/cssom/#common-serializing-idioms
var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;

function fcssescape( ch, asCodePoint ) {
	if ( asCodePoint ) {

		// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
		if ( ch === "\0" ) {
			return "\uFFFD";
		}

		// Control characters and (dependent upon position) numbers get escaped as code points
		return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
	}

	// Other potentially-special ASCII characters get backslash-escaped
	return "\\" + ch;
}

jQuery.escapeSelector = function( sel ) {
	return ( sel + "" ).replace( rcssescape, fcssescape );
};




var preferredDoc = document,
	pushNative = push;

( function() {

var i,
	Expr,
	outermostContext,
	sortInput,
	hasDuplicate,
	push = pushNative,

	// Local document vars
	document,
	documentElement,
	documentIsHTML,
	rbuggyQSA,
	matches,

	// Instance-specific data
	expando = jQuery.expando,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	nonnativeSelectorCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|" +
		"loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
	identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace +
		"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",

	// Attribute selectors: https://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +

		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +

		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" +
		whitespace + "*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +

		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +

		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +

		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rleadingCombinator = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" +
		whitespace + "*" ),
	rdescend = new RegExp( whitespace + "|>" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		ID: new RegExp( "^#(" + identifier + ")" ),
		CLASS: new RegExp( "^\\.(" + identifier + ")" ),
		TAG: new RegExp( "^(" + identifier + "|[*])" ),
		ATTR: new RegExp( "^" + attributes ),
		PSEUDO: new RegExp( "^" + pseudos ),
		CHILD: new RegExp(
			"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
				whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" +
				whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		bool: new RegExp( "^(?:" + booleans + ")$", "i" ),

		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		needsContext: new RegExp( "^" + whitespace +
			"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
			"*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// https://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\[\\da-fA-F]{1,6}" + whitespace +
		"?|\\\\([^\\r\\n\\f])", "g" ),
	funescape = function( escape, nonHex ) {
		var high = "0x" + escape.slice( 1 ) - 0x10000;

		if ( nonHex ) {

			// Strip the backslash prefix from a non-hex escape sequence
			return nonHex;
		}

		// Replace a hexadecimal escape sequence with the encoded Unicode code point
		// Support: IE <=11+
		// For values outside the Basic Multilingual Plane (BMP), manually construct a
		// surrogate pair
		return high < 0 ?
			String.fromCharCode( high + 0x10000 ) :
			String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// Used for iframes; see `setDocument`.
	// Support: IE 9 - 11+, Edge 12 - 18+
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE/Edge.
	unloadHandler = function() {
		setDocument();
	},

	inDisabledFieldset = addCombinator(
		function( elem ) {
			return elem.disabled === true && nodeName( elem, "fieldset" );
		},
		{ dir: "parentNode", next: "legend" }
	);

// Support: IE <=9 only
// Accessing document.activeElement can throw unexpectedly
// https://bugs.jquery.com/ticket/13393
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		( arr = slice.call( preferredDoc.childNodes ) ),
		preferredDoc.childNodes
	);

	// Support: Android <=4.0
	// Detect silently failing push.apply
	// eslint-disable-next-line no-unused-expressions
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = {
		apply: function( target, els ) {
			pushNative.apply( target, slice.call( els ) );
		},
		call: function( target ) {
			pushNative.apply( target, slice.call( arguments, 1 ) );
		}
	};
}

function find( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {
		setDocument( context );
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {

				// ID selector
				if ( ( m = match[ 1 ] ) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( ( elem = context.getElementById( m ) ) ) {

							// Support: IE 9 only
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								push.call( results, elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE 9 only
						// getElementById can match elements by name instead of ID
						if ( newContext && ( elem = newContext.getElementById( m ) ) &&
							find.contains( context, elem ) &&
							elem.id === m ) {

							push.call( results, elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[ 2 ] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( ( m = match[ 3 ] ) && context.getElementsByClassName ) {
					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( !nonnativeSelectorCache[ selector + " " ] &&
				( !rbuggyQSA || !rbuggyQSA.test( selector ) ) ) {

				newSelector = selector;
				newContext = context;

				// qSA considers elements outside a scoping root when evaluating child or
				// descendant combinators, which is not what we want.
				// In such cases, we work around the behavior by prefixing every selector in the
				// list with an ID selector referencing the scope context.
				// The technique has to be used as well when a leading combinator is used
				// as such selectors are not recognized by querySelectorAll.
				// Thanks to Andrew Dupont for this technique.
				if ( nodeType === 1 &&
					( rdescend.test( selector ) || rleadingCombinator.test( selector ) ) ) {

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;

					// We can use :scope instead of the ID hack if the browser
					// supports it & if we're not changing the context.
					// Support: IE 11+, Edge 17 - 18+
					// IE/Edge sometimes throw a "Permission denied" error when
					// strict-comparing two documents; shallow comparisons work.
					// eslint-disable-next-line eqeqeq
					if ( newContext != context || !support.scope ) {

						// Capture the context ID, setting it first if necessary
						if ( ( nid = context.getAttribute( "id" ) ) ) {
							nid = jQuery.escapeSelector( nid );
						} else {
							context.setAttribute( "id", ( nid = expando ) );
						}
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[ i ] = ( nid ? "#" + nid : ":scope" ) + " " +
							toSelector( groups[ i ] );
					}
					newSelector = groups.join( "," );
				}

				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch ( qsaError ) {
					nonnativeSelectorCache( selector, true );
				} finally {
					if ( nid === expando ) {
						context.removeAttribute( "id" );
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrimCSS, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {

		// Use (key + " ") to avoid collision with native prototype properties
		// (see https://github.com/jquery/sizzle/issues/157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {

			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return ( cache[ key + " " ] = value );
	}
	return cache;
}

/**
 * Mark a function for special use by jQuery selector module
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement( "fieldset" );

	try {
		return !!fn( el );
	} catch ( e ) {
		return false;
	} finally {

		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}

		// release memory in IE
		el = null;
	}
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		return nodeName( elem, "input" ) && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		return ( nodeName( elem, "input" ) || nodeName( elem, "button" ) ) &&
			elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11+
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					elem.isDisabled !== !disabled &&
						inDisabledFieldset( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction( function( argument ) {
		argument = +argument;
		return markFunction( function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ ( j = matchIndexes[ i ] ) ] ) {
					seed[ j ] = !( matches[ j ] = seed[ j ] );
				}
			}
		} );
	} );
}

/**
 * Checks a node for validity as a jQuery selector context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [node] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
function setDocument( node ) {
	var subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	documentElement = document.documentElement;
	documentIsHTML = !jQuery.isXMLDoc( document );

	// Support: iOS 7 only, IE 9 - 11+
	// Older browsers didn't support unprefixed `matches`.
	matches = documentElement.matches ||
		documentElement.webkitMatchesSelector ||
		documentElement.msMatchesSelector;

	// Support: IE 9 - 11+, Edge 12 - 18+
	// Accessing iframe documents after unload throws "permission denied" errors
	// (see trac-13936).
	// Limit the fix to IE & Edge Legacy; despite Edge 15+ implementing `matches`,
	// all IE 9+ and Edge Legacy versions implement `msMatchesSelector` as well.
	if ( documentElement.msMatchesSelector &&

		// Support: IE 11+, Edge 17 - 18+
		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
		// two documents; shallow comparisons work.
		// eslint-disable-next-line eqeqeq
		preferredDoc != document &&
		( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {

		// Support: IE 9 - 11+, Edge 12 - 18+
		subWindow.addEventListener( "unload", unloadHandler );
	}

	// Support: IE <10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert( function( el ) {
		documentElement.appendChild( el ).id = jQuery.expando;
		return !document.getElementsByName ||
			!document.getElementsByName( jQuery.expando ).length;
	} );

	// Support: IE 9 only
	// Check to see if it's possible to do matchesSelector
	// on a disconnected node.
	support.disconnectedMatch = assert( function( el ) {
		return matches.call( el, "*" );
	} );

	// Support: IE 9 - 11+, Edge 12 - 18+
	// IE/Edge don't support the :scope pseudo-class.
	support.scope = assert( function() {
		return document.querySelectorAll( ":scope" );
	} );

	// Support: Chrome 105 - 111 only, Safari 15.4 - 16.3 only
	// Make sure the `:has()` argument is parsed unforgivingly.
	// We include `*` in the test to detect buggy implementations that are
	// _selectively_ forgiving (specifically when the list includes at least
	// one valid selector).
	// Note that we treat complete lack of support for `:has()` as if it were
	// spec-compliant support, which is fine because use of `:has()` in such
	// environments will fail in the qSA path and fall back to jQuery traversal
	// anyway.
	support.cssHas = assert( function() {
		try {
			document.querySelector( ":has(*,:jqfake)" );
			return false;
		} catch ( e ) {
			return true;
		}
	} );

	// ID filter and find
	if ( support.getById ) {
		Expr.filter.ID = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute( "id" ) === attrId;
			};
		};
		Expr.find.ID = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter.ID =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode( "id" );
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find.ID = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode( "id" );
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( ( elem = elems[ i++ ] ) ) {
						node = elem.getAttributeNode( "id" );
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find.TAG = function( tag, context ) {
		if ( typeof context.getElementsByTagName !== "undefined" ) {
			return context.getElementsByTagName( tag );

		// DocumentFragment nodes don't have gEBTN
		} else {
			return context.querySelectorAll( tag );
		}
	};

	// Class
	Expr.find.CLASS = function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	rbuggyQSA = [];

	// Build QSA regex
	// Regex strategy adopted from Diego Perini
	assert( function( el ) {

		var input;

		documentElement.appendChild( el ).innerHTML =
			"<a id='" + expando + "' href='' disabled='disabled'></a>" +
			"<select id='" + expando + "-\r\\' disabled='disabled'>" +
			"<option selected=''></option></select>";

		// Support: iOS <=7 - 8 only
		// Boolean attributes and "value" are not treated correctly in some XML documents
		if ( !el.querySelectorAll( "[selected]" ).length ) {
			rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
		}

		// Support: iOS <=7 - 8 only
		if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
			rbuggyQSA.push( "~=" );
		}

		// Support: iOS 8 only
		// https://bugs.webkit.org/show_bug.cgi?id=136851
		// In-page `selector#id sibling-combinator selector` fails
		if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
			rbuggyQSA.push( ".#.+[+~]" );
		}

		// Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+
		// In some of the document kinds, these selectors wouldn't work natively.
		// This is probably OK but for backwards compatibility we want to maintain
		// handling them through jQuery traversal in jQuery 3.x.
		if ( !el.querySelectorAll( ":checked" ).length ) {
			rbuggyQSA.push( ":checked" );
		}

		// Support: Windows 8 Native Apps
		// The type and name attributes are restricted during .innerHTML assignment
		input = document.createElement( "input" );
		input.setAttribute( "type", "hidden" );
		el.appendChild( input ).setAttribute( "name", "D" );

		// Support: IE 9 - 11+
		// IE's :disabled selector does not pick up the children of disabled fieldsets
		// Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+
		// In some of the document kinds, these selectors wouldn't work natively.
		// This is probably OK but for backwards compatibility we want to maintain
		// handling them through jQuery traversal in jQuery 3.x.
		documentElement.appendChild( el ).disabled = true;
		if ( el.querySelectorAll( ":disabled" ).length !== 2 ) {
			rbuggyQSA.push( ":enabled", ":disabled" );
		}

		// Support: IE 11+, Edge 15 - 18+
		// IE 11/Edge don't find elements on a `[name='']` query in some cases.
		// Adding a temporary attribute to the document before the selection works
		// around the issue.
		// Interestingly, IE 10 & older don't seem to have the issue.
		input = document.createElement( "input" );
		input.setAttribute( "name", "" );
		el.appendChild( input );
		if ( !el.querySelectorAll( "[name='']" ).length ) {
			rbuggyQSA.push( "\\[" + whitespace + "*name" + whitespace + "*=" +
				whitespace + "*(?:''|\"\")" );
		}
	} );

	if ( !support.cssHas ) {

		// Support: Chrome 105 - 110+, Safari 15.4 - 16.3+
		// Our regular `try-catch` mechanism fails to detect natively-unsupported
		// pseudo-classes inside `:has()` (such as `:has(:contains("Foo"))`)
		// in browsers that parse the `:has()` argument as a forgiving selector list.
		// https://drafts.csswg.org/selectors/#relational now requires the argument
		// to be parsed unforgivingly, but browsers have not yet fully adjusted.
		rbuggyQSA.push( ":has" );
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( "|" ) );

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		// Support: IE 11+, Edge 17 - 18+
		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
		// two documents; shallow comparisons work.
		// eslint-disable-next-line eqeqeq
		compare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {

			// Choose the first element that is related to our preferred document
			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( a === document || a.ownerDocument == preferredDoc &&
				find.contains( preferredDoc, a ) ) {
				return -1;
			}

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( b === document || b.ownerDocument == preferredDoc &&
				find.contains( preferredDoc, b ) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	};

	return document;
}

find.matches = function( expr, elements ) {
	return find( expr, null, null, elements );
};

find.matchesSelector = function( elem, expr ) {
	setDocument( elem );

	if ( documentIsHTML &&
		!nonnativeSelectorCache[ expr + " " ] &&
		( !rbuggyQSA || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||

					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch ( e ) {
			nonnativeSelectorCache( expr, true );
		}
	}

	return find( expr, document, null, [ elem ] ).length > 0;
};

find.contains = function( context, elem ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( context.ownerDocument || context ) != document ) {
		setDocument( context );
	}
	return jQuery.contains( context, elem );
};


find.attr = function( elem, name ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( elem.ownerDocument || elem ) != document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],

		// Don't get fooled by Object.prototype properties (see trac-13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	if ( val !== undefined ) {
		return val;
	}

	return elem.getAttribute( name );
};

find.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
jQuery.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	//
	// Support: Android <=4.0+
	// Testing for detecting duplicates is unpredictable so instead assume we can't
	// depend on duplicate detection in all browsers without a stable sort.
	hasDuplicate = !support.sortStable;
	sortInput = !support.sortStable && slice.call( results, 0 );
	sort.call( results, sortOrder );

	if ( hasDuplicate ) {
		while ( ( elem = results[ i++ ] ) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			splice.call( results, duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

jQuery.fn.uniqueSort = function() {
	return this.pushStack( jQuery.uniqueSort( slice.apply( this ) ) );
};

Expr = jQuery.expr = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		ATTR: function( match ) {
			match[ 1 ] = match[ 1 ].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[ 3 ] = ( match[ 3 ] || match[ 4 ] || match[ 5 ] || "" )
				.replace( runescape, funescape );

			if ( match[ 2 ] === "~=" ) {
				match[ 3 ] = " " + match[ 3 ] + " ";
			}

			return match.slice( 0, 4 );
		},

		CHILD: function( match ) {

			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[ 1 ] = match[ 1 ].toLowerCase();

			if ( match[ 1 ].slice( 0, 3 ) === "nth" ) {

				// nth-* requires argument
				if ( !match[ 3 ] ) {
					find.error( match[ 0 ] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[ 4 ] = +( match[ 4 ] ?
					match[ 5 ] + ( match[ 6 ] || 1 ) :
					2 * ( match[ 3 ] === "even" || match[ 3 ] === "odd" )
				);
				match[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === "odd" );

			// other types prohibit arguments
			} else if ( match[ 3 ] ) {
				find.error( match[ 0 ] );
			}

			return match;
		},

		PSEUDO: function( match ) {
			var excess,
				unquoted = !match[ 6 ] && match[ 2 ];

			if ( matchExpr.CHILD.test( match[ 0 ] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[ 3 ] ) {
				match[ 2 ] = match[ 4 ] || match[ 5 ] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&

				// Get excess from tokenize (recursively)
				( excess = tokenize( unquoted, true ) ) &&

				// advance to the next closing parenthesis
				( excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length ) ) {

				// excess is a negative index
				match[ 0 ] = match[ 0 ].slice( 0, excess );
				match[ 2 ] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		TAG: function( nodeNameSelector ) {
			var expectedNodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() {
					return true;
				} :
				function( elem ) {
					return nodeName( elem, expectedNodeName );
				};
		},

		CLASS: function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				( pattern = new RegExp( "(^|" + whitespace + ")" + className +
					"(" + whitespace + "|$)" ) ) &&
				classCache( className, function( elem ) {
					return pattern.test(
						typeof elem.className === "string" && elem.className ||
							typeof elem.getAttribute !== "undefined" &&
								elem.getAttribute( "class" ) ||
							""
					);
				} );
		},

		ATTR: function( name, operator, check ) {
			return function( elem ) {
				var result = find.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				if ( operator === "=" ) {
					return result === check;
				}
				if ( operator === "!=" ) {
					return result !== check;
				}
				if ( operator === "^=" ) {
					return check && result.indexOf( check ) === 0;
				}
				if ( operator === "*=" ) {
					return check && result.indexOf( check ) > -1;
				}
				if ( operator === "$=" ) {
					return check && result.slice( -check.length ) === check;
				}
				if ( operator === "~=" ) {
					return ( " " + result.replace( rwhitespace, " " ) + " " )
						.indexOf( check ) > -1;
				}
				if ( operator === "|=" ) {
					return result === check || result.slice( 0, check.length + 1 ) === check + "-";
				}

				return false;
			};
		},

		CHILD: function( type, what, _argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, _context, xml ) {
					var cache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( ( node = node[ dir ] ) ) {
									if ( ofType ?
										nodeName( node, name ) :
										node.nodeType === 1 ) {

										return false;
									}
								}

								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index
							outerCache = parent[ expando ] || ( parent[ expando ] = {} );
							cache = outerCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( ( node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								( diff = nodeIndex = 0 ) || start.pop() ) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {

							// Use previously-cached element index if available
							if ( useCache ) {
								outerCache = elem[ expando ] || ( elem[ expando ] = {} );
								cache = outerCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {

								// Use the same loop as above to seek `elem` from the start
								while ( ( node = ++nodeIndex && node && node[ dir ] ||
									( diff = nodeIndex = 0 ) || start.pop() ) ) {

									if ( ( ofType ?
										nodeName( node, name ) :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] ||
												( node[ expando ] = {} );
											outerCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		PSEUDO: function( pseudo, argument ) {

			// pseudo-class names are case-insensitive
			// https://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					find.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as jQuery does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction( function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf.call( seed, matched[ i ] );
							seed[ idx ] = !( matches[ idx ] = matched[ i ] );
						}
					} ) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {

		// Potentially complex pseudos
		not: markFunction( function( selector ) {

			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrimCSS, "$1" ) );

			return matcher[ expando ] ?
				markFunction( function( seed, matches, _context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( ( elem = unmatched[ i ] ) ) {
							seed[ i ] = !( matches[ i ] = elem );
						}
					}
				} ) :
				function( elem, _context, xml ) {
					input[ 0 ] = elem;
					matcher( input, null, xml, results );

					// Don't keep the element
					// (see https://github.com/jquery/sizzle/issues/299)
					input[ 0 ] = null;
					return !results.pop();
				};
		} ),

		has: markFunction( function( selector ) {
			return function( elem ) {
				return find( selector, elem ).length > 0;
			};
		} ),

		contains: markFunction( function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || jQuery.text( elem ) ).indexOf( text ) > -1;
			};
		} ),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// https://www.w3.org/TR/selectors/#lang-pseudo
		lang: markFunction( function( lang ) {

			// lang value must be a valid identifier
			if ( !ridentifier.test( lang || "" ) ) {
				find.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( ( elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute( "xml:lang" ) || elem.getAttribute( "lang" ) ) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );
				return false;
			};
		} ),

		// Miscellaneous
		target: function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		root: function( elem ) {
			return elem === documentElement;
		},

		focus: function( elem ) {
			return elem === safeActiveElement() &&
				document.hasFocus() &&
				!!( elem.type || elem.href || ~elem.tabIndex );
		},

		// Boolean properties
		enabled: createDisabledPseudo( false ),
		disabled: createDisabledPseudo( true ),

		checked: function( elem ) {

			// In CSS3, :checked should return both checked and selected elements
			// https://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			return ( nodeName( elem, "input" ) && !!elem.checked ) ||
				( nodeName( elem, "option" ) && !!elem.selected );
		},

		selected: function( elem ) {

			// Support: IE <=11+
			// Accessing the selectedIndex property
			// forces the browser to treat the default option as
			// selected when in an optgroup.
			if ( elem.parentNode ) {
				// eslint-disable-next-line no-unused-expressions
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		empty: function( elem ) {

			// https://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		parent: function( elem ) {
			return !Expr.pseudos.empty( elem );
		},

		// Element/input types
		header: function( elem ) {
			return rheader.test( elem.nodeName );
		},

		input: function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		button: function( elem ) {
			return nodeName( elem, "input" ) && elem.type === "button" ||
				nodeName( elem, "button" );
		},

		text: function( elem ) {
			var attr;
			return nodeName( elem, "input" ) && elem.type === "text" &&

				// Support: IE <10 only
				// New HTML5 attribute values (e.g., "search") appear
				// with elem.type === "text"
				( ( attr = elem.getAttribute( "type" ) ) == null ||
					attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		first: createPositionalPseudo( function() {
			return [ 0 ];
		} ),

		last: createPositionalPseudo( function( _matchIndexes, length ) {
			return [ length - 1 ];
		} ),

		eq: createPositionalPseudo( function( _matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		} ),

		even: createPositionalPseudo( function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		odd: createPositionalPseudo( function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		lt: createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i;

			if ( argument < 0 ) {
				i = argument + length;
			} else if ( argument > length ) {
				i = length;
			} else {
				i = argument;
			}

			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		gt: createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} )
	}
};

Expr.pseudos.nth = Expr.pseudos.eq;

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

function tokenize( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || ( match = rcomma.exec( soFar ) ) ) {
			if ( match ) {

				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[ 0 ].length ) || soFar;
			}
			groups.push( ( tokens = [] ) );
		}

		matched = false;

		// Combinators
		if ( ( match = rleadingCombinator.exec( soFar ) ) ) {
			matched = match.shift();
			tokens.push( {
				value: matched,

				// Cast descendant combinators to space
				type: match[ 0 ].replace( rtrimCSS, " " )
			} );
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||
				( match = preFilters[ type ]( match ) ) ) ) {
				matched = match.shift();
				tokens.push( {
					value: matched,
					type: type,
					matches: match
				} );
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	if ( parseOnly ) {
		return soFar.length;
	}

	return soFar ?
		find.error( selector ) :

		// Cache the tokens
		tokenCache( selector, groups ).slice( 0 );
}

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[ i ].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?

		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( ( elem = elem[ dir ] ) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || ( elem[ expando ] = {} );

						if ( skip && nodeName( elem, skip ) ) {
							elem = elem[ dir ] || elem;
						} else if ( ( oldCache = outerCache[ key ] ) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return ( newCache[ 2 ] = oldCache[ 2 ] );
						} else {

							// Reuse newcache so results back-propagate to previous elements
							outerCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[ i ]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[ 0 ];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		find( selector, contexts[ i ], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( ( elem = unmatched[ i ] ) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction( function( seed, results, context, xml ) {
		var temp, i, elem, matcherOut,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed ||
				multipleContexts( selector || "*",
					context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems;

		if ( matcher ) {

			// If we have a postFinder, or filtered seed, or non-seed postFilter
			// or preexisting results,
			matcherOut = postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

				// ...intermediate processing is necessary
				[] :

				// ...otherwise use results directly
				results;

			// Find primary matches
			matcher( matcherIn, matcherOut, context, xml );
		} else {
			matcherOut = matcherIn;
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( ( elem = temp[ i ] ) ) {
					matcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {

					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( ( elem = matcherOut[ i ] ) ) {

							// Restore matcherIn since elem is not yet a final match
							temp.push( ( matcherIn[ i ] = elem ) );
						}
					}
					postFinder( null, ( matcherOut = [] ), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( ( elem = matcherOut[ i ] ) &&
						( temp = postFinder ? indexOf.call( seed, elem ) : preMap[ i ] ) > -1 ) {

						seed[ temp ] = !( results[ temp ] = elem );
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	} );
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[ 0 ].type ],
		implicitRelative = leadingRelative || Expr.relative[ " " ],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf.call( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			var ret = ( !leadingRelative && ( xml || context != outermostContext ) ) || (
				( checkContext = context ).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );

			// Avoid hanging onto element
			// (see https://github.com/jquery/sizzle/issues/299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {
			matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
		} else {
			matcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {

				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[ j ].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(

						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 )
							.concat( { value: tokens[ i - 2 ].type === " " ? "*" : "" } )
					).replace( rtrimCSS, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,

				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find.TAG( "*", outermost ),

				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),
				len = elems.length;

			if ( outermost ) {

				// Support: IE 11+, Edge 17 - 18+
				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
				// two documents; shallow comparisons work.
				// eslint-disable-next-line eqeqeq
				outermostContext = context == document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: iOS <=7 - 9 only
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching
			// elements by id. (see trac-14142)
			for ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;

					// Support: IE 11+, Edge 17 - 18+
					// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
					// two documents; shallow comparisons work.
					// eslint-disable-next-line eqeqeq
					if ( !context && elem.ownerDocument != document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( ( matcher = elementMatchers[ j++ ] ) ) {
						if ( matcher( elem, context || document, xml ) ) {
							push.call( results, elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {

					// They will have gone through all possible matchers
					if ( ( elem = !matcher && elem ) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( ( matcher = setMatchers[ j++ ] ) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {

					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !( unmatched[ i ] || setMatched[ i ] ) ) {
								setMatched[ i ] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					jQuery.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

function compile( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {

		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[ i ] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector,
			matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
}

/**
 * A low-level selection function that works with jQuery's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with jQuery selector compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
function select( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( ( selector = compiled.selector || selector ) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[ 0 ] = match[ 0 ].slice( 0 );
		if ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {

			context = ( Expr.find.ID(
				token.matches[ 0 ].replace( runescape, funescape ),
				context
			) || [] )[ 0 ];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr.needsContext.test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[ i ];

			// Abort if we hit a combinator
			if ( Expr.relative[ ( type = token.type ) ] ) {
				break;
			}
			if ( ( find = Expr.find[ type ] ) ) {

				// Search, expanding context for leading sibling combinators
				if ( ( seed = find(
					token.matches[ 0 ].replace( runescape, funescape ),
					rsibling.test( tokens[ 0 ].type ) &&
						testContext( context.parentNode ) || context
				) ) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
}

// One-time assignments

// Support: Android <=4.0 - 4.1+
// Sort stability
support.sortStable = expando.split( "" ).sort( sortOrder ).join( "" ) === expando;

// Initialize against the default document
setDocument();

// Support: Android <=4.0 - 4.1+
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert( function( el ) {

	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement( "fieldset" ) ) & 1;
} );

jQuery.find = find;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.unique = jQuery.uniqueSort;

// These have always been private, but they used to be documented as part of
// Sizzle so let's maintain them for now for backwards compatibility purposes.
find.compile = compile;
find.select = select;
find.setDocument = setDocument;
find.tokenize = tokenize;

find.escape = jQuery.escapeSelector;
find.getText = jQuery.text;
find.isXML = jQuery.isXMLDoc;
find.selectors = jQuery.expr;
find.support = jQuery.support;
find.uniqueSort = jQuery.uniqueSort;

	/* eslint-enable */

} )();


var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (trac-9521)
	// Strict HTML recognition (trac-11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to jQuery#find
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, _i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, _i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, _i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		if ( elem.contentDocument != null &&

			// Support: IE 11+
			// <object> elements with no `data` attribute has an object
			// `contentDocument` with a `null` prototype.
			getProto( elem.contentDocument ) ) {

			return elem.contentDocument;
		}

		// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
		// Treat the template element as a regular one in browsers that
		// don't support it.
		if ( nodeName( elem, "template" ) ) {
			elem = elem.content || elem;
		}

		return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( _i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.error );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the error, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getErrorHook ) {
									process.error = jQuery.Deferred.getErrorHook();

								// The deprecated alias of the above. While the name suggests
								// returning the stack, not an error instance, jQuery just passes
								// it directly to `console.warn` so both will work; an instance
								// just better cooperates with source maps.
								} else if ( jQuery.Deferred.getStackHook ) {
									process.error = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the primary Deferred
			primary = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						primary.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, primary.done( updateFunc( i ) ).resolve, primary.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( primary.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return primary.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), primary.reject );
		}

		return primary.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

// If `jQuery.Deferred.getErrorHook` is defined, `asyncError` is an error
// captured before the async barrier to get the original error cause
// which may otherwise be hidden.
jQuery.Deferred.exceptionHook = function( error, asyncError ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message,
			error.stack, asyncError );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See trac-6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, _key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( _all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (trac-9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see trac-8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (trac-14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var documentElement = document.documentElement;



	var isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem );
		},
		composed = { composed: true };

	// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
	// Check attachment across shadow DOM boundaries when possible (gh-3504)
	// Support: iOS 10.0-10.2 only
	// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
	// leading to errors. We need to check for `getRootNode`.
	if ( documentElement.getRootNode ) {
		isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem ) ||
				elem.getRootNode( composed ) === elem.ownerDocument;
		};
	}
var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			isAttached( elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};



function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = elem.nodeType &&
			( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (trac-11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (trac-14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

	// Support: IE <=9 only
	// IE <=9 replaces <option> tags with their contents when inserted outside of
	// the select element.
	div.innerHTML = "<option></option>";
	support.option = !!div.lastChild;
} )();


// We have to close these tags to support XHTML (trac-13200)
var wrapMap = {

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: IE <=9 only
if ( !support.option ) {
	wrapMap.optgroup = wrapMap.option = [ 1, "<select multiple='multiple'>", "</select>" ];
}


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (trac-15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, attached, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (trac-12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		attached = isAttached( elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( attached ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Only attach events to objects that accept data
		if ( !acceptData( elem ) ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = Object.create( null );
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),

			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix( nativeEvent ),

			handlers = (
				dataPriv.get( this, "events" ) || Object.create( null )
			)[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// If the event is namespaced, then each handler is only invoked if it is
				// specially universal or its namespaces are a superset of the event's.
				if ( !event.rnamespace || handleObj.namespace === false ||
					event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (trac-13208)
				// Don't process clicks on disabled elements (trac-6911, trac-8165, trac-11382, trac-11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (trac-13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
						return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
						return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		click: {

			// Utilize native event to ensure correct state for checkable inputs
			setup: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Claim the first handler
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					// dataPriv.set( el, "click", ... )
					leverageNative( el, "click", true );
				}

				// Return false to allow normal processing in the caller
				return false;
			},
			trigger: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Force setup before triggering a click
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					leverageNative( el, "click" );
				}

				// Return non-false to allow normal event-path propagation
				return true;
			},

			// For cross-browser consistency, suppress native .click() on links
			// Also prevent it if we're currently inside a leveraged native-event stack
			_default: function( event ) {
				var target = event.target;
				return rcheckableType.test( target.type ) &&
					target.click && nodeName( target, "input" ) &&
					dataPriv.get( target, "click" ) ||
					nodeName( target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

// Ensure the presence of an event listener that handles manually-triggered
// synthetic events by interrupting progress until reinvoked in response to
// *native* events that it fires directly, ensuring that state changes have
// already occurred before other listeners are invoked.
function leverageNative( el, type, isSetup ) {

	// Missing `isSetup` indicates a trigger call, which must force setup through jQuery.event.add
	if ( !isSetup ) {
		if ( dataPriv.get( el, type ) === undefined ) {
			jQuery.event.add( el, type, returnTrue );
		}
		return;
	}

	// Register the controller as a special universal handler for all event namespaces
	dataPriv.set( el, type, false );
	jQuery.event.add( el, type, {
		namespace: false,
		handler: function( event ) {
			var result,
				saved = dataPriv.get( this, type );

			if ( ( event.isTrigger & 1 ) && this[ type ] ) {

				// Interrupt processing of the outer synthetic .trigger()ed event
				if ( !saved ) {

					// Store arguments for use when handling the inner native event
					// There will always be at least one argument (an event object), so this array
					// will not be confused with a leftover capture object.
					saved = slice.call( arguments );
					dataPriv.set( this, type, saved );

					// Trigger the native event and capture its result
					this[ type ]();
					result = dataPriv.get( this, type );
					dataPriv.set( this, type, false );

					if ( saved !== result ) {

						// Cancel the outer synthetic event
						event.stopImmediatePropagation();
						event.preventDefault();

						return result;
					}

				// If this is an inner synthetic event for an event with a bubbling surrogate
				// (focus or blur), assume that the surrogate already propagated from triggering
				// the native event and prevent that from happening again here.
				// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
				// bubbling surrogate propagates *after* the non-bubbling base), but that seems
				// less bad than duplication.
				} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
					event.stopPropagation();
				}

			// If this is a native event triggered above, everything is now in order
			// Fire an inner synthetic event with the original arguments
			} else if ( saved ) {

				// ...and capture the result
				dataPriv.set( this, type, jQuery.event.trigger(
					saved[ 0 ],
					saved.slice( 1 ),
					this
				) );

				// Abort handling of the native event by all jQuery handlers while allowing
				// native handlers on the same element to run. On target, this is achieved
				// by stopping immediate propagation just on the jQuery event. However,
				// the native event is re-wrapped by a jQuery one on each level of the
				// propagation so the only way to stop it for jQuery is to stop it for
				// everyone via native `stopPropagation()`. This is not a problem for
				// focus/blur which don't bubble, but it does also stop click on checkboxes
				// and radios. We accept this limitation.
				event.stopPropagation();
				event.isImmediatePropagationStopped = returnTrue;
			}
		}
	} );
}

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (trac-504, trac-13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	code: true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,
	which: true
}, jQuery.event.addProp );

jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {

	function focusMappedHandler( nativeEvent ) {
		if ( document.documentMode ) {

			// Support: IE 11+
			// Attach a single focusin/focusout handler on the document while someone wants
			// focus/blur. This is because the former are synchronous in IE while the latter
			// are async. In other browsers, all those handlers are invoked synchronously.

			// `handle` from private data would already wrap the event, but we need
			// to change the `type` here.
			var handle = dataPriv.get( this, "handle" ),
				event = jQuery.event.fix( nativeEvent );
			event.type = nativeEvent.type === "focusin" ? "focus" : "blur";
			event.isSimulated = true;

			// First, handle focusin/focusout
			handle( nativeEvent );

			// ...then, handle focus/blur
			//
			// focus/blur don't bubble while focusin/focusout do; simulate the former by only
			// invoking the handler at the lower level.
			if ( event.target === event.currentTarget ) {

				// The setup part calls `leverageNative`, which, in turn, calls
				// `jQuery.event.add`, so event handle will already have been set
				// by this point.
				handle( event );
			}
		} else {

			// For non-IE browsers, attach a single capturing handler on the document
			// while someone wants focusin/focusout.
			jQuery.event.simulate( delegateType, nativeEvent.target,
				jQuery.event.fix( nativeEvent ) );
		}
	}

	jQuery.event.special[ type ] = {

		// Utilize native event if possible so blur/focus sequence is correct
		setup: function() {

			var attaches;

			// Claim the first handler
			// dataPriv.set( this, "focus", ... )
			// dataPriv.set( this, "blur", ... )
			leverageNative( this, type, true );

			if ( document.documentMode ) {

				// Support: IE 9 - 11+
				// We use the same native handler for focusin & focus (and focusout & blur)
				// so we need to coordinate setup & teardown parts between those events.
				// Use `delegateType` as the key as `type` is already used by `leverageNative`.
				attaches = dataPriv.get( this, delegateType );
				if ( !attaches ) {
					this.addEventListener( delegateType, focusMappedHandler );
				}
				dataPriv.set( this, delegateType, ( attaches || 0 ) + 1 );
			} else {

				// Return false to allow normal processing in the caller
				return false;
			}
		},
		trigger: function() {

			// Force setup before trigger
			leverageNative( this, type );

			// Return non-false to allow normal event-path propagation
			return true;
		},

		teardown: function() {
			var attaches;

			if ( document.documentMode ) {
				attaches = dataPriv.get( this, delegateType ) - 1;
				if ( !attaches ) {
					this.removeEventListener( delegateType, focusMappedHandler );
					dataPriv.remove( this, delegateType );
				} else {
					dataPriv.set( this, delegateType, attaches );
				}
			} else {

				// Return false to indicate standard teardown should be applied
				return false;
			}
		},

		// Suppress native focus or blur if we're currently inside
		// a leveraged native-event stack
		_default: function( event ) {
			return dataPriv.get( event.target, type );
		},

		delegateType: delegateType
	};

	// Support: Firefox <=44
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
	//
	// Support: IE 9 - 11+
	// To preserve relative focusin/focus & focusout/blur event order guaranteed on the 3.x branch,
	// attach a single handler for both events in IE.
	jQuery.event.special[ delegateType ] = {
		setup: function() {

			// Handle: regular nodes (via `this.ownerDocument`), window
			// (via `this.document`) & document (via `this`).
			var doc = this.ownerDocument || this.document || this,
				dataHolder = document.documentMode ? this : doc,
				attaches = dataPriv.get( dataHolder, delegateType );

			// Support: IE 9 - 11+
			// We use the same native handler for focusin & focus (and focusout & blur)
			// so we need to coordinate setup & teardown parts between those events.
			// Use `delegateType` as the key as `type` is already used by `leverageNative`.
			if ( !attaches ) {
				if ( document.documentMode ) {
					this.addEventListener( delegateType, focusMappedHandler );
				} else {
					doc.addEventListener( type, focusMappedHandler, true );
				}
			}
			dataPriv.set( dataHolder, delegateType, ( attaches || 0 ) + 1 );
		},
		teardown: function() {
			var doc = this.ownerDocument || this.document || this,
				dataHolder = document.documentMode ? this : doc,
				attaches = dataPriv.get( dataHolder, delegateType ) - 1;

			if ( !attaches ) {
				if ( document.documentMode ) {
					this.removeEventListener( delegateType, focusMappedHandler );
				} else {
					doc.removeEventListener( type, focusMappedHandler, true );
				}
				dataPriv.remove( dataHolder, delegateType );
			} else {
				dataPriv.set( dataHolder, delegateType, attaches );
			}
		}
	};
} );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,

	rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.get( src );
		events = pdataOld.events;

		if ( events ) {
			dataPriv.remove( dest, "handle events" );

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = flat( args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (trac-8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Re-enable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl && !node.noModule ) {
								jQuery._evalUrl( node.src, {
									nonce: node.nonce || node.getAttribute( "nonce" )
								}, doc );
							}
						} else {

							// Unwrap a CDATA section containing script contents. This shouldn't be
							// needed as in XML documents they're already not visible when
							// inspecting element contents and in HTML documents they have no
							// meaning but we're preserving that logic for backwards compatibility.
							// This will be removed completely in 4.0. See gh-4904.
							DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && isAttached( node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html;
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = isAttached( elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew jQuery#find here for performance reasons:
			// https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var rcustomProp = /^--/;


var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (trac-15098, trac-14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var swap = function( elem, options, callback ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.call( elem );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		// Support: Chrome <=64
		// Don't get tricked when zoom affects offsetWidth (gh-4029)
		div.style.position = "absolute";
		scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableTrDimensionsVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (trac-8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		},

		// Support: IE 9 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Behavior in IE 9 is more subtle than in newer versions & it passes
		// some versions of this test; make sure not to make it pass there!
		//
		// Support: Firefox 70+
		// Only Firefox includes border widths
		// in computed dimensions. (gh-4529)
		reliableTrDimensions: function() {
			var table, tr, trChild, trStyle;
			if ( reliableTrDimensionsVal == null ) {
				table = document.createElement( "table" );
				tr = document.createElement( "tr" );
				trChild = document.createElement( "div" );

				table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
				tr.style.cssText = "box-sizing:content-box;border:1px solid";

				// Support: Chrome 86+
				// Height set through cssText does not get applied.
				// Computed height then comes back as 0.
				tr.style.height = "1px";
				trChild.style.height = "9px";

				// Support: Android 8 Chrome 86+
				// In our bodyBackground.html iframe,
				// display for all div elements is set to "inline",
				// which causes a problem only in Android 8 Chrome 86.
				// Ensuring the div is `display: block`
				// gets around this issue.
				trChild.style.display = "block";

				documentElement
					.appendChild( table )
					.appendChild( tr )
					.appendChild( trChild );

				trStyle = window.getComputedStyle( tr );
				reliableTrDimensionsVal = ( parseInt( trStyle.height, 10 ) +
					parseInt( trStyle.borderTopWidth, 10 ) +
					parseInt( trStyle.borderBottomWidth, 10 ) ) === tr.offsetHeight;

				documentElement.removeChild( table );
			}
			return reliableTrDimensionsVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		isCustomProp = rcustomProp.test( name ),

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, trac-12537)
	//   .css('--customProperty) (gh-3144)
	if ( computed ) {

		// Support: IE <=9 - 11+
		// IE only supports `"float"` in `getPropertyValue`; in computed styles
		// it's only available as `"cssFloat"`. We no longer modify properties
		// sent to `.css()` apart from camelCasing, so we need to check both.
		// Normally, this would create difference in behavior: if
		// `getPropertyValue` returns an empty string, the value returned
		// by `.css()` would be `undefined`. This is usually the case for
		// disconnected elements. However, in IE even disconnected elements
		// with no styles return `"none"` for `getPropertyValue( "float" )`
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( isCustomProp && ret ) {

			// Support: Firefox 105+, Chrome <=105+
			// Spec requires trimming whitespace for custom properties (gh-4926).
			// Firefox only trims leading whitespace. Chrome just collapses
			// both leading & trailing whitespace to a single space.
			//
			// Fall back to `undefined` if empty string returned.
			// This collapses a missing definition with property defined
			// and set to an empty string but there's no standard API
			// allowing us to differentiate them without a performance penalty
			// and returning `undefined` aligns with older jQuery.
			//
			// rtrimCSS treats U+000D CARRIAGE RETURN and U+000C FORM FEED
			// as whitespace while CSS does not, but this is not a problem
			// because CSS preprocessing replaces them with U+000A LINE FEED
			// (which *is* CSS whitespace)
			// https://www.w3.org/TR/css-syntax-3/#input-preprocessing
			ret = ret.replace( rtrimCSS, "$1" ) || undefined;
		}

		if ( ret === "" && !isAttached( elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style,
	vendorProps = {};

// Return a vendor-prefixed property or undefined
function vendorPropName( name ) {

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
function finalPropName( name ) {
	var final = jQuery.cssProps[ name ] || vendorProps[ name ];

	if ( final ) {
		return final;
	}
	if ( name in emptyStyle ) {
		return name;
	}
	return vendorProps[ name ] = vendorPropName( name ) || name;
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	};

function setPositiveNumber( _elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0,
		marginDelta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		// Count margin delta separately to only add it after scroll gutter adjustment.
		// This is needed to make negative margins work with `outerHeight( true )` (gh-3982).
		if ( box === "margin" ) {
			marginDelta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5

		// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
		// Use an explicit zero to avoid NaN (gh-3964)
		) ) || 0;
	}

	return delta + marginDelta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),

		// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
		// Fake content-box until we know it's needed to know the true value.
		boxSizingNeeded = !support.boxSizingReliable() || extra,
		isBorderBox = boxSizingNeeded &&
			jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox,

		val = curCSS( elem, dimension, styles ),
		offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}


	// Support: IE 9 - 11 only
	// Use offsetWidth/offsetHeight for when box sizing is unreliable.
	// In those cases, the computed value can be trusted to be border-box.
	if ( ( !support.boxSizingReliable() && isBorderBox ||

		// Support: IE 10 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Interestingly, in some cases IE 9 doesn't suffer from this issue.
		!support.reliableTrDimensions() && nodeName( elem, "tr" ) ||

		// Fall back to offsetWidth/offsetHeight when value is "auto"
		// This happens for inline elements with no explicit setting (gh-3571)
		val === "auto" ||

		// Support: Android <=4.1 - 4.3 only
		// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&

		// Make sure the element is visible & connected
		elem.getClientRects().length ) {

		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Where available, offsetWidth/offsetHeight approximate border box dimensions.
		// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
		// retrieved value as a content box dimension.
		valueIsBorderBox = offsetProp in elem;
		if ( valueIsBorderBox ) {
			val = elem[ offsetProp ];
		}
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		animationIterationCount: true,
		aspectRatio: true,
		borderImageSlice: true,
		columnCount: true,
		flexGrow: true,
		flexShrink: true,
		fontWeight: true,
		gridArea: true,
		gridColumn: true,
		gridColumnEnd: true,
		gridColumnStart: true,
		gridRow: true,
		gridRowEnd: true,
		gridRowStart: true,
		lineHeight: true,
		opacity: true,
		order: true,
		orphans: true,
		scale: true,
		widows: true,
		zIndex: true,
		zoom: true,

		// SVG-related
		fillOpacity: true,
		floodOpacity: true,
		stopOpacity: true,
		strokeMiterlimit: true,
		strokeOpacity: true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (trac-7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug trac-9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (trac-7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
			// "px" to a few hardcoded values.
			if ( type === "number" && !isCustomProp ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( _i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
					swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, dimension, extra );
					} ) :
					getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),

				// Only read styles.position if the test has a chance to fail
				// to avoid forcing a reflow.
				scrollboxSizeBuggy = !support.scrollboxSize() &&
					styles.position === "absolute",

				// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
				boxSizingNeeded = scrollboxSizeBuggy || extra,
				isBorderBox = boxSizingNeeded &&
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra ?
					boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					) :
					0;

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && scrollboxSizeBuggy ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
			) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 && (
				jQuery.cssHooks[ tween.prop ] ||
					tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

				/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (trac-12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
					animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};

		doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( _i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( _i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// Use proper attribute retrieval (trac-12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classNames, cur, curValue, className, i, finalValue;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classNames = classesToArray( value );

		if ( classNames.length ) {
			return this.each( function() {
				curValue = getClass( this );
				cur = this.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					for ( i = 0; i < classNames.length; i++ ) {
						className = classNames[ i ];
						if ( cur.indexOf( " " + className + " " ) < 0 ) {
							cur += className + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						this.setAttribute( "class", finalValue );
					}
				}
			} );
		}

		return this;
	},

	removeClass: function( value ) {
		var classNames, cur, curValue, className, i, finalValue;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classNames = classesToArray( value );

		if ( classNames.length ) {
			return this.each( function() {
				curValue = getClass( this );

				// This expression is here for better compressibility (see addClass)
				cur = this.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					for ( i = 0; i < classNames.length; i++ ) {
						className = classNames[ i ];

						// Remove *all* instances
						while ( cur.indexOf( " " + className + " " ) > -1 ) {
							cur = cur.replace( " " + className + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						this.setAttribute( "class", finalValue );
					}
				}
			} );
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var classNames, className, i, self,
			type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		classNames = classesToArray( value );

		return this.each( function() {
			if ( isValidValue ) {

				// Toggle individual class names
				self = jQuery( this );

				for ( i = 0; i < classNames.length; i++ ) {
					className = classNames[ i ];

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
				return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (trac-14686, trac-14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (trac-2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion
var location = window.location;

var nonce = { guid: Date.now() };

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml, parserErrorElem;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {}

	parserErrorElem = xml && xml.getElementsByTagName( "parsererror" )[ 0 ];
	if ( !xml || parserErrorElem ) {
		jQuery.error( "Invalid XML: " + (
			parserErrorElem ?
				jQuery.map( parserErrorElem.childNodes, function( el ) {
					return el.textContent;
				} ).join( "\n" ) :
				data
		) );
	}
	return xml;
};


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (trac-9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (trac-9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || Object.create( null ) )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (trac-6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	if ( a == null ) {
		return "";
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} ).filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} ).map( function( _i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// trac-7653, trac-8125, trac-8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (trac-10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );

originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes trac-9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
										.concat( match[ 2 ] );
							}
						}
						match = responseHeaders[ key.toLowerCase() + " " ];
					}
					return match == null ? null : match.join( ", " );
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (trac-10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket trac-12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (trac-15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// trac-9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce.guid++ ) +
					uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Use a noop converter for missing script but not if jsonp
			if ( !isSuccess &&
				jQuery.inArray( "script", s.dataTypes ) > -1 &&
				jQuery.inArray( "json", s.dataTypes ) < 0 ) {
				s.converters[ "text script" ] = function() {};
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( _i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );

jQuery.ajaxPrefilter( function( s ) {
	var i;
	for ( i in s.headers ) {
		if ( i.toLowerCase() === "content-type" ) {
			s.contentType = s.headers[ i ] || "";
		}
	}
} );


jQuery._evalUrl = function( url, options, doc ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (trac-11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,

		// Only evaluate the response if it is successful (gh-4126)
		// dataFilter is not invoked for failure responses, so using it instead
		// of the default converter is kludgy but it works.
		converters: {
			"text script": function() {}
		},
		dataFilter: function( response ) {
			jQuery.globalEval( response, options, doc );
		}
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// trac-1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see trac-8605, trac-14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// trac-14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain or forced-by-attrs requests
	if ( s.crossDomain || s.scriptAttrs ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" )
					.attr( s.scriptAttrs || {} )
					.prop( { charset: s.scriptCharset, src: s.url } )
					.on( "load error", callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					} );

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce.guid++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( _i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( {
		padding: "inner" + name,
		content: type,
		"": "outer" + name
	}, function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( _i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	},

	hover: function( fnOver, fnOut ) {
		return this
			.on( "mouseenter", fnOver )
			.on( "mouseleave", fnOut || fnOver );
	}
} );

jQuery.each(
	( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( _i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	}
);




// Support: Android <=4.0 only
// Make sure we trim BOM and NBSP
// Require that the "whitespace run" starts from a non-whitespace
// to avoid O(N^2) behavior when the engine would try matching "\s+$" at each space position.
var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};

jQuery.trim = function( text ) {
	return text == null ?
		"" :
		( text + "" ).replace( rtrim, "$1" );
};



// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( true ) {
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
		return jQuery;
	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (trac-7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (trac-13566)
if ( typeof noGlobal === "undefined" ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );


/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";


var stylesInDOM = [];
function getIndexByIdentifier(identifier) {
  var result = -1;
  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }
  return result;
}
function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];
  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };
    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }
    identifiers.push(identifier);
  }
  return identifiers;
}
function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);
  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }
      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };
  return updater;
}
module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];
    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }
    var newLastIdentifiers = modulesToDom(newList, options);
    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];
      var _index = getIndexByIdentifier(_identifier);
      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();
        stylesInDOM.splice(_index, 1);
      }
    }
    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";


var memo = {};

/* istanbul ignore next  */
function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target);

    // Special case to return head of iframe instead of iframe itself
    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }
    memo[target] = styleTarget;
  }
  return memo[target];
}

/* istanbul ignore next  */
function insertBySelector(insert, style) {
  var target = getTarget(insert);
  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }
  target.appendChild(style);
}
module.exports = insertBySelector;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}
module.exports = insertStyleElement;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;
  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}
module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";
  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }
  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }
  var needLayer = typeof obj.layer !== "undefined";
  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }
  css += obj.css;
  if (needLayer) {
    css += "}";
  }
  if (obj.media) {
    css += "}";
  }
  if (obj.supports) {
    css += "}";
  }
  var sourceMap = obj.sourceMap;
  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  }

  // For old IE
  /* istanbul ignore if  */
  options.styleTagTransform(css, styleElement, options.options);
}
function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }
  styleElement.parentNode.removeChild(styleElement);
}

/* istanbul ignore next  */
function domAPI(options) {
  if (typeof document === "undefined") {
    return {
      update: function update() {},
      remove: function remove() {}
    };
  }
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}
module.exports = domAPI;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }
    styleElement.appendChild(document.createTextNode(css));
  }
}
module.exports = styleTagTransform;

/***/ }),

/***/ "./node_modules/underscore/modules/_baseCreate.js":
/*!********************************************************!*\
  !*** ./node_modules/underscore/modules/_baseCreate.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ baseCreate)
/* harmony export */ });
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObject.js */ "./node_modules/underscore/modules/isObject.js");
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");



// Create a naked function reference for surrogate-prototype-swapping.
function ctor() {
  return function(){};
}

// An internal function for creating a new object that inherits from another.
function baseCreate(prototype) {
  if (!(0,_isObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype)) return {};
  if (_setup_js__WEBPACK_IMPORTED_MODULE_1__.nativeCreate) return (0,_setup_js__WEBPACK_IMPORTED_MODULE_1__.nativeCreate)(prototype);
  var Ctor = ctor();
  Ctor.prototype = prototype;
  var result = new Ctor;
  Ctor.prototype = null;
  return result;
}


/***/ }),

/***/ "./node_modules/underscore/modules/_baseIteratee.js":
/*!**********************************************************!*\
  !*** ./node_modules/underscore/modules/_baseIteratee.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ baseIteratee)
/* harmony export */ });
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity.js */ "./node_modules/underscore/modules/identity.js");
/* harmony import */ var _isFunction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isFunction.js */ "./node_modules/underscore/modules/isFunction.js");
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isObject.js */ "./node_modules/underscore/modules/isObject.js");
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/underscore/modules/isArray.js");
/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./matcher.js */ "./node_modules/underscore/modules/matcher.js");
/* harmony import */ var _property_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./property.js */ "./node_modules/underscore/modules/property.js");
/* harmony import */ var _optimizeCb_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_optimizeCb.js */ "./node_modules/underscore/modules/_optimizeCb.js");








// An internal function to generate callbacks that can be applied to each
// element in a collection, returning the desired result — either `_.identity`,
// an arbitrary callback, a property matcher, or a property accessor.
function baseIteratee(value, context, argCount) {
  if (value == null) return _identity_js__WEBPACK_IMPORTED_MODULE_0__["default"];
  if ((0,_isFunction_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value)) return (0,_optimizeCb_js__WEBPACK_IMPORTED_MODULE_6__["default"])(value, context, argCount);
  if ((0,_isObject_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value) && !(0,_isArray_js__WEBPACK_IMPORTED_MODULE_3__["default"])(value)) return (0,_matcher_js__WEBPACK_IMPORTED_MODULE_4__["default"])(value);
  return (0,_property_js__WEBPACK_IMPORTED_MODULE_5__["default"])(value);
}


/***/ }),

/***/ "./node_modules/underscore/modules/_cb.js":
/*!************************************************!*\
  !*** ./node_modules/underscore/modules/_cb.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ cb)
/* harmony export */ });
/* harmony import */ var _underscore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./underscore.js */ "./node_modules/underscore/modules/underscore.js");
/* harmony import */ var _baseIteratee_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseIteratee.js */ "./node_modules/underscore/modules/_baseIteratee.js");
/* harmony import */ var _iteratee_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./iteratee.js */ "./node_modules/underscore/modules/iteratee.js");




// The function we call internally to generate a callback. It invokes
// `_.iteratee` if overridden, otherwise `baseIteratee`.
function cb(value, context, argCount) {
  if (_underscore_js__WEBPACK_IMPORTED_MODULE_0__["default"].iteratee !== _iteratee_js__WEBPACK_IMPORTED_MODULE_2__["default"]) return _underscore_js__WEBPACK_IMPORTED_MODULE_0__["default"].iteratee(value, context);
  return (0,_baseIteratee_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value, context, argCount);
}


/***/ }),

/***/ "./node_modules/underscore/modules/_chainResult.js":
/*!*********************************************************!*\
  !*** ./node_modules/underscore/modules/_chainResult.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ chainResult)
/* harmony export */ });
/* harmony import */ var _underscore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./underscore.js */ "./node_modules/underscore/modules/underscore.js");


// Helper function to continue chaining intermediate results.
function chainResult(instance, obj) {
  return instance._chain ? (0,_underscore_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj).chain() : obj;
}


/***/ }),

/***/ "./node_modules/underscore/modules/_collectNonEnumProps.js":
/*!*****************************************************************!*\
  !*** ./node_modules/underscore/modules/_collectNonEnumProps.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ collectNonEnumProps)
/* harmony export */ });
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");
/* harmony import */ var _isFunction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isFunction.js */ "./node_modules/underscore/modules/isFunction.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_has.js */ "./node_modules/underscore/modules/_has.js");




// Internal helper to create a simple lookup structure.
// `collectNonEnumProps` used to depend on `_.contains`, but this led to
// circular imports. `emulatedSet` is a one-off solution that only works for
// arrays of strings.
function emulatedSet(keys) {
  var hash = {};
  for (var l = keys.length, i = 0; i < l; ++i) hash[keys[i]] = true;
  return {
    contains: function(key) { return hash[key] === true; },
    push: function(key) {
      hash[key] = true;
      return keys.push(key);
    }
  };
}

// Internal helper. Checks `keys` for the presence of keys in IE < 9 that won't
// be iterated by `for key in ...` and thus missed. Extends `keys` in place if
// needed.
function collectNonEnumProps(obj, keys) {
  keys = emulatedSet(keys);
  var nonEnumIdx = _setup_js__WEBPACK_IMPORTED_MODULE_0__.nonEnumerableProps.length;
  var constructor = obj.constructor;
  var proto = ((0,_isFunction_js__WEBPACK_IMPORTED_MODULE_1__["default"])(constructor) && constructor.prototype) || _setup_js__WEBPACK_IMPORTED_MODULE_0__.ObjProto;

  // Constructor is a special case.
  var prop = 'constructor';
  if ((0,_has_js__WEBPACK_IMPORTED_MODULE_2__["default"])(obj, prop) && !keys.contains(prop)) keys.push(prop);

  while (nonEnumIdx--) {
    prop = _setup_js__WEBPACK_IMPORTED_MODULE_0__.nonEnumerableProps[nonEnumIdx];
    if (prop in obj && obj[prop] !== proto[prop] && !keys.contains(prop)) {
      keys.push(prop);
    }
  }
}


/***/ }),

/***/ "./node_modules/underscore/modules/_createAssigner.js":
/*!************************************************************!*\
  !*** ./node_modules/underscore/modules/_createAssigner.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ createAssigner)
/* harmony export */ });
// An internal function for creating assigner functions.
function createAssigner(keysFunc, defaults) {
  return function(obj) {
    var length = arguments.length;
    if (defaults) obj = Object(obj);
    if (length < 2 || obj == null) return obj;
    for (var index = 1; index < length; index++) {
      var source = arguments[index],
          keys = keysFunc(source),
          l = keys.length;
      for (var i = 0; i < l; i++) {
        var key = keys[i];
        if (!defaults || obj[key] === void 0) obj[key] = source[key];
      }
    }
    return obj;
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/_createEscaper.js":
/*!***********************************************************!*\
  !*** ./node_modules/underscore/modules/_createEscaper.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ createEscaper)
/* harmony export */ });
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./keys.js */ "./node_modules/underscore/modules/keys.js");


// Internal helper to generate functions for escaping and unescaping strings
// to/from HTML interpolation.
function createEscaper(map) {
  var escaper = function(match) {
    return map[match];
  };
  // Regexes for identifying a key that needs to be escaped.
  var source = '(?:' + (0,_keys_js__WEBPACK_IMPORTED_MODULE_0__["default"])(map).join('|') + ')';
  var testRegexp = RegExp(source);
  var replaceRegexp = RegExp(source, 'g');
  return function(string) {
    string = string == null ? '' : '' + string;
    return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/_createIndexFinder.js":
/*!***************************************************************!*\
  !*** ./node_modules/underscore/modules/_createIndexFinder.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ createIndexFinder)
/* harmony export */ });
/* harmony import */ var _getLength_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getLength.js */ "./node_modules/underscore/modules/_getLength.js");
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");
/* harmony import */ var _isNaN_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isNaN.js */ "./node_modules/underscore/modules/isNaN.js");




// Internal function to generate the `_.indexOf` and `_.lastIndexOf` functions.
function createIndexFinder(dir, predicateFind, sortedIndex) {
  return function(array, item, idx) {
    var i = 0, length = (0,_getLength_js__WEBPACK_IMPORTED_MODULE_0__["default"])(array);
    if (typeof idx == 'number') {
      if (dir > 0) {
        i = idx >= 0 ? idx : Math.max(idx + length, i);
      } else {
        length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
      }
    } else if (sortedIndex && idx && length) {
      idx = sortedIndex(array, item);
      return array[idx] === item ? idx : -1;
    }
    if (item !== item) {
      idx = predicateFind(_setup_js__WEBPACK_IMPORTED_MODULE_1__.slice.call(array, i, length), _isNaN_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
      return idx >= 0 ? idx + i : -1;
    }
    for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
      if (array[idx] === item) return idx;
    }
    return -1;
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/_createPredicateIndexFinder.js":
/*!************************************************************************!*\
  !*** ./node_modules/underscore/modules/_createPredicateIndexFinder.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ createPredicateIndexFinder)
/* harmony export */ });
/* harmony import */ var _cb_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_cb.js */ "./node_modules/underscore/modules/_cb.js");
/* harmony import */ var _getLength_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_getLength.js */ "./node_modules/underscore/modules/_getLength.js");



// Internal function to generate `_.findIndex` and `_.findLastIndex`.
function createPredicateIndexFinder(dir) {
  return function(array, predicate, context) {
    predicate = (0,_cb_js__WEBPACK_IMPORTED_MODULE_0__["default"])(predicate, context);
    var length = (0,_getLength_js__WEBPACK_IMPORTED_MODULE_1__["default"])(array);
    var index = dir > 0 ? 0 : length - 1;
    for (; index >= 0 && index < length; index += dir) {
      if (predicate(array[index], index, array)) return index;
    }
    return -1;
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/_createReduce.js":
/*!**********************************************************!*\
  !*** ./node_modules/underscore/modules/_createReduce.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ createReduce)
/* harmony export */ });
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_isArrayLike.js */ "./node_modules/underscore/modules/_isArrayLike.js");
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keys.js */ "./node_modules/underscore/modules/keys.js");
/* harmony import */ var _optimizeCb_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_optimizeCb.js */ "./node_modules/underscore/modules/_optimizeCb.js");




// Internal helper to create a reducing function, iterating left or right.
function createReduce(dir) {
  // Wrap code that reassigns argument variables in a separate function than
  // the one that accesses `arguments.length` to avoid a perf hit. (#1991)
  var reducer = function(obj, iteratee, memo, initial) {
    var _keys = !(0,_isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj) && (0,_keys_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj),
        length = (_keys || obj).length,
        index = dir > 0 ? 0 : length - 1;
    if (!initial) {
      memo = obj[_keys ? _keys[index] : index];
      index += dir;
    }
    for (; index >= 0 && index < length; index += dir) {
      var currentKey = _keys ? _keys[index] : index;
      memo = iteratee(memo, obj[currentKey], currentKey, obj);
    }
    return memo;
  };

  return function(obj, iteratee, memo, context) {
    var initial = arguments.length >= 3;
    return reducer(obj, (0,_optimizeCb_js__WEBPACK_IMPORTED_MODULE_2__["default"])(iteratee, context, 4), memo, initial);
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/_createSizePropertyCheck.js":
/*!*********************************************************************!*\
  !*** ./node_modules/underscore/modules/_createSizePropertyCheck.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ createSizePropertyCheck)
/* harmony export */ });
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");


// Common internal logic for `isArrayLike` and `isBufferLike`.
function createSizePropertyCheck(getSizeProperty) {
  return function(collection) {
    var sizeProperty = getSizeProperty(collection);
    return typeof sizeProperty == 'number' && sizeProperty >= 0 && sizeProperty <= _setup_js__WEBPACK_IMPORTED_MODULE_0__.MAX_ARRAY_INDEX;
  }
}


/***/ }),

/***/ "./node_modules/underscore/modules/_deepGet.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/_deepGet.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ deepGet)
/* harmony export */ });
// Internal function to obtain a nested property in `obj` along `path`.
function deepGet(obj, path) {
  var length = path.length;
  for (var i = 0; i < length; i++) {
    if (obj == null) return void 0;
    obj = obj[path[i]];
  }
  return length ? obj : void 0;
}


/***/ }),

/***/ "./node_modules/underscore/modules/_escapeMap.js":
/*!*******************************************************!*\
  !*** ./node_modules/underscore/modules/_escapeMap.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// Internal list of HTML entities for escaping.
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#x27;',
  '`': '&#x60;'
});


/***/ }),

/***/ "./node_modules/underscore/modules/_executeBound.js":
/*!**********************************************************!*\
  !*** ./node_modules/underscore/modules/_executeBound.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ executeBound)
/* harmony export */ });
/* harmony import */ var _baseCreate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseCreate.js */ "./node_modules/underscore/modules/_baseCreate.js");
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isObject.js */ "./node_modules/underscore/modules/isObject.js");



// Internal function to execute `sourceFunc` bound to `context` with optional
// `args`. Determines whether to execute a function as a constructor or as a
// normal function.
function executeBound(sourceFunc, boundFunc, context, callingContext, args) {
  if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
  var self = (0,_baseCreate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(sourceFunc.prototype);
  var result = sourceFunc.apply(self, args);
  if ((0,_isObject_js__WEBPACK_IMPORTED_MODULE_1__["default"])(result)) return result;
  return self;
}


/***/ }),

/***/ "./node_modules/underscore/modules/_flatten.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/_flatten.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ flatten)
/* harmony export */ });
/* harmony import */ var _getLength_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getLength.js */ "./node_modules/underscore/modules/_getLength.js");
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_isArrayLike.js */ "./node_modules/underscore/modules/_isArrayLike.js");
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/underscore/modules/isArray.js");
/* harmony import */ var _isArguments_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isArguments.js */ "./node_modules/underscore/modules/isArguments.js");





// Internal implementation of a recursive `flatten` function.
function flatten(input, depth, strict, output) {
  output = output || [];
  if (!depth && depth !== 0) {
    depth = Infinity;
  } else if (depth <= 0) {
    return output.concat(input);
  }
  var idx = output.length;
  for (var i = 0, length = (0,_getLength_js__WEBPACK_IMPORTED_MODULE_0__["default"])(input); i < length; i++) {
    var value = input[i];
    if ((0,_isArrayLike_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value) && ((0,_isArray_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value) || (0,_isArguments_js__WEBPACK_IMPORTED_MODULE_3__["default"])(value))) {
      // Flatten current level of array or arguments object.
      if (depth > 1) {
        flatten(value, depth - 1, strict, output);
        idx = output.length;
      } else {
        var j = 0, len = value.length;
        while (j < len) output[idx++] = value[j++];
      }
    } else if (!strict) {
      output[idx++] = value;
    }
  }
  return output;
}


/***/ }),

/***/ "./node_modules/underscore/modules/_getByteLength.js":
/*!***********************************************************!*\
  !*** ./node_modules/underscore/modules/_getByteLength.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shallowProperty_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_shallowProperty.js */ "./node_modules/underscore/modules/_shallowProperty.js");


// Internal helper to obtain the `byteLength` property of an object.
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_shallowProperty_js__WEBPACK_IMPORTED_MODULE_0__["default"])('byteLength'));


/***/ }),

/***/ "./node_modules/underscore/modules/_getLength.js":
/*!*******************************************************!*\
  !*** ./node_modules/underscore/modules/_getLength.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shallowProperty_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_shallowProperty.js */ "./node_modules/underscore/modules/_shallowProperty.js");


// Internal helper to obtain the `length` property of an object.
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_shallowProperty_js__WEBPACK_IMPORTED_MODULE_0__["default"])('length'));


/***/ }),

/***/ "./node_modules/underscore/modules/_group.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/_group.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ group)
/* harmony export */ });
/* harmony import */ var _cb_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_cb.js */ "./node_modules/underscore/modules/_cb.js");
/* harmony import */ var _each_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./each.js */ "./node_modules/underscore/modules/each.js");



// An internal function used for aggregate "group by" operations.
function group(behavior, partition) {
  return function(obj, iteratee, context) {
    var result = partition ? [[], []] : {};
    iteratee = (0,_cb_js__WEBPACK_IMPORTED_MODULE_0__["default"])(iteratee, context);
    (0,_each_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj, function(value, index) {
      var key = iteratee(value, index, obj);
      behavior(result, value, key);
    });
    return result;
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/_has.js":
/*!*************************************************!*\
  !*** ./node_modules/underscore/modules/_has.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ has)
/* harmony export */ });
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");


// Internal function to check whether `key` is an own property name of `obj`.
function has(obj, key) {
  return obj != null && _setup_js__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty.call(obj, key);
}


/***/ }),

/***/ "./node_modules/underscore/modules/_hasObjectTag.js":
/*!**********************************************************!*\
  !*** ./node_modules/underscore/modules/_hasObjectTag.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _tagTester_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_tagTester.js */ "./node_modules/underscore/modules/_tagTester.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_tagTester_js__WEBPACK_IMPORTED_MODULE_0__["default"])('Object'));


/***/ }),

/***/ "./node_modules/underscore/modules/_isArrayLike.js":
/*!*********************************************************!*\
  !*** ./node_modules/underscore/modules/_isArrayLike.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _createSizePropertyCheck_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createSizePropertyCheck.js */ "./node_modules/underscore/modules/_createSizePropertyCheck.js");
/* harmony import */ var _getLength_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_getLength.js */ "./node_modules/underscore/modules/_getLength.js");



// Internal helper for collection methods to determine whether a collection
// should be iterated as an array or as an object.
// Related: https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
// Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_createSizePropertyCheck_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_getLength_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/***/ }),

/***/ "./node_modules/underscore/modules/_isBufferLike.js":
/*!**********************************************************!*\
  !*** ./node_modules/underscore/modules/_isBufferLike.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _createSizePropertyCheck_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createSizePropertyCheck.js */ "./node_modules/underscore/modules/_createSizePropertyCheck.js");
/* harmony import */ var _getByteLength_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_getByteLength.js */ "./node_modules/underscore/modules/_getByteLength.js");



// Internal helper to determine whether we should spend extensive checks against
// `ArrayBuffer` et al.
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_createSizePropertyCheck_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_getByteLength_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/***/ }),

/***/ "./node_modules/underscore/modules/_keyInObj.js":
/*!******************************************************!*\
  !*** ./node_modules/underscore/modules/_keyInObj.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ keyInObj)
/* harmony export */ });
// Internal `_.pick` helper function to determine whether `key` is an enumerable
// property name of `obj`.
function keyInObj(value, key, obj) {
  return key in obj;
}


/***/ }),

/***/ "./node_modules/underscore/modules/_methodFingerprint.js":
/*!***************************************************************!*\
  !*** ./node_modules/underscore/modules/_methodFingerprint.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ie11fingerprint: () => (/* binding */ ie11fingerprint),
/* harmony export */   mapMethods: () => (/* binding */ mapMethods),
/* harmony export */   setMethods: () => (/* binding */ setMethods),
/* harmony export */   weakMapMethods: () => (/* binding */ weakMapMethods)
/* harmony export */ });
/* harmony import */ var _getLength_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getLength.js */ "./node_modules/underscore/modules/_getLength.js");
/* harmony import */ var _isFunction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isFunction.js */ "./node_modules/underscore/modules/isFunction.js");
/* harmony import */ var _allKeys_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./allKeys.js */ "./node_modules/underscore/modules/allKeys.js");




// Since the regular `Object.prototype.toString` type tests don't work for
// some types in IE 11, we use a fingerprinting heuristic instead, based
// on the methods. It's not great, but it's the best we got.
// The fingerprint method lists are defined below.
function ie11fingerprint(methods) {
  var length = (0,_getLength_js__WEBPACK_IMPORTED_MODULE_0__["default"])(methods);
  return function(obj) {
    if (obj == null) return false;
    // `Map`, `WeakMap` and `Set` have no enumerable keys.
    var keys = (0,_allKeys_js__WEBPACK_IMPORTED_MODULE_2__["default"])(obj);
    if ((0,_getLength_js__WEBPACK_IMPORTED_MODULE_0__["default"])(keys)) return false;
    for (var i = 0; i < length; i++) {
      if (!(0,_isFunction_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj[methods[i]])) return false;
    }
    // If we are testing against `WeakMap`, we need to ensure that
    // `obj` doesn't have a `forEach` method in order to distinguish
    // it from a regular `Map`.
    return methods !== weakMapMethods || !(0,_isFunction_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj[forEachName]);
  };
}

// In the interest of compact minification, we write
// each string in the fingerprints only once.
var forEachName = 'forEach',
    hasName = 'has',
    commonInit = ['clear', 'delete'],
    mapTail = ['get', hasName, 'set'];

// `Map`, `WeakMap` and `Set` each have slightly different
// combinations of the above sublists.
var mapMethods = commonInit.concat(forEachName, mapTail),
    weakMapMethods = commonInit.concat(mapTail),
    setMethods = ['add'].concat(commonInit, forEachName, hasName);


/***/ }),

/***/ "./node_modules/underscore/modules/_optimizeCb.js":
/*!********************************************************!*\
  !*** ./node_modules/underscore/modules/_optimizeCb.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ optimizeCb)
/* harmony export */ });
// Internal function that returns an efficient (for current engines) version
// of the passed-in callback, to be repeatedly applied in other Underscore
// functions.
function optimizeCb(func, context, argCount) {
  if (context === void 0) return func;
  switch (argCount == null ? 3 : argCount) {
    case 1: return function(value) {
      return func.call(context, value);
    };
    // The 2-argument case is omitted because we’re not using it.
    case 3: return function(value, index, collection) {
      return func.call(context, value, index, collection);
    };
    case 4: return function(accumulator, value, index, collection) {
      return func.call(context, accumulator, value, index, collection);
    };
  }
  return function() {
    return func.apply(context, arguments);
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/_setup.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/_setup.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ArrayProto: () => (/* binding */ ArrayProto),
/* harmony export */   MAX_ARRAY_INDEX: () => (/* binding */ MAX_ARRAY_INDEX),
/* harmony export */   ObjProto: () => (/* binding */ ObjProto),
/* harmony export */   SymbolProto: () => (/* binding */ SymbolProto),
/* harmony export */   VERSION: () => (/* binding */ VERSION),
/* harmony export */   _isFinite: () => (/* binding */ _isFinite),
/* harmony export */   _isNaN: () => (/* binding */ _isNaN),
/* harmony export */   hasEnumBug: () => (/* binding */ hasEnumBug),
/* harmony export */   hasOwnProperty: () => (/* binding */ hasOwnProperty),
/* harmony export */   nativeCreate: () => (/* binding */ nativeCreate),
/* harmony export */   nativeIsArray: () => (/* binding */ nativeIsArray),
/* harmony export */   nativeIsView: () => (/* binding */ nativeIsView),
/* harmony export */   nativeKeys: () => (/* binding */ nativeKeys),
/* harmony export */   nonEnumerableProps: () => (/* binding */ nonEnumerableProps),
/* harmony export */   push: () => (/* binding */ push),
/* harmony export */   root: () => (/* binding */ root),
/* harmony export */   slice: () => (/* binding */ slice),
/* harmony export */   supportsArrayBuffer: () => (/* binding */ supportsArrayBuffer),
/* harmony export */   supportsDataView: () => (/* binding */ supportsDataView),
/* harmony export */   toString: () => (/* binding */ toString)
/* harmony export */ });
// Current version.
var VERSION = '1.13.7';

// Establish the root object, `window` (`self`) in the browser, `global`
// on the server, or `this` in some virtual machines. We use `self`
// instead of `window` for `WebWorker` support.
var root = (typeof self == 'object' && self.self === self && self) ||
          (typeof global == 'object' && global.global === global && global) ||
          Function('return this')() ||
          {};

// Save bytes in the minified (but not gzipped) version:
var ArrayProto = Array.prototype, ObjProto = Object.prototype;
var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;

// Create quick reference variables for speed access to core prototypes.
var push = ArrayProto.push,
    slice = ArrayProto.slice,
    toString = ObjProto.toString,
    hasOwnProperty = ObjProto.hasOwnProperty;

// Modern feature detection.
var supportsArrayBuffer = typeof ArrayBuffer !== 'undefined',
    supportsDataView = typeof DataView !== 'undefined';

// All **ECMAScript 5+** native function implementations that we hope to use
// are declared here.
var nativeIsArray = Array.isArray,
    nativeKeys = Object.keys,
    nativeCreate = Object.create,
    nativeIsView = supportsArrayBuffer && ArrayBuffer.isView;

// Create references to these builtin functions because we override them.
var _isNaN = isNaN,
    _isFinite = isFinite;

// Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
  'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

// The largest integer that can be represented exactly.
var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;


/***/ }),

/***/ "./node_modules/underscore/modules/_shallowProperty.js":
/*!*************************************************************!*\
  !*** ./node_modules/underscore/modules/_shallowProperty.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ shallowProperty)
/* harmony export */ });
// Internal helper to generate a function to obtain property `key` from `obj`.
function shallowProperty(key) {
  return function(obj) {
    return obj == null ? void 0 : obj[key];
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/_stringTagBug.js":
/*!**********************************************************!*\
  !*** ./node_modules/underscore/modules/_stringTagBug.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   hasDataViewBug: () => (/* binding */ hasDataViewBug),
/* harmony export */   isIE11: () => (/* binding */ isIE11)
/* harmony export */ });
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");
/* harmony import */ var _hasObjectTag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_hasObjectTag.js */ "./node_modules/underscore/modules/_hasObjectTag.js");



// In IE 10 - Edge 13, `DataView` has string tag `'[object Object]'`.
// In IE 11, the most common among them, this problem also applies to
// `Map`, `WeakMap` and `Set`.
// Also, there are cases where an application can override the native
// `DataView` object, in cases like that we can't use the constructor
// safely and should just rely on alternate `DataView` checks
var hasDataViewBug = (
      _setup_js__WEBPACK_IMPORTED_MODULE_0__.supportsDataView && (!/\[native code\]/.test(String(DataView)) || (0,_hasObjectTag_js__WEBPACK_IMPORTED_MODULE_1__["default"])(new DataView(new ArrayBuffer(8))))
    ),
    isIE11 = (typeof Map !== 'undefined' && (0,_hasObjectTag_js__WEBPACK_IMPORTED_MODULE_1__["default"])(new Map));


/***/ }),

/***/ "./node_modules/underscore/modules/_tagTester.js":
/*!*******************************************************!*\
  !*** ./node_modules/underscore/modules/_tagTester.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ tagTester)
/* harmony export */ });
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");


// Internal function for creating a `toString`-based type tester.
function tagTester(name) {
  var tag = '[object ' + name + ']';
  return function(obj) {
    return _setup_js__WEBPACK_IMPORTED_MODULE_0__.toString.call(obj) === tag;
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/_toBufferView.js":
/*!**********************************************************!*\
  !*** ./node_modules/underscore/modules/_toBufferView.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toBufferView)
/* harmony export */ });
/* harmony import */ var _getByteLength_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getByteLength.js */ "./node_modules/underscore/modules/_getByteLength.js");


// Internal function to wrap or shallow-copy an ArrayBuffer,
// typed array or DataView to a new view, reusing the buffer.
function toBufferView(bufferSource) {
  return new Uint8Array(
    bufferSource.buffer || bufferSource,
    bufferSource.byteOffset || 0,
    (0,_getByteLength_js__WEBPACK_IMPORTED_MODULE_0__["default"])(bufferSource)
  );
}


/***/ }),

/***/ "./node_modules/underscore/modules/_toPath.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/_toPath.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toPath)
/* harmony export */ });
/* harmony import */ var _underscore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./underscore.js */ "./node_modules/underscore/modules/underscore.js");
/* harmony import */ var _toPath_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./toPath.js */ "./node_modules/underscore/modules/toPath.js");



// Internal wrapper for `_.toPath` to enable minification.
// Similar to `cb` for `_.iteratee`.
function toPath(path) {
  return _underscore_js__WEBPACK_IMPORTED_MODULE_0__["default"].toPath(path);
}


/***/ }),

/***/ "./node_modules/underscore/modules/_unescapeMap.js":
/*!*********************************************************!*\
  !*** ./node_modules/underscore/modules/_unescapeMap.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _invert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./invert.js */ "./node_modules/underscore/modules/invert.js");
/* harmony import */ var _escapeMap_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_escapeMap.js */ "./node_modules/underscore/modules/_escapeMap.js");



// Internal list of HTML entities for unescaping.
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_invert_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_escapeMap_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/***/ }),

/***/ "./node_modules/underscore/modules/after.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/after.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ after)
/* harmony export */ });
// Returns a function that will only be executed on and after the Nth call.
function after(times, func) {
  return function() {
    if (--times < 1) {
      return func.apply(this, arguments);
    }
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/allKeys.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/allKeys.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ allKeys)
/* harmony export */ });
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObject.js */ "./node_modules/underscore/modules/isObject.js");
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");
/* harmony import */ var _collectNonEnumProps_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_collectNonEnumProps.js */ "./node_modules/underscore/modules/_collectNonEnumProps.js");




// Retrieve all the enumerable property names of an object.
function allKeys(obj) {
  if (!(0,_isObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj)) return [];
  var keys = [];
  for (var key in obj) keys.push(key);
  // Ahem, IE < 9.
  if (_setup_js__WEBPACK_IMPORTED_MODULE_1__.hasEnumBug) (0,_collectNonEnumProps_js__WEBPACK_IMPORTED_MODULE_2__["default"])(obj, keys);
  return keys;
}


/***/ }),

/***/ "./node_modules/underscore/modules/before.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/before.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ before)
/* harmony export */ });
// Returns a function that will only be executed up to (but not including) the
// Nth call.
function before(times, func) {
  var memo;
  return function() {
    if (--times > 0) {
      memo = func.apply(this, arguments);
    }
    if (times <= 1) func = null;
    return memo;
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/bind.js":
/*!*************************************************!*\
  !*** ./node_modules/underscore/modules/bind.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _restArguments_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./restArguments.js */ "./node_modules/underscore/modules/restArguments.js");
/* harmony import */ var _isFunction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isFunction.js */ "./node_modules/underscore/modules/isFunction.js");
/* harmony import */ var _executeBound_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_executeBound.js */ "./node_modules/underscore/modules/_executeBound.js");




// Create a function bound to a given object (assigning `this`, and arguments,
// optionally).
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_restArguments_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(func, context, args) {
  if (!(0,_isFunction_js__WEBPACK_IMPORTED_MODULE_1__["default"])(func)) throw new TypeError('Bind must be called on a function');
  var bound = (0,_restArguments_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(callArgs) {
    return (0,_executeBound_js__WEBPACK_IMPORTED_MODULE_2__["default"])(func, bound, context, this, args.concat(callArgs));
  });
  return bound;
}));


/***/ }),

/***/ "./node_modules/underscore/modules/bindAll.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/bindAll.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _restArguments_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./restArguments.js */ "./node_modules/underscore/modules/restArguments.js");
/* harmony import */ var _flatten_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_flatten.js */ "./node_modules/underscore/modules/_flatten.js");
/* harmony import */ var _bind_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bind.js */ "./node_modules/underscore/modules/bind.js");




// Bind a number of an object's methods to that object. Remaining arguments
// are the method names to be bound. Useful for ensuring that all callbacks
// defined on an object belong to it.
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_restArguments_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(obj, keys) {
  keys = (0,_flatten_js__WEBPACK_IMPORTED_MODULE_1__["default"])(keys, false, false);
  var index = keys.length;
  if (index < 1) throw new Error('bindAll must be passed function names');
  while (index--) {
    var key = keys[index];
    obj[key] = (0,_bind_js__WEBPACK_IMPORTED_MODULE_2__["default"])(obj[key], obj);
  }
  return obj;
}));


/***/ }),

/***/ "./node_modules/underscore/modules/chain.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/chain.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ chain)
/* harmony export */ });
/* harmony import */ var _underscore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./underscore.js */ "./node_modules/underscore/modules/underscore.js");


// Start chaining a wrapped Underscore object.
function chain(obj) {
  var instance = (0,_underscore_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj);
  instance._chain = true;
  return instance;
}


/***/ }),

/***/ "./node_modules/underscore/modules/chunk.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/chunk.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ chunk)
/* harmony export */ });
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");


// Chunk a single array into multiple arrays, each containing `count` or fewer
// items.
function chunk(array, count) {
  if (count == null || count < 1) return [];
  var result = [];
  var i = 0, length = array.length;
  while (i < length) {
    result.push(_setup_js__WEBPACK_IMPORTED_MODULE_0__.slice.call(array, i, i += count));
  }
  return result;
}


/***/ }),

/***/ "./node_modules/underscore/modules/clone.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/clone.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ clone)
/* harmony export */ });
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObject.js */ "./node_modules/underscore/modules/isObject.js");
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/underscore/modules/isArray.js");
/* harmony import */ var _extend_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./extend.js */ "./node_modules/underscore/modules/extend.js");




// Create a (shallow-cloned) duplicate of an object.
function clone(obj) {
  if (!(0,_isObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj)) return obj;
  return (0,_isArray_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj) ? obj.slice() : (0,_extend_js__WEBPACK_IMPORTED_MODULE_2__["default"])({}, obj);
}


/***/ }),

/***/ "./node_modules/underscore/modules/compact.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/compact.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ compact)
/* harmony export */ });
/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./filter.js */ "./node_modules/underscore/modules/filter.js");


// Trim out all falsy values from an array.
function compact(array) {
  return (0,_filter_js__WEBPACK_IMPORTED_MODULE_0__["default"])(array, Boolean);
}


/***/ }),

/***/ "./node_modules/underscore/modules/compose.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/compose.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ compose)
/* harmony export */ });
// Returns a function that is the composition of a list of functions, each
// consuming the return value of the function that follows.
function compose() {
  var args = arguments;
  var start = args.length - 1;
  return function() {
    var i = start;
    var result = args[start].apply(this, arguments);
    while (i--) result = args[i].call(this, result);
    return result;
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/constant.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/constant.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ constant)
/* harmony export */ });
// Predicate-generating function. Often useful outside of Underscore.
function constant(value) {
  return function() {
    return value;
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/contains.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/contains.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ contains)
/* harmony export */ });
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_isArrayLike.js */ "./node_modules/underscore/modules/_isArrayLike.js");
/* harmony import */ var _values_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./values.js */ "./node_modules/underscore/modules/values.js");
/* harmony import */ var _indexOf_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./indexOf.js */ "./node_modules/underscore/modules/indexOf.js");




// Determine if the array or object contains a given item (using `===`).
function contains(obj, item, fromIndex, guard) {
  if (!(0,_isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj)) obj = (0,_values_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj);
  if (typeof fromIndex != 'number' || guard) fromIndex = 0;
  return (0,_indexOf_js__WEBPACK_IMPORTED_MODULE_2__["default"])(obj, item, fromIndex) >= 0;
}


/***/ }),

/***/ "./node_modules/underscore/modules/countBy.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/countBy.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _group_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_group.js */ "./node_modules/underscore/modules/_group.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_has.js */ "./node_modules/underscore/modules/_has.js");



// Counts instances of an object that group by a certain criterion. Pass
// either a string attribute to count by, or a function that returns the
// criterion.
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_group_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(result, value, key) {
  if ((0,_has_js__WEBPACK_IMPORTED_MODULE_1__["default"])(result, key)) result[key]++; else result[key] = 1;
}));


/***/ }),

/***/ "./node_modules/underscore/modules/create.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/create.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ create)
/* harmony export */ });
/* harmony import */ var _baseCreate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseCreate.js */ "./node_modules/underscore/modules/_baseCreate.js");
/* harmony import */ var _extendOwn_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./extendOwn.js */ "./node_modules/underscore/modules/extendOwn.js");



// Creates an object that inherits from the given prototype object.
// If additional properties are provided then they will be added to the
// created object.
function create(prototype, props) {
  var result = (0,_baseCreate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype);
  if (props) (0,_extendOwn_js__WEBPACK_IMPORTED_MODULE_1__["default"])(result, props);
  return result;
}


/***/ }),

/***/ "./node_modules/underscore/modules/debounce.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/debounce.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ debounce)
/* harmony export */ });
/* harmony import */ var _restArguments_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./restArguments.js */ "./node_modules/underscore/modules/restArguments.js");
/* harmony import */ var _now_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./now.js */ "./node_modules/underscore/modules/now.js");



// When a sequence of calls of the returned function ends, the argument
// function is triggered. The end of a sequence is defined by the `wait`
// parameter. If `immediate` is passed, the argument function will be
// triggered at the beginning of the sequence instead of at the end.
function debounce(func, wait, immediate) {
  var timeout, previous, args, result, context;

  var later = function() {
    var passed = (0,_now_js__WEBPACK_IMPORTED_MODULE_1__["default"])() - previous;
    if (wait > passed) {
      timeout = setTimeout(later, wait - passed);
    } else {
      timeout = null;
      if (!immediate) result = func.apply(context, args);
      // This check is needed because `func` can recursively invoke `debounced`.
      if (!timeout) args = context = null;
    }
  };

  var debounced = (0,_restArguments_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(_args) {
    context = this;
    args = _args;
    previous = (0,_now_js__WEBPACK_IMPORTED_MODULE_1__["default"])();
    if (!timeout) {
      timeout = setTimeout(later, wait);
      if (immediate) result = func.apply(context, args);
    }
    return result;
  });

  debounced.cancel = function() {
    clearTimeout(timeout);
    timeout = args = context = null;
  };

  return debounced;
}


/***/ }),

/***/ "./node_modules/underscore/modules/defaults.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/defaults.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _createAssigner_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createAssigner.js */ "./node_modules/underscore/modules/_createAssigner.js");
/* harmony import */ var _allKeys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./allKeys.js */ "./node_modules/underscore/modules/allKeys.js");



// Fill in a given object with default properties.
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_createAssigner_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_allKeys_js__WEBPACK_IMPORTED_MODULE_1__["default"], true));


/***/ }),

/***/ "./node_modules/underscore/modules/defer.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/defer.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _partial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./partial.js */ "./node_modules/underscore/modules/partial.js");
/* harmony import */ var _delay_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./delay.js */ "./node_modules/underscore/modules/delay.js");
/* harmony import */ var _underscore_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./underscore.js */ "./node_modules/underscore/modules/underscore.js");




// Defers a function, scheduling it to run after the current call stack has
// cleared.
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_partial_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_delay_js__WEBPACK_IMPORTED_MODULE_1__["default"], _underscore_js__WEBPACK_IMPORTED_MODULE_2__["default"], 1));


/***/ }),

/***/ "./node_modules/underscore/modules/delay.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/delay.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _restArguments_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./restArguments.js */ "./node_modules/underscore/modules/restArguments.js");


// Delays a function for the given number of milliseconds, and then calls
// it with the arguments supplied.
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_restArguments_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(func, wait, args) {
  return setTimeout(function() {
    return func.apply(null, args);
  }, wait);
}));


/***/ }),

/***/ "./node_modules/underscore/modules/difference.js":
/*!*******************************************************!*\
  !*** ./node_modules/underscore/modules/difference.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _restArguments_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./restArguments.js */ "./node_modules/underscore/modules/restArguments.js");
/* harmony import */ var _flatten_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_flatten.js */ "./node_modules/underscore/modules/_flatten.js");
/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./filter.js */ "./node_modules/underscore/modules/filter.js");
/* harmony import */ var _contains_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./contains.js */ "./node_modules/underscore/modules/contains.js");





// Take the difference between one array and a number of other arrays.
// Only the elements present in just the first array will remain.
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_restArguments_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(array, rest) {
  rest = (0,_flatten_js__WEBPACK_IMPORTED_MODULE_1__["default"])(rest, true, true);
  return (0,_filter_js__WEBPACK_IMPORTED_MODULE_2__["default"])(array, function(value){
    return !(0,_contains_js__WEBPACK_IMPORTED_MODULE_3__["default"])(rest, value);
  });
}));


/***/ }),

/***/ "./node_modules/underscore/modules/each.js":
/*!*************************************************!*\
  !*** ./node_modules/underscore/modules/each.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ each)
/* harmony export */ });
/* harmony import */ var _optimizeCb_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_optimizeCb.js */ "./node_modules/underscore/modules/_optimizeCb.js");
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_isArrayLike.js */ "./node_modules/underscore/modules/_isArrayLike.js");
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./keys.js */ "./node_modules/underscore/modules/keys.js");




// The cornerstone for collection functions, an `each`
// implementation, aka `forEach`.
// Handles raw objects in addition to array-likes. Treats all
// sparse array-likes as if they were dense.
function each(obj, iteratee, context) {
  iteratee = (0,_optimizeCb_js__WEBPACK_IMPORTED_MODULE_0__["default"])(iteratee, context);
  var i, length;
  if ((0,_isArrayLike_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj)) {
    for (i = 0, length = obj.length; i < length; i++) {
      iteratee(obj[i], i, obj);
    }
  } else {
    var _keys = (0,_keys_js__WEBPACK_IMPORTED_MODULE_2__["default"])(obj);
    for (i = 0, length = _keys.length; i < length; i++) {
      iteratee(obj[_keys[i]], _keys[i], obj);
    }
  }
  return obj;
}


/***/ }),

/***/ "./node_modules/underscore/modules/escape.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/escape.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _createEscaper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createEscaper.js */ "./node_modules/underscore/modules/_createEscaper.js");
/* harmony import */ var _escapeMap_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_escapeMap.js */ "./node_modules/underscore/modules/_escapeMap.js");



// Function for escaping strings to HTML interpolation.
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_createEscaper_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_escapeMap_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/***/ }),

/***/ "./node_modules/underscore/modules/every.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/every.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ every)
/* harmony export */ });
/* harmony import */ var _cb_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_cb.js */ "./node_modules/underscore/modules/_cb.js");
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_isArrayLike.js */ "./node_modules/underscore/modules/_isArrayLike.js");
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./keys.js */ "./node_modules/underscore/modules/keys.js");




// Determine whether all of the elements pass a truth test.
function every(obj, predicate, context) {
  predicate = (0,_cb_js__WEBPACK_IMPORTED_MODULE_0__["default"])(predicate, context);
  var _keys = !(0,_isArrayLike_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj) && (0,_keys_js__WEBPACK_IMPORTED_MODULE_2__["default"])(obj),
      length = (_keys || obj).length;
  for (var index = 0; index < length; index++) {
    var currentKey = _keys ? _keys[index] : index;
    if (!predicate(obj[currentKey], currentKey, obj)) return false;
  }
  return true;
}


/***/ }),

/***/ "./node_modules/underscore/modules/extend.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/extend.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _createAssigner_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createAssigner.js */ "./node_modules/underscore/modules/_createAssigner.js");
/* harmony import */ var _allKeys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./allKeys.js */ "./node_modules/underscore/modules/allKeys.js");



// Extend a given object with all the properties in passed-in object(s).
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_createAssigner_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_allKeys_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/***/ }),

/***/ "./node_modules/underscore/modules/extendOwn.js":
/*!******************************************************!*\
  !*** ./node_modules/underscore/modules/extendOwn.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _createAssigner_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createAssigner.js */ "./node_modules/underscore/modules/_createAssigner.js");
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keys.js */ "./node_modules/underscore/modules/keys.js");



// Assigns a given object with all the own properties in the passed-in
// object(s).
// (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_createAssigner_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_keys_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/***/ }),

/***/ "./node_modules/underscore/modules/filter.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/filter.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ filter)
/* harmony export */ });
/* harmony import */ var _cb_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_cb.js */ "./node_modules/underscore/modules/_cb.js");
/* harmony import */ var _each_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./each.js */ "./node_modules/underscore/modules/each.js");



// Return all the elements that pass a truth test.
function filter(obj, predicate, context) {
  var results = [];
  predicate = (0,_cb_js__WEBPACK_IMPORTED_MODULE_0__["default"])(predicate, context);
  (0,_each_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj, function(value, index, list) {
    if (predicate(value, index, list)) results.push(value);
  });
  return results;
}


/***/ }),

/***/ "./node_modules/underscore/modules/find.js":
/*!*************************************************!*\
  !*** ./node_modules/underscore/modules/find.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ find)
/* harmony export */ });
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_isArrayLike.js */ "./node_modules/underscore/modules/_isArrayLike.js");
/* harmony import */ var _findIndex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./findIndex.js */ "./node_modules/underscore/modules/findIndex.js");
/* harmony import */ var _findKey_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./findKey.js */ "./node_modules/underscore/modules/findKey.js");




// Return the first value which passes a truth test.
function find(obj, predicate, context) {
  var keyFinder = (0,_isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj) ? _findIndex_js__WEBPACK_IMPORTED_MODULE_1__["default"] : _findKey_js__WEBPACK_IMPORTED_MODULE_2__["default"];
  var key = keyFinder(obj, predicate, context);
  if (key !== void 0 && key !== -1) return obj[key];
}


/***/ }),

/***/ "./node_modules/underscore/modules/findIndex.js":
/*!******************************************************!*\
  !*** ./node_modules/underscore/modules/findIndex.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _createPredicateIndexFinder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createPredicateIndexFinder.js */ "./node_modules/underscore/modules/_createPredicateIndexFinder.js");


// Returns the first index on an array-like that passes a truth test.
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_createPredicateIndexFinder_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1));


/***/ }),

/***/ "./node_modules/underscore/modules/findKey.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/findKey.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ findKey)
/* harmony export */ });
/* harmony import */ var _cb_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_cb.js */ "./node_modules/underscore/modules/_cb.js");
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keys.js */ "./node_modules/underscore/modules/keys.js");



// Returns the first key on an object that passes a truth test.
function findKey(obj, predicate, context) {
  predicate = (0,_cb_js__WEBPACK_IMPORTED_MODULE_0__["default"])(predicate, context);
  var _keys = (0,_keys_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj), key;
  for (var i = 0, length = _keys.length; i < length; i++) {
    key = _keys[i];
    if (predicate(obj[key], key, obj)) return key;
  }
}


/***/ }),

/***/ "./node_modules/underscore/modules/findLastIndex.js":
/*!**********************************************************!*\
  !*** ./node_modules/underscore/modules/findLastIndex.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _createPredicateIndexFinder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createPredicateIndexFinder.js */ "./node_modules/underscore/modules/_createPredicateIndexFinder.js");


// Returns the last index on an array-like that passes a truth test.
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_createPredicateIndexFinder_js__WEBPACK_IMPORTED_MODULE_0__["default"])(-1));


/***/ }),

/***/ "./node_modules/underscore/modules/findWhere.js":
/*!******************************************************!*\
  !*** ./node_modules/underscore/modules/findWhere.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ findWhere)
/* harmony export */ });
/* harmony import */ var _find_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./find.js */ "./node_modules/underscore/modules/find.js");
/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./matcher.js */ "./node_modules/underscore/modules/matcher.js");



// Convenience version of a common use case of `_.find`: getting the first
// object containing specific `key:value` pairs.
function findWhere(obj, attrs) {
  return (0,_find_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj, (0,_matcher_js__WEBPACK_IMPORTED_MODULE_1__["default"])(attrs));
}


/***/ }),

/***/ "./node_modules/underscore/modules/first.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/first.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ first)
/* harmony export */ });
/* harmony import */ var _initial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./initial.js */ "./node_modules/underscore/modules/initial.js");


// Get the first element of an array. Passing **n** will return the first N
// values in the array. The **guard** check allows it to work with `_.map`.
function first(array, n, guard) {
  if (array == null || array.length < 1) return n == null || guard ? void 0 : [];
  if (n == null || guard) return array[0];
  return (0,_initial_js__WEBPACK_IMPORTED_MODULE_0__["default"])(array, array.length - n);
}


/***/ }),

/***/ "./node_modules/underscore/modules/flatten.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/flatten.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ flatten)
/* harmony export */ });
/* harmony import */ var _flatten_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_flatten.js */ "./node_modules/underscore/modules/_flatten.js");


// Flatten out an array, either recursively (by default), or up to `depth`.
// Passing `true` or `false` as `depth` means `1` or `Infinity`, respectively.
function flatten(array, depth) {
  return (0,_flatten_js__WEBPACK_IMPORTED_MODULE_0__["default"])(array, depth, false);
}


/***/ }),

/***/ "./node_modules/underscore/modules/functions.js":
/*!******************************************************!*\
  !*** ./node_modules/underscore/modules/functions.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ functions)
/* harmony export */ });
/* harmony import */ var _isFunction_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isFunction.js */ "./node_modules/underscore/modules/isFunction.js");


// Return a sorted list of the function names available on the object.
function functions(obj) {
  var names = [];
  for (var key in obj) {
    if ((0,_isFunction_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj[key])) names.push(key);
  }
  return names.sort();
}


/***/ }),

/***/ "./node_modules/underscore/modules/get.js":
/*!************************************************!*\
  !*** ./node_modules/underscore/modules/get.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ get)
/* harmony export */ });
/* harmony import */ var _toPath_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_toPath.js */ "./node_modules/underscore/modules/_toPath.js");
/* harmony import */ var _deepGet_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_deepGet.js */ "./node_modules/underscore/modules/_deepGet.js");
/* harmony import */ var _isUndefined_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isUndefined.js */ "./node_modules/underscore/modules/isUndefined.js");




// Get the value of the (deep) property on `path` from `object`.
// If any property in `path` does not exist or if the value is
// `undefined`, return `defaultValue` instead.
// The `path` is normalized through `_.toPath`.
function get(object, path, defaultValue) {
  var value = (0,_deepGet_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object, (0,_toPath_js__WEBPACK_IMPORTED_MODULE_0__["default"])(path));
  return (0,_isUndefined_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value) ? defaultValue : value;
}


/***/ }),

/***/ "./node_modules/underscore/modules/groupBy.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/groupBy.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _group_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_group.js */ "./node_modules/underscore/modules/_group.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_has.js */ "./node_modules/underscore/modules/_has.js");



// Groups the object's values by a criterion. Pass either a string attribute
// to group by, or a function that returns the criterion.
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_group_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(result, value, key) {
  if ((0,_has_js__WEBPACK_IMPORTED_MODULE_1__["default"])(result, key)) result[key].push(value); else result[key] = [value];
}));


/***/ }),

/***/ "./node_modules/underscore/modules/has.js":
/*!************************************************!*\
  !*** ./node_modules/underscore/modules/has.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ has)
/* harmony export */ });
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_has.js */ "./node_modules/underscore/modules/_has.js");
/* harmony import */ var _toPath_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_toPath.js */ "./node_modules/underscore/modules/_toPath.js");



// Shortcut function for checking if an object has a given property directly on
// itself (in other words, not on a prototype). Unlike the internal `has`
// function, this public version can also traverse nested properties.
function has(obj, path) {
  path = (0,_toPath_js__WEBPACK_IMPORTED_MODULE_1__["default"])(path);
  var length = path.length;
  for (var i = 0; i < length; i++) {
    var key = path[i];
    if (!(0,_has_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj, key)) return false;
    obj = obj[key];
  }
  return !!length;
}


/***/ }),

/***/ "./node_modules/underscore/modules/identity.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/identity.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ identity)
/* harmony export */ });
// Keep the identity function around for default iteratees.
function identity(value) {
  return value;
}


/***/ }),

/***/ "./node_modules/underscore/modules/index-all.js":
/*!******************************************************!*\
  !*** ./node_modules/underscore/modules/index-all.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VERSION: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.VERSION),
/* harmony export */   after: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.after),
/* harmony export */   all: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.all),
/* harmony export */   allKeys: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.allKeys),
/* harmony export */   any: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.any),
/* harmony export */   assign: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.assign),
/* harmony export */   before: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.before),
/* harmony export */   bind: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.bind),
/* harmony export */   bindAll: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.bindAll),
/* harmony export */   chain: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.chain),
/* harmony export */   chunk: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.chunk),
/* harmony export */   clone: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.clone),
/* harmony export */   collect: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.collect),
/* harmony export */   compact: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.compact),
/* harmony export */   compose: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.compose),
/* harmony export */   constant: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.constant),
/* harmony export */   contains: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.contains),
/* harmony export */   countBy: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.countBy),
/* harmony export */   create: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.create),
/* harmony export */   debounce: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.debounce),
/* harmony export */   "default": () => (/* reexport safe */ _index_default_js__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   defaults: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.defaults),
/* harmony export */   defer: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.defer),
/* harmony export */   delay: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.delay),
/* harmony export */   detect: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.detect),
/* harmony export */   difference: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.difference),
/* harmony export */   drop: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.drop),
/* harmony export */   each: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.each),
/* harmony export */   escape: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.escape),
/* harmony export */   every: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.every),
/* harmony export */   extend: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.extend),
/* harmony export */   extendOwn: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.extendOwn),
/* harmony export */   filter: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.filter),
/* harmony export */   find: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.find),
/* harmony export */   findIndex: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.findIndex),
/* harmony export */   findKey: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.findKey),
/* harmony export */   findLastIndex: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.findLastIndex),
/* harmony export */   findWhere: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.findWhere),
/* harmony export */   first: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.first),
/* harmony export */   flatten: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.flatten),
/* harmony export */   foldl: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.foldl),
/* harmony export */   foldr: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.foldr),
/* harmony export */   forEach: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.forEach),
/* harmony export */   functions: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.functions),
/* harmony export */   get: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.get),
/* harmony export */   groupBy: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.groupBy),
/* harmony export */   has: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.has),
/* harmony export */   head: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.head),
/* harmony export */   identity: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.identity),
/* harmony export */   include: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.include),
/* harmony export */   includes: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.includes),
/* harmony export */   indexBy: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.indexBy),
/* harmony export */   indexOf: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.indexOf),
/* harmony export */   initial: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.initial),
/* harmony export */   inject: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.inject),
/* harmony export */   intersection: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.intersection),
/* harmony export */   invert: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.invert),
/* harmony export */   invoke: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.invoke),
/* harmony export */   isArguments: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.isArguments),
/* harmony export */   isArray: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.isArray),
/* harmony export */   isArrayBuffer: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.isArrayBuffer),
/* harmony export */   isBoolean: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.isBoolean),
/* harmony export */   isDataView: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.isDataView),
/* harmony export */   isDate: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.isDate),
/* harmony export */   isElement: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.isElement),
/* harmony export */   isEmpty: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.isEmpty),
/* harmony export */   isEqual: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.isEqual),
/* harmony export */   isError: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.isError),
/* harmony export */   isFinite: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.isFinite),
/* harmony export */   isFunction: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.isFunction),
/* harmony export */   isMap: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.isMap),
/* harmony export */   isMatch: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.isMatch),
/* harmony export */   isNaN: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.isNaN),
/* harmony export */   isNull: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.isNull),
/* harmony export */   isNumber: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.isNumber),
/* harmony export */   isObject: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.isObject),
/* harmony export */   isRegExp: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.isRegExp),
/* harmony export */   isSet: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.isSet),
/* harmony export */   isString: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.isString),
/* harmony export */   isSymbol: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.isSymbol),
/* harmony export */   isTypedArray: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.isTypedArray),
/* harmony export */   isUndefined: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.isUndefined),
/* harmony export */   isWeakMap: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.isWeakMap),
/* harmony export */   isWeakSet: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.isWeakSet),
/* harmony export */   iteratee: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.iteratee),
/* harmony export */   keys: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.keys),
/* harmony export */   last: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.last),
/* harmony export */   lastIndexOf: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.lastIndexOf),
/* harmony export */   map: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.map),
/* harmony export */   mapObject: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.mapObject),
/* harmony export */   matcher: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.matcher),
/* harmony export */   matches: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.matches),
/* harmony export */   max: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.max),
/* harmony export */   memoize: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.memoize),
/* harmony export */   methods: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.methods),
/* harmony export */   min: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.min),
/* harmony export */   mixin: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.mixin),
/* harmony export */   negate: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.negate),
/* harmony export */   noop: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.noop),
/* harmony export */   now: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.now),
/* harmony export */   object: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.object),
/* harmony export */   omit: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.omit),
/* harmony export */   once: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.once),
/* harmony export */   pairs: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.pairs),
/* harmony export */   partial: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.partial),
/* harmony export */   partition: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.partition),
/* harmony export */   pick: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.pick),
/* harmony export */   pluck: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.pluck),
/* harmony export */   property: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.property),
/* harmony export */   propertyOf: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.propertyOf),
/* harmony export */   random: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.random),
/* harmony export */   range: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.range),
/* harmony export */   reduce: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.reduce),
/* harmony export */   reduceRight: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.reduceRight),
/* harmony export */   reject: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.reject),
/* harmony export */   rest: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.rest),
/* harmony export */   restArguments: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.restArguments),
/* harmony export */   result: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.result),
/* harmony export */   sample: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.sample),
/* harmony export */   select: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.select),
/* harmony export */   shuffle: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.shuffle),
/* harmony export */   size: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.size),
/* harmony export */   some: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.some),
/* harmony export */   sortBy: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.sortBy),
/* harmony export */   sortedIndex: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.sortedIndex),
/* harmony export */   tail: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.tail),
/* harmony export */   take: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.take),
/* harmony export */   tap: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.tap),
/* harmony export */   template: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.template),
/* harmony export */   templateSettings: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.templateSettings),
/* harmony export */   throttle: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.throttle),
/* harmony export */   times: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.times),
/* harmony export */   toArray: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.toArray),
/* harmony export */   toPath: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.toPath),
/* harmony export */   transpose: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.transpose),
/* harmony export */   unescape: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.unescape),
/* harmony export */   union: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.union),
/* harmony export */   uniq: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.uniq),
/* harmony export */   unique: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.unique),
/* harmony export */   uniqueId: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.uniqueId),
/* harmony export */   unzip: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.unzip),
/* harmony export */   values: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.values),
/* harmony export */   where: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.where),
/* harmony export */   without: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.without),
/* harmony export */   wrap: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.wrap),
/* harmony export */   zip: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_1__.zip)
/* harmony export */ });
/* harmony import */ var _index_default_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-default.js */ "./node_modules/underscore/modules/index-default.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/underscore/modules/index.js");
// ESM Exports
// ===========
// This module is the package entry point for ES module users. In other words,
// it is the module they are interfacing with when they import from the whole
// package instead of from a submodule, like this:
//
// ```js
// import { map } from 'underscore';
// ```
//
// The difference with `./index-default`, which is the package entry point for
// CommonJS, AMD and UMD users, is purely technical. In ES modules, named and
// default exports are considered to be siblings, so when you have a default
// export, its properties are not automatically available as named exports. For
// this reason, we re-export the named exports in addition to providing the same
// default export as in `./index-default`.




/***/ }),

/***/ "./node_modules/underscore/modules/index-default.js":
/*!**********************************************************!*\
  !*** ./node_modules/underscore/modules/index-default.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/underscore/modules/index.js");
// Default Export
// ==============
// In this module, we mix our bundled exports into the `_` object and export
// the result. This is analogous to setting `module.exports = _` in CommonJS.
// Hence, this module is also the entry point of our UMD bundle and the package
// entry point for CommonJS and AMD users. In other words, this is (the source
// of) the module you are interfacing with when you do any of the following:
//
// ```js
// // CommonJS
// var _ = require('underscore');
//
// // AMD
// define(['underscore'], function(_) {...});
//
// // UMD in the browser
// // _ is available as a global variable
// ```



// Add all of the Underscore functions to the wrapper object.
var _ = (0,_index_js__WEBPACK_IMPORTED_MODULE_0__.mixin)(_index_js__WEBPACK_IMPORTED_MODULE_0__);
// Legacy Node.js API.
_._ = _;
// Export the Underscore API.
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_);


/***/ }),

/***/ "./node_modules/underscore/modules/index.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VERSION: () => (/* reexport safe */ _setup_js__WEBPACK_IMPORTED_MODULE_0__.VERSION),
/* harmony export */   after: () => (/* reexport safe */ _after_js__WEBPACK_IMPORTED_MODULE_72__["default"]),
/* harmony export */   all: () => (/* reexport safe */ _every_js__WEBPACK_IMPORTED_MODULE_89__["default"]),
/* harmony export */   allKeys: () => (/* reexport safe */ _allKeys_js__WEBPACK_IMPORTED_MODULE_29__["default"]),
/* harmony export */   any: () => (/* reexport safe */ _some_js__WEBPACK_IMPORTED_MODULE_90__["default"]),
/* harmony export */   assign: () => (/* reexport safe */ _extendOwn_js__WEBPACK_IMPORTED_MODULE_35__["default"]),
/* harmony export */   before: () => (/* reexport safe */ _before_js__WEBPACK_IMPORTED_MODULE_73__["default"]),
/* harmony export */   bind: () => (/* reexport safe */ _bind_js__WEBPACK_IMPORTED_MODULE_62__["default"]),
/* harmony export */   bindAll: () => (/* reexport safe */ _bindAll_js__WEBPACK_IMPORTED_MODULE_63__["default"]),
/* harmony export */   chain: () => (/* reexport safe */ _chain_js__WEBPACK_IMPORTED_MODULE_59__["default"]),
/* harmony export */   chunk: () => (/* reexport safe */ _chunk_js__WEBPACK_IMPORTED_MODULE_123__["default"]),
/* harmony export */   clone: () => (/* reexport safe */ _clone_js__WEBPACK_IMPORTED_MODULE_38__["default"]),
/* harmony export */   collect: () => (/* reexport safe */ _map_js__WEBPACK_IMPORTED_MODULE_84__["default"]),
/* harmony export */   compact: () => (/* reexport safe */ _compact_js__WEBPACK_IMPORTED_MODULE_112__["default"]),
/* harmony export */   compose: () => (/* reexport safe */ _compose_js__WEBPACK_IMPORTED_MODULE_71__["default"]),
/* harmony export */   constant: () => (/* reexport safe */ _constant_js__WEBPACK_IMPORTED_MODULE_44__["default"]),
/* harmony export */   contains: () => (/* reexport safe */ _contains_js__WEBPACK_IMPORTED_MODULE_91__["default"]),
/* harmony export */   countBy: () => (/* reexport safe */ _countBy_js__WEBPACK_IMPORTED_MODULE_102__["default"]),
/* harmony export */   create: () => (/* reexport safe */ _create_js__WEBPACK_IMPORTED_MODULE_37__["default"]),
/* harmony export */   debounce: () => (/* reexport safe */ _debounce_js__WEBPACK_IMPORTED_MODULE_68__["default"]),
/* harmony export */   "default": () => (/* reexport safe */ _underscore_array_methods_js__WEBPACK_IMPORTED_MODULE_125__["default"]),
/* harmony export */   defaults: () => (/* reexport safe */ _defaults_js__WEBPACK_IMPORTED_MODULE_36__["default"]),
/* harmony export */   defer: () => (/* reexport safe */ _defer_js__WEBPACK_IMPORTED_MODULE_66__["default"]),
/* harmony export */   delay: () => (/* reexport safe */ _delay_js__WEBPACK_IMPORTED_MODULE_65__["default"]),
/* harmony export */   detect: () => (/* reexport safe */ _find_js__WEBPACK_IMPORTED_MODULE_81__["default"]),
/* harmony export */   difference: () => (/* reexport safe */ _difference_js__WEBPACK_IMPORTED_MODULE_118__["default"]),
/* harmony export */   drop: () => (/* reexport safe */ _rest_js__WEBPACK_IMPORTED_MODULE_111__["default"]),
/* harmony export */   each: () => (/* reexport safe */ _each_js__WEBPACK_IMPORTED_MODULE_83__["default"]),
/* harmony export */   escape: () => (/* reexport safe */ _escape_js__WEBPACK_IMPORTED_MODULE_53__["default"]),
/* harmony export */   every: () => (/* reexport safe */ _every_js__WEBPACK_IMPORTED_MODULE_89__["default"]),
/* harmony export */   extend: () => (/* reexport safe */ _extend_js__WEBPACK_IMPORTED_MODULE_34__["default"]),
/* harmony export */   extendOwn: () => (/* reexport safe */ _extendOwn_js__WEBPACK_IMPORTED_MODULE_35__["default"]),
/* harmony export */   filter: () => (/* reexport safe */ _filter_js__WEBPACK_IMPORTED_MODULE_87__["default"]),
/* harmony export */   find: () => (/* reexport safe */ _find_js__WEBPACK_IMPORTED_MODULE_81__["default"]),
/* harmony export */   findIndex: () => (/* reexport safe */ _findIndex_js__WEBPACK_IMPORTED_MODULE_76__["default"]),
/* harmony export */   findKey: () => (/* reexport safe */ _findKey_js__WEBPACK_IMPORTED_MODULE_75__["default"]),
/* harmony export */   findLastIndex: () => (/* reexport safe */ _findLastIndex_js__WEBPACK_IMPORTED_MODULE_77__["default"]),
/* harmony export */   findWhere: () => (/* reexport safe */ _findWhere_js__WEBPACK_IMPORTED_MODULE_82__["default"]),
/* harmony export */   first: () => (/* reexport safe */ _first_js__WEBPACK_IMPORTED_MODULE_108__["default"]),
/* harmony export */   flatten: () => (/* reexport safe */ _flatten_js__WEBPACK_IMPORTED_MODULE_113__["default"]),
/* harmony export */   foldl: () => (/* reexport safe */ _reduce_js__WEBPACK_IMPORTED_MODULE_85__["default"]),
/* harmony export */   foldr: () => (/* reexport safe */ _reduceRight_js__WEBPACK_IMPORTED_MODULE_86__["default"]),
/* harmony export */   forEach: () => (/* reexport safe */ _each_js__WEBPACK_IMPORTED_MODULE_83__["default"]),
/* harmony export */   functions: () => (/* reexport safe */ _functions_js__WEBPACK_IMPORTED_MODULE_33__["default"]),
/* harmony export */   get: () => (/* reexport safe */ _get_js__WEBPACK_IMPORTED_MODULE_40__["default"]),
/* harmony export */   groupBy: () => (/* reexport safe */ _groupBy_js__WEBPACK_IMPORTED_MODULE_100__["default"]),
/* harmony export */   has: () => (/* reexport safe */ _has_js__WEBPACK_IMPORTED_MODULE_41__["default"]),
/* harmony export */   head: () => (/* reexport safe */ _first_js__WEBPACK_IMPORTED_MODULE_108__["default"]),
/* harmony export */   identity: () => (/* reexport safe */ _identity_js__WEBPACK_IMPORTED_MODULE_43__["default"]),
/* harmony export */   include: () => (/* reexport safe */ _contains_js__WEBPACK_IMPORTED_MODULE_91__["default"]),
/* harmony export */   includes: () => (/* reexport safe */ _contains_js__WEBPACK_IMPORTED_MODULE_91__["default"]),
/* harmony export */   indexBy: () => (/* reexport safe */ _indexBy_js__WEBPACK_IMPORTED_MODULE_101__["default"]),
/* harmony export */   indexOf: () => (/* reexport safe */ _indexOf_js__WEBPACK_IMPORTED_MODULE_79__["default"]),
/* harmony export */   initial: () => (/* reexport safe */ _initial_js__WEBPACK_IMPORTED_MODULE_109__["default"]),
/* harmony export */   inject: () => (/* reexport safe */ _reduce_js__WEBPACK_IMPORTED_MODULE_85__["default"]),
/* harmony export */   intersection: () => (/* reexport safe */ _intersection_js__WEBPACK_IMPORTED_MODULE_117__["default"]),
/* harmony export */   invert: () => (/* reexport safe */ _invert_js__WEBPACK_IMPORTED_MODULE_32__["default"]),
/* harmony export */   invoke: () => (/* reexport safe */ _invoke_js__WEBPACK_IMPORTED_MODULE_92__["default"]),
/* harmony export */   isArguments: () => (/* reexport safe */ _isArguments_js__WEBPACK_IMPORTED_MODULE_17__["default"]),
/* harmony export */   isArray: () => (/* reexport safe */ _isArray_js__WEBPACK_IMPORTED_MODULE_15__["default"]),
/* harmony export */   isArrayBuffer: () => (/* reexport safe */ _isArrayBuffer_js__WEBPACK_IMPORTED_MODULE_13__["default"]),
/* harmony export */   isBoolean: () => (/* reexport safe */ _isBoolean_js__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   isDataView: () => (/* reexport safe */ _isDataView_js__WEBPACK_IMPORTED_MODULE_14__["default"]),
/* harmony export */   isDate: () => (/* reexport safe */ _isDate_js__WEBPACK_IMPORTED_MODULE_9__["default"]),
/* harmony export */   isElement: () => (/* reexport safe */ _isElement_js__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   isEmpty: () => (/* reexport safe */ _isEmpty_js__WEBPACK_IMPORTED_MODULE_21__["default"]),
/* harmony export */   isEqual: () => (/* reexport safe */ _isEqual_js__WEBPACK_IMPORTED_MODULE_23__["default"]),
/* harmony export */   isError: () => (/* reexport safe */ _isError_js__WEBPACK_IMPORTED_MODULE_11__["default"]),
/* harmony export */   isFinite: () => (/* reexport safe */ _isFinite_js__WEBPACK_IMPORTED_MODULE_18__["default"]),
/* harmony export */   isFunction: () => (/* reexport safe */ _isFunction_js__WEBPACK_IMPORTED_MODULE_16__["default"]),
/* harmony export */   isMap: () => (/* reexport safe */ _isMap_js__WEBPACK_IMPORTED_MODULE_24__["default"]),
/* harmony export */   isMatch: () => (/* reexport safe */ _isMatch_js__WEBPACK_IMPORTED_MODULE_22__["default"]),
/* harmony export */   isNaN: () => (/* reexport safe */ _isNaN_js__WEBPACK_IMPORTED_MODULE_19__["default"]),
/* harmony export */   isNull: () => (/* reexport safe */ _isNull_js__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   isNumber: () => (/* reexport safe */ _isNumber_js__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   isObject: () => (/* reexport safe */ _isObject_js__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   isRegExp: () => (/* reexport safe */ _isRegExp_js__WEBPACK_IMPORTED_MODULE_10__["default"]),
/* harmony export */   isSet: () => (/* reexport safe */ _isSet_js__WEBPACK_IMPORTED_MODULE_26__["default"]),
/* harmony export */   isString: () => (/* reexport safe */ _isString_js__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   isSymbol: () => (/* reexport safe */ _isSymbol_js__WEBPACK_IMPORTED_MODULE_12__["default"]),
/* harmony export */   isTypedArray: () => (/* reexport safe */ _isTypedArray_js__WEBPACK_IMPORTED_MODULE_20__["default"]),
/* harmony export */   isUndefined: () => (/* reexport safe */ _isUndefined_js__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   isWeakMap: () => (/* reexport safe */ _isWeakMap_js__WEBPACK_IMPORTED_MODULE_25__["default"]),
/* harmony export */   isWeakSet: () => (/* reexport safe */ _isWeakSet_js__WEBPACK_IMPORTED_MODULE_27__["default"]),
/* harmony export */   iteratee: () => (/* reexport safe */ _iteratee_js__WEBPACK_IMPORTED_MODULE_60__["default"]),
/* harmony export */   keys: () => (/* reexport safe */ _keys_js__WEBPACK_IMPORTED_MODULE_28__["default"]),
/* harmony export */   last: () => (/* reexport safe */ _last_js__WEBPACK_IMPORTED_MODULE_110__["default"]),
/* harmony export */   lastIndexOf: () => (/* reexport safe */ _lastIndexOf_js__WEBPACK_IMPORTED_MODULE_80__["default"]),
/* harmony export */   map: () => (/* reexport safe */ _map_js__WEBPACK_IMPORTED_MODULE_84__["default"]),
/* harmony export */   mapObject: () => (/* reexport safe */ _mapObject_js__WEBPACK_IMPORTED_MODULE_42__["default"]),
/* harmony export */   matcher: () => (/* reexport safe */ _matcher_js__WEBPACK_IMPORTED_MODULE_49__["default"]),
/* harmony export */   matches: () => (/* reexport safe */ _matcher_js__WEBPACK_IMPORTED_MODULE_49__["default"]),
/* harmony export */   max: () => (/* reexport safe */ _max_js__WEBPACK_IMPORTED_MODULE_95__["default"]),
/* harmony export */   memoize: () => (/* reexport safe */ _memoize_js__WEBPACK_IMPORTED_MODULE_64__["default"]),
/* harmony export */   methods: () => (/* reexport safe */ _functions_js__WEBPACK_IMPORTED_MODULE_33__["default"]),
/* harmony export */   min: () => (/* reexport safe */ _min_js__WEBPACK_IMPORTED_MODULE_96__["default"]),
/* harmony export */   mixin: () => (/* reexport safe */ _mixin_js__WEBPACK_IMPORTED_MODULE_124__["default"]),
/* harmony export */   negate: () => (/* reexport safe */ _negate_js__WEBPACK_IMPORTED_MODULE_70__["default"]),
/* harmony export */   noop: () => (/* reexport safe */ _noop_js__WEBPACK_IMPORTED_MODULE_45__["default"]),
/* harmony export */   now: () => (/* reexport safe */ _now_js__WEBPACK_IMPORTED_MODULE_52__["default"]),
/* harmony export */   object: () => (/* reexport safe */ _object_js__WEBPACK_IMPORTED_MODULE_121__["default"]),
/* harmony export */   omit: () => (/* reexport safe */ _omit_js__WEBPACK_IMPORTED_MODULE_107__["default"]),
/* harmony export */   once: () => (/* reexport safe */ _once_js__WEBPACK_IMPORTED_MODULE_74__["default"]),
/* harmony export */   pairs: () => (/* reexport safe */ _pairs_js__WEBPACK_IMPORTED_MODULE_31__["default"]),
/* harmony export */   partial: () => (/* reexport safe */ _partial_js__WEBPACK_IMPORTED_MODULE_61__["default"]),
/* harmony export */   partition: () => (/* reexport safe */ _partition_js__WEBPACK_IMPORTED_MODULE_103__["default"]),
/* harmony export */   pick: () => (/* reexport safe */ _pick_js__WEBPACK_IMPORTED_MODULE_106__["default"]),
/* harmony export */   pluck: () => (/* reexport safe */ _pluck_js__WEBPACK_IMPORTED_MODULE_93__["default"]),
/* harmony export */   property: () => (/* reexport safe */ _property_js__WEBPACK_IMPORTED_MODULE_47__["default"]),
/* harmony export */   propertyOf: () => (/* reexport safe */ _propertyOf_js__WEBPACK_IMPORTED_MODULE_48__["default"]),
/* harmony export */   random: () => (/* reexport safe */ _random_js__WEBPACK_IMPORTED_MODULE_51__["default"]),
/* harmony export */   range: () => (/* reexport safe */ _range_js__WEBPACK_IMPORTED_MODULE_122__["default"]),
/* harmony export */   reduce: () => (/* reexport safe */ _reduce_js__WEBPACK_IMPORTED_MODULE_85__["default"]),
/* harmony export */   reduceRight: () => (/* reexport safe */ _reduceRight_js__WEBPACK_IMPORTED_MODULE_86__["default"]),
/* harmony export */   reject: () => (/* reexport safe */ _reject_js__WEBPACK_IMPORTED_MODULE_88__["default"]),
/* harmony export */   rest: () => (/* reexport safe */ _rest_js__WEBPACK_IMPORTED_MODULE_111__["default"]),
/* harmony export */   restArguments: () => (/* reexport safe */ _restArguments_js__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   result: () => (/* reexport safe */ _result_js__WEBPACK_IMPORTED_MODULE_57__["default"]),
/* harmony export */   sample: () => (/* reexport safe */ _sample_js__WEBPACK_IMPORTED_MODULE_98__["default"]),
/* harmony export */   select: () => (/* reexport safe */ _filter_js__WEBPACK_IMPORTED_MODULE_87__["default"]),
/* harmony export */   shuffle: () => (/* reexport safe */ _shuffle_js__WEBPACK_IMPORTED_MODULE_97__["default"]),
/* harmony export */   size: () => (/* reexport safe */ _size_js__WEBPACK_IMPORTED_MODULE_105__["default"]),
/* harmony export */   some: () => (/* reexport safe */ _some_js__WEBPACK_IMPORTED_MODULE_90__["default"]),
/* harmony export */   sortBy: () => (/* reexport safe */ _sortBy_js__WEBPACK_IMPORTED_MODULE_99__["default"]),
/* harmony export */   sortedIndex: () => (/* reexport safe */ _sortedIndex_js__WEBPACK_IMPORTED_MODULE_78__["default"]),
/* harmony export */   tail: () => (/* reexport safe */ _rest_js__WEBPACK_IMPORTED_MODULE_111__["default"]),
/* harmony export */   take: () => (/* reexport safe */ _first_js__WEBPACK_IMPORTED_MODULE_108__["default"]),
/* harmony export */   tap: () => (/* reexport safe */ _tap_js__WEBPACK_IMPORTED_MODULE_39__["default"]),
/* harmony export */   template: () => (/* reexport safe */ _template_js__WEBPACK_IMPORTED_MODULE_56__["default"]),
/* harmony export */   templateSettings: () => (/* reexport safe */ _templateSettings_js__WEBPACK_IMPORTED_MODULE_55__["default"]),
/* harmony export */   throttle: () => (/* reexport safe */ _throttle_js__WEBPACK_IMPORTED_MODULE_67__["default"]),
/* harmony export */   times: () => (/* reexport safe */ _times_js__WEBPACK_IMPORTED_MODULE_50__["default"]),
/* harmony export */   toArray: () => (/* reexport safe */ _toArray_js__WEBPACK_IMPORTED_MODULE_104__["default"]),
/* harmony export */   toPath: () => (/* reexport safe */ _toPath_js__WEBPACK_IMPORTED_MODULE_46__["default"]),
/* harmony export */   transpose: () => (/* reexport safe */ _unzip_js__WEBPACK_IMPORTED_MODULE_119__["default"]),
/* harmony export */   unescape: () => (/* reexport safe */ _unescape_js__WEBPACK_IMPORTED_MODULE_54__["default"]),
/* harmony export */   union: () => (/* reexport safe */ _union_js__WEBPACK_IMPORTED_MODULE_116__["default"]),
/* harmony export */   uniq: () => (/* reexport safe */ _uniq_js__WEBPACK_IMPORTED_MODULE_115__["default"]),
/* harmony export */   unique: () => (/* reexport safe */ _uniq_js__WEBPACK_IMPORTED_MODULE_115__["default"]),
/* harmony export */   uniqueId: () => (/* reexport safe */ _uniqueId_js__WEBPACK_IMPORTED_MODULE_58__["default"]),
/* harmony export */   unzip: () => (/* reexport safe */ _unzip_js__WEBPACK_IMPORTED_MODULE_119__["default"]),
/* harmony export */   values: () => (/* reexport safe */ _values_js__WEBPACK_IMPORTED_MODULE_30__["default"]),
/* harmony export */   where: () => (/* reexport safe */ _where_js__WEBPACK_IMPORTED_MODULE_94__["default"]),
/* harmony export */   without: () => (/* reexport safe */ _without_js__WEBPACK_IMPORTED_MODULE_114__["default"]),
/* harmony export */   wrap: () => (/* reexport safe */ _wrap_js__WEBPACK_IMPORTED_MODULE_69__["default"]),
/* harmony export */   zip: () => (/* reexport safe */ _zip_js__WEBPACK_IMPORTED_MODULE_120__["default"])
/* harmony export */ });
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");
/* harmony import */ var _restArguments_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./restArguments.js */ "./node_modules/underscore/modules/restArguments.js");
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isObject.js */ "./node_modules/underscore/modules/isObject.js");
/* harmony import */ var _isNull_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isNull.js */ "./node_modules/underscore/modules/isNull.js");
/* harmony import */ var _isUndefined_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./isUndefined.js */ "./node_modules/underscore/modules/isUndefined.js");
/* harmony import */ var _isBoolean_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./isBoolean.js */ "./node_modules/underscore/modules/isBoolean.js");
/* harmony import */ var _isElement_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./isElement.js */ "./node_modules/underscore/modules/isElement.js");
/* harmony import */ var _isString_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./isString.js */ "./node_modules/underscore/modules/isString.js");
/* harmony import */ var _isNumber_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./isNumber.js */ "./node_modules/underscore/modules/isNumber.js");
/* harmony import */ var _isDate_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./isDate.js */ "./node_modules/underscore/modules/isDate.js");
/* harmony import */ var _isRegExp_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./isRegExp.js */ "./node_modules/underscore/modules/isRegExp.js");
/* harmony import */ var _isError_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./isError.js */ "./node_modules/underscore/modules/isError.js");
/* harmony import */ var _isSymbol_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./isSymbol.js */ "./node_modules/underscore/modules/isSymbol.js");
/* harmony import */ var _isArrayBuffer_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./isArrayBuffer.js */ "./node_modules/underscore/modules/isArrayBuffer.js");
/* harmony import */ var _isDataView_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./isDataView.js */ "./node_modules/underscore/modules/isDataView.js");
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/underscore/modules/isArray.js");
/* harmony import */ var _isFunction_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./isFunction.js */ "./node_modules/underscore/modules/isFunction.js");
/* harmony import */ var _isArguments_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./isArguments.js */ "./node_modules/underscore/modules/isArguments.js");
/* harmony import */ var _isFinite_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./isFinite.js */ "./node_modules/underscore/modules/isFinite.js");
/* harmony import */ var _isNaN_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./isNaN.js */ "./node_modules/underscore/modules/isNaN.js");
/* harmony import */ var _isTypedArray_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./isTypedArray.js */ "./node_modules/underscore/modules/isTypedArray.js");
/* harmony import */ var _isEmpty_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./isEmpty.js */ "./node_modules/underscore/modules/isEmpty.js");
/* harmony import */ var _isMatch_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./isMatch.js */ "./node_modules/underscore/modules/isMatch.js");
/* harmony import */ var _isEqual_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./isEqual.js */ "./node_modules/underscore/modules/isEqual.js");
/* harmony import */ var _isMap_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./isMap.js */ "./node_modules/underscore/modules/isMap.js");
/* harmony import */ var _isWeakMap_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./isWeakMap.js */ "./node_modules/underscore/modules/isWeakMap.js");
/* harmony import */ var _isSet_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./isSet.js */ "./node_modules/underscore/modules/isSet.js");
/* harmony import */ var _isWeakSet_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./isWeakSet.js */ "./node_modules/underscore/modules/isWeakSet.js");
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./keys.js */ "./node_modules/underscore/modules/keys.js");
/* harmony import */ var _allKeys_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./allKeys.js */ "./node_modules/underscore/modules/allKeys.js");
/* harmony import */ var _values_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./values.js */ "./node_modules/underscore/modules/values.js");
/* harmony import */ var _pairs_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./pairs.js */ "./node_modules/underscore/modules/pairs.js");
/* harmony import */ var _invert_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./invert.js */ "./node_modules/underscore/modules/invert.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./functions.js */ "./node_modules/underscore/modules/functions.js");
/* harmony import */ var _extend_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./extend.js */ "./node_modules/underscore/modules/extend.js");
/* harmony import */ var _extendOwn_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./extendOwn.js */ "./node_modules/underscore/modules/extendOwn.js");
/* harmony import */ var _defaults_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./defaults.js */ "./node_modules/underscore/modules/defaults.js");
/* harmony import */ var _create_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./create.js */ "./node_modules/underscore/modules/create.js");
/* harmony import */ var _clone_js__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./clone.js */ "./node_modules/underscore/modules/clone.js");
/* harmony import */ var _tap_js__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./tap.js */ "./node_modules/underscore/modules/tap.js");
/* harmony import */ var _get_js__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./get.js */ "./node_modules/underscore/modules/get.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./has.js */ "./node_modules/underscore/modules/has.js");
/* harmony import */ var _mapObject_js__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./mapObject.js */ "./node_modules/underscore/modules/mapObject.js");
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./identity.js */ "./node_modules/underscore/modules/identity.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./constant.js */ "./node_modules/underscore/modules/constant.js");
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./noop.js */ "./node_modules/underscore/modules/noop.js");
/* harmony import */ var _toPath_js__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./toPath.js */ "./node_modules/underscore/modules/toPath.js");
/* harmony import */ var _property_js__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./property.js */ "./node_modules/underscore/modules/property.js");
/* harmony import */ var _propertyOf_js__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./propertyOf.js */ "./node_modules/underscore/modules/propertyOf.js");
/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./matcher.js */ "./node_modules/underscore/modules/matcher.js");
/* harmony import */ var _times_js__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./times.js */ "./node_modules/underscore/modules/times.js");
/* harmony import */ var _random_js__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./random.js */ "./node_modules/underscore/modules/random.js");
/* harmony import */ var _now_js__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./now.js */ "./node_modules/underscore/modules/now.js");
/* harmony import */ var _escape_js__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./escape.js */ "./node_modules/underscore/modules/escape.js");
/* harmony import */ var _unescape_js__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! ./unescape.js */ "./node_modules/underscore/modules/unescape.js");
/* harmony import */ var _templateSettings_js__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ./templateSettings.js */ "./node_modules/underscore/modules/templateSettings.js");
/* harmony import */ var _template_js__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! ./template.js */ "./node_modules/underscore/modules/template.js");
/* harmony import */ var _result_js__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! ./result.js */ "./node_modules/underscore/modules/result.js");
/* harmony import */ var _uniqueId_js__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! ./uniqueId.js */ "./node_modules/underscore/modules/uniqueId.js");
/* harmony import */ var _chain_js__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! ./chain.js */ "./node_modules/underscore/modules/chain.js");
/* harmony import */ var _iteratee_js__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(/*! ./iteratee.js */ "./node_modules/underscore/modules/iteratee.js");
/* harmony import */ var _partial_js__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(/*! ./partial.js */ "./node_modules/underscore/modules/partial.js");
/* harmony import */ var _bind_js__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(/*! ./bind.js */ "./node_modules/underscore/modules/bind.js");
/* harmony import */ var _bindAll_js__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(/*! ./bindAll.js */ "./node_modules/underscore/modules/bindAll.js");
/* harmony import */ var _memoize_js__WEBPACK_IMPORTED_MODULE_64__ = __webpack_require__(/*! ./memoize.js */ "./node_modules/underscore/modules/memoize.js");
/* harmony import */ var _delay_js__WEBPACK_IMPORTED_MODULE_65__ = __webpack_require__(/*! ./delay.js */ "./node_modules/underscore/modules/delay.js");
/* harmony import */ var _defer_js__WEBPACK_IMPORTED_MODULE_66__ = __webpack_require__(/*! ./defer.js */ "./node_modules/underscore/modules/defer.js");
/* harmony import */ var _throttle_js__WEBPACK_IMPORTED_MODULE_67__ = __webpack_require__(/*! ./throttle.js */ "./node_modules/underscore/modules/throttle.js");
/* harmony import */ var _debounce_js__WEBPACK_IMPORTED_MODULE_68__ = __webpack_require__(/*! ./debounce.js */ "./node_modules/underscore/modules/debounce.js");
/* harmony import */ var _wrap_js__WEBPACK_IMPORTED_MODULE_69__ = __webpack_require__(/*! ./wrap.js */ "./node_modules/underscore/modules/wrap.js");
/* harmony import */ var _negate_js__WEBPACK_IMPORTED_MODULE_70__ = __webpack_require__(/*! ./negate.js */ "./node_modules/underscore/modules/negate.js");
/* harmony import */ var _compose_js__WEBPACK_IMPORTED_MODULE_71__ = __webpack_require__(/*! ./compose.js */ "./node_modules/underscore/modules/compose.js");
/* harmony import */ var _after_js__WEBPACK_IMPORTED_MODULE_72__ = __webpack_require__(/*! ./after.js */ "./node_modules/underscore/modules/after.js");
/* harmony import */ var _before_js__WEBPACK_IMPORTED_MODULE_73__ = __webpack_require__(/*! ./before.js */ "./node_modules/underscore/modules/before.js");
/* harmony import */ var _once_js__WEBPACK_IMPORTED_MODULE_74__ = __webpack_require__(/*! ./once.js */ "./node_modules/underscore/modules/once.js");
/* harmony import */ var _findKey_js__WEBPACK_IMPORTED_MODULE_75__ = __webpack_require__(/*! ./findKey.js */ "./node_modules/underscore/modules/findKey.js");
/* harmony import */ var _findIndex_js__WEBPACK_IMPORTED_MODULE_76__ = __webpack_require__(/*! ./findIndex.js */ "./node_modules/underscore/modules/findIndex.js");
/* harmony import */ var _findLastIndex_js__WEBPACK_IMPORTED_MODULE_77__ = __webpack_require__(/*! ./findLastIndex.js */ "./node_modules/underscore/modules/findLastIndex.js");
/* harmony import */ var _sortedIndex_js__WEBPACK_IMPORTED_MODULE_78__ = __webpack_require__(/*! ./sortedIndex.js */ "./node_modules/underscore/modules/sortedIndex.js");
/* harmony import */ var _indexOf_js__WEBPACK_IMPORTED_MODULE_79__ = __webpack_require__(/*! ./indexOf.js */ "./node_modules/underscore/modules/indexOf.js");
/* harmony import */ var _lastIndexOf_js__WEBPACK_IMPORTED_MODULE_80__ = __webpack_require__(/*! ./lastIndexOf.js */ "./node_modules/underscore/modules/lastIndexOf.js");
/* harmony import */ var _find_js__WEBPACK_IMPORTED_MODULE_81__ = __webpack_require__(/*! ./find.js */ "./node_modules/underscore/modules/find.js");
/* harmony import */ var _findWhere_js__WEBPACK_IMPORTED_MODULE_82__ = __webpack_require__(/*! ./findWhere.js */ "./node_modules/underscore/modules/findWhere.js");
/* harmony import */ var _each_js__WEBPACK_IMPORTED_MODULE_83__ = __webpack_require__(/*! ./each.js */ "./node_modules/underscore/modules/each.js");
/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_84__ = __webpack_require__(/*! ./map.js */ "./node_modules/underscore/modules/map.js");
/* harmony import */ var _reduce_js__WEBPACK_IMPORTED_MODULE_85__ = __webpack_require__(/*! ./reduce.js */ "./node_modules/underscore/modules/reduce.js");
/* harmony import */ var _reduceRight_js__WEBPACK_IMPORTED_MODULE_86__ = __webpack_require__(/*! ./reduceRight.js */ "./node_modules/underscore/modules/reduceRight.js");
/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_87__ = __webpack_require__(/*! ./filter.js */ "./node_modules/underscore/modules/filter.js");
/* harmony import */ var _reject_js__WEBPACK_IMPORTED_MODULE_88__ = __webpack_require__(/*! ./reject.js */ "./node_modules/underscore/modules/reject.js");
/* harmony import */ var _every_js__WEBPACK_IMPORTED_MODULE_89__ = __webpack_require__(/*! ./every.js */ "./node_modules/underscore/modules/every.js");
/* harmony import */ var _some_js__WEBPACK_IMPORTED_MODULE_90__ = __webpack_require__(/*! ./some.js */ "./node_modules/underscore/modules/some.js");
/* harmony import */ var _contains_js__WEBPACK_IMPORTED_MODULE_91__ = __webpack_require__(/*! ./contains.js */ "./node_modules/underscore/modules/contains.js");
/* harmony import */ var _invoke_js__WEBPACK_IMPORTED_MODULE_92__ = __webpack_require__(/*! ./invoke.js */ "./node_modules/underscore/modules/invoke.js");
/* harmony import */ var _pluck_js__WEBPACK_IMPORTED_MODULE_93__ = __webpack_require__(/*! ./pluck.js */ "./node_modules/underscore/modules/pluck.js");
/* harmony import */ var _where_js__WEBPACK_IMPORTED_MODULE_94__ = __webpack_require__(/*! ./where.js */ "./node_modules/underscore/modules/where.js");
/* harmony import */ var _max_js__WEBPACK_IMPORTED_MODULE_95__ = __webpack_require__(/*! ./max.js */ "./node_modules/underscore/modules/max.js");
/* harmony import */ var _min_js__WEBPACK_IMPORTED_MODULE_96__ = __webpack_require__(/*! ./min.js */ "./node_modules/underscore/modules/min.js");
/* harmony import */ var _shuffle_js__WEBPACK_IMPORTED_MODULE_97__ = __webpack_require__(/*! ./shuffle.js */ "./node_modules/underscore/modules/shuffle.js");
/* harmony import */ var _sample_js__WEBPACK_IMPORTED_MODULE_98__ = __webpack_require__(/*! ./sample.js */ "./node_modules/underscore/modules/sample.js");
/* harmony import */ var _sortBy_js__WEBPACK_IMPORTED_MODULE_99__ = __webpack_require__(/*! ./sortBy.js */ "./node_modules/underscore/modules/sortBy.js");
/* harmony import */ var _groupBy_js__WEBPACK_IMPORTED_MODULE_100__ = __webpack_require__(/*! ./groupBy.js */ "./node_modules/underscore/modules/groupBy.js");
/* harmony import */ var _indexBy_js__WEBPACK_IMPORTED_MODULE_101__ = __webpack_require__(/*! ./indexBy.js */ "./node_modules/underscore/modules/indexBy.js");
/* harmony import */ var _countBy_js__WEBPACK_IMPORTED_MODULE_102__ = __webpack_require__(/*! ./countBy.js */ "./node_modules/underscore/modules/countBy.js");
/* harmony import */ var _partition_js__WEBPACK_IMPORTED_MODULE_103__ = __webpack_require__(/*! ./partition.js */ "./node_modules/underscore/modules/partition.js");
/* harmony import */ var _toArray_js__WEBPACK_IMPORTED_MODULE_104__ = __webpack_require__(/*! ./toArray.js */ "./node_modules/underscore/modules/toArray.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_105__ = __webpack_require__(/*! ./size.js */ "./node_modules/underscore/modules/size.js");
/* harmony import */ var _pick_js__WEBPACK_IMPORTED_MODULE_106__ = __webpack_require__(/*! ./pick.js */ "./node_modules/underscore/modules/pick.js");
/* harmony import */ var _omit_js__WEBPACK_IMPORTED_MODULE_107__ = __webpack_require__(/*! ./omit.js */ "./node_modules/underscore/modules/omit.js");
/* harmony import */ var _first_js__WEBPACK_IMPORTED_MODULE_108__ = __webpack_require__(/*! ./first.js */ "./node_modules/underscore/modules/first.js");
/* harmony import */ var _initial_js__WEBPACK_IMPORTED_MODULE_109__ = __webpack_require__(/*! ./initial.js */ "./node_modules/underscore/modules/initial.js");
/* harmony import */ var _last_js__WEBPACK_IMPORTED_MODULE_110__ = __webpack_require__(/*! ./last.js */ "./node_modules/underscore/modules/last.js");
/* harmony import */ var _rest_js__WEBPACK_IMPORTED_MODULE_111__ = __webpack_require__(/*! ./rest.js */ "./node_modules/underscore/modules/rest.js");
/* harmony import */ var _compact_js__WEBPACK_IMPORTED_MODULE_112__ = __webpack_require__(/*! ./compact.js */ "./node_modules/underscore/modules/compact.js");
/* harmony import */ var _flatten_js__WEBPACK_IMPORTED_MODULE_113__ = __webpack_require__(/*! ./flatten.js */ "./node_modules/underscore/modules/flatten.js");
/* harmony import */ var _without_js__WEBPACK_IMPORTED_MODULE_114__ = __webpack_require__(/*! ./without.js */ "./node_modules/underscore/modules/without.js");
/* harmony import */ var _uniq_js__WEBPACK_IMPORTED_MODULE_115__ = __webpack_require__(/*! ./uniq.js */ "./node_modules/underscore/modules/uniq.js");
/* harmony import */ var _union_js__WEBPACK_IMPORTED_MODULE_116__ = __webpack_require__(/*! ./union.js */ "./node_modules/underscore/modules/union.js");
/* harmony import */ var _intersection_js__WEBPACK_IMPORTED_MODULE_117__ = __webpack_require__(/*! ./intersection.js */ "./node_modules/underscore/modules/intersection.js");
/* harmony import */ var _difference_js__WEBPACK_IMPORTED_MODULE_118__ = __webpack_require__(/*! ./difference.js */ "./node_modules/underscore/modules/difference.js");
/* harmony import */ var _unzip_js__WEBPACK_IMPORTED_MODULE_119__ = __webpack_require__(/*! ./unzip.js */ "./node_modules/underscore/modules/unzip.js");
/* harmony import */ var _zip_js__WEBPACK_IMPORTED_MODULE_120__ = __webpack_require__(/*! ./zip.js */ "./node_modules/underscore/modules/zip.js");
/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_121__ = __webpack_require__(/*! ./object.js */ "./node_modules/underscore/modules/object.js");
/* harmony import */ var _range_js__WEBPACK_IMPORTED_MODULE_122__ = __webpack_require__(/*! ./range.js */ "./node_modules/underscore/modules/range.js");
/* harmony import */ var _chunk_js__WEBPACK_IMPORTED_MODULE_123__ = __webpack_require__(/*! ./chunk.js */ "./node_modules/underscore/modules/chunk.js");
/* harmony import */ var _mixin_js__WEBPACK_IMPORTED_MODULE_124__ = __webpack_require__(/*! ./mixin.js */ "./node_modules/underscore/modules/mixin.js");
/* harmony import */ var _underscore_array_methods_js__WEBPACK_IMPORTED_MODULE_125__ = __webpack_require__(/*! ./underscore-array-methods.js */ "./node_modules/underscore/modules/underscore-array-methods.js");
// Named Exports
// =============

//     Underscore.js 1.13.7
//     https://underscorejs.org
//     (c) 2009-2024 Jeremy Ashkenas, Julian Gonggrijp, and DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

// Baseline setup.



// Object Functions
// ----------------
// Our most fundamental functions operate on any JavaScript object.
// Most functions in Underscore depend on at least one function in this section.

// A group of functions that check the types of core JavaScript values.
// These are often informally referred to as the "isType" functions.



























// Functions that treat an object as a dictionary of key-value pairs.
















// Utility Functions
// -----------------
// A bit of a grab bag: Predicate-generating functions for use with filters and
// loops, string escaping and templating, create random numbers and unique ids,
// and functions that facilitate Underscore's chaining and iteration conventions.



















// Function (ahem) Functions
// -------------------------
// These functions take a function as an argument and return a new function
// as the result. Also known as higher-order functions.















// Finders
// -------
// Functions that extract (the position of) a single element from an object
// or array based on some criterion.









// Collection Functions
// --------------------
// Functions that work on any collection of elements: either an array, or
// an object of key-value pairs.
























// `_.pick` and `_.omit` are actually object functions, but we put
// them here in order to create a more natural reading order in the
// monolithic build as they depend on `_.contains`.



// Array Functions
// ---------------
// Functions that operate on arrays (and array-likes) only, because they’re
// expressed in terms of operations on an ordered list of values.

















// OOP
// ---
// These modules support the "object-oriented" calling style. See also
// `underscore.js` and `index-default.js`.




/***/ }),

/***/ "./node_modules/underscore/modules/indexBy.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/indexBy.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _group_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_group.js */ "./node_modules/underscore/modules/_group.js");


// Indexes the object's values by a criterion, similar to `_.groupBy`, but for
// when you know that your index values will be unique.
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_group_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(result, value, key) {
  result[key] = value;
}));


/***/ }),

/***/ "./node_modules/underscore/modules/indexOf.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/indexOf.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sortedIndex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sortedIndex.js */ "./node_modules/underscore/modules/sortedIndex.js");
/* harmony import */ var _findIndex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./findIndex.js */ "./node_modules/underscore/modules/findIndex.js");
/* harmony import */ var _createIndexFinder_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_createIndexFinder.js */ "./node_modules/underscore/modules/_createIndexFinder.js");




// Return the position of the first occurrence of an item in an array,
// or -1 if the item is not included in the array.
// If the array is large and already in sort order, pass `true`
// for **isSorted** to use binary search.
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_createIndexFinder_js__WEBPACK_IMPORTED_MODULE_2__["default"])(1, _findIndex_js__WEBPACK_IMPORTED_MODULE_1__["default"], _sortedIndex_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/***/ }),

/***/ "./node_modules/underscore/modules/initial.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/initial.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ initial)
/* harmony export */ });
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");


// Returns everything but the last entry of the array. Especially useful on
// the arguments object. Passing **n** will return all the values in
// the array, excluding the last N.
function initial(array, n, guard) {
  return _setup_js__WEBPACK_IMPORTED_MODULE_0__.slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
}


/***/ }),

/***/ "./node_modules/underscore/modules/intersection.js":
/*!*********************************************************!*\
  !*** ./node_modules/underscore/modules/intersection.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ intersection)
/* harmony export */ });
/* harmony import */ var _getLength_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getLength.js */ "./node_modules/underscore/modules/_getLength.js");
/* harmony import */ var _contains_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./contains.js */ "./node_modules/underscore/modules/contains.js");



// Produce an array that contains every item shared between all the
// passed-in arrays.
function intersection(array) {
  var result = [];
  var argsLength = arguments.length;
  for (var i = 0, length = (0,_getLength_js__WEBPACK_IMPORTED_MODULE_0__["default"])(array); i < length; i++) {
    var item = array[i];
    if ((0,_contains_js__WEBPACK_IMPORTED_MODULE_1__["default"])(result, item)) continue;
    var j;
    for (j = 1; j < argsLength; j++) {
      if (!(0,_contains_js__WEBPACK_IMPORTED_MODULE_1__["default"])(arguments[j], item)) break;
    }
    if (j === argsLength) result.push(item);
  }
  return result;
}


/***/ }),

/***/ "./node_modules/underscore/modules/invert.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/invert.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ invert)
/* harmony export */ });
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./keys.js */ "./node_modules/underscore/modules/keys.js");


// Invert the keys and values of an object. The values must be serializable.
function invert(obj) {
  var result = {};
  var _keys = (0,_keys_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj);
  for (var i = 0, length = _keys.length; i < length; i++) {
    result[obj[_keys[i]]] = _keys[i];
  }
  return result;
}


/***/ }),

/***/ "./node_modules/underscore/modules/invoke.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/invoke.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _restArguments_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./restArguments.js */ "./node_modules/underscore/modules/restArguments.js");
/* harmony import */ var _isFunction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isFunction.js */ "./node_modules/underscore/modules/isFunction.js");
/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./map.js */ "./node_modules/underscore/modules/map.js");
/* harmony import */ var _deepGet_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_deepGet.js */ "./node_modules/underscore/modules/_deepGet.js");
/* harmony import */ var _toPath_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_toPath.js */ "./node_modules/underscore/modules/_toPath.js");






// Invoke a method (with arguments) on every item in a collection.
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_restArguments_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(obj, path, args) {
  var contextPath, func;
  if ((0,_isFunction_js__WEBPACK_IMPORTED_MODULE_1__["default"])(path)) {
    func = path;
  } else {
    path = (0,_toPath_js__WEBPACK_IMPORTED_MODULE_4__["default"])(path);
    contextPath = path.slice(0, -1);
    path = path[path.length - 1];
  }
  return (0,_map_js__WEBPACK_IMPORTED_MODULE_2__["default"])(obj, function(context) {
    var method = func;
    if (!method) {
      if (contextPath && contextPath.length) {
        context = (0,_deepGet_js__WEBPACK_IMPORTED_MODULE_3__["default"])(context, contextPath);
      }
      if (context == null) return void 0;
      method = context[path];
    }
    return method == null ? method : method.apply(context, args);
  });
}));


/***/ }),

/***/ "./node_modules/underscore/modules/isArguments.js":
/*!********************************************************!*\
  !*** ./node_modules/underscore/modules/isArguments.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _tagTester_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_tagTester.js */ "./node_modules/underscore/modules/_tagTester.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_has.js */ "./node_modules/underscore/modules/_has.js");



var isArguments = (0,_tagTester_js__WEBPACK_IMPORTED_MODULE_0__["default"])('Arguments');

// Define a fallback version of the method in browsers (ahem, IE < 9), where
// there isn't any inspectable "Arguments" type.
(function() {
  if (!isArguments(arguments)) {
    isArguments = function(obj) {
      return (0,_has_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj, 'callee');
    };
  }
}());

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isArguments);


/***/ }),

/***/ "./node_modules/underscore/modules/isArray.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/isArray.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");
/* harmony import */ var _tagTester_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_tagTester.js */ "./node_modules/underscore/modules/_tagTester.js");



// Is a given value an array?
// Delegates to ECMA5's native `Array.isArray`.
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_setup_js__WEBPACK_IMPORTED_MODULE_0__.nativeIsArray || (0,_tagTester_js__WEBPACK_IMPORTED_MODULE_1__["default"])('Array'));


/***/ }),

/***/ "./node_modules/underscore/modules/isArrayBuffer.js":
/*!**********************************************************!*\
  !*** ./node_modules/underscore/modules/isArrayBuffer.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _tagTester_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_tagTester.js */ "./node_modules/underscore/modules/_tagTester.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_tagTester_js__WEBPACK_IMPORTED_MODULE_0__["default"])('ArrayBuffer'));


/***/ }),

/***/ "./node_modules/underscore/modules/isBoolean.js":
/*!******************************************************!*\
  !*** ./node_modules/underscore/modules/isBoolean.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isBoolean)
/* harmony export */ });
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");


// Is a given value a boolean?
function isBoolean(obj) {
  return obj === true || obj === false || _setup_js__WEBPACK_IMPORTED_MODULE_0__.toString.call(obj) === '[object Boolean]';
}


/***/ }),

/***/ "./node_modules/underscore/modules/isDataView.js":
/*!*******************************************************!*\
  !*** ./node_modules/underscore/modules/isDataView.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _tagTester_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_tagTester.js */ "./node_modules/underscore/modules/_tagTester.js");
/* harmony import */ var _isFunction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isFunction.js */ "./node_modules/underscore/modules/isFunction.js");
/* harmony import */ var _isArrayBuffer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isArrayBuffer.js */ "./node_modules/underscore/modules/isArrayBuffer.js");
/* harmony import */ var _stringTagBug_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_stringTagBug.js */ "./node_modules/underscore/modules/_stringTagBug.js");





var isDataView = (0,_tagTester_js__WEBPACK_IMPORTED_MODULE_0__["default"])('DataView');

// In IE 10 - Edge 13, we need a different heuristic
// to determine whether an object is a `DataView`.
// Also, in cases where the native `DataView` is
// overridden we can't rely on the tag itself.
function alternateIsDataView(obj) {
  return obj != null && (0,_isFunction_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj.getInt8) && (0,_isArrayBuffer_js__WEBPACK_IMPORTED_MODULE_2__["default"])(obj.buffer);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_stringTagBug_js__WEBPACK_IMPORTED_MODULE_3__.hasDataViewBug ? alternateIsDataView : isDataView);


/***/ }),

/***/ "./node_modules/underscore/modules/isDate.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/isDate.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _tagTester_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_tagTester.js */ "./node_modules/underscore/modules/_tagTester.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_tagTester_js__WEBPACK_IMPORTED_MODULE_0__["default"])('Date'));


/***/ }),

/***/ "./node_modules/underscore/modules/isElement.js":
/*!******************************************************!*\
  !*** ./node_modules/underscore/modules/isElement.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isElement)
/* harmony export */ });
// Is a given value a DOM element?
function isElement(obj) {
  return !!(obj && obj.nodeType === 1);
}


/***/ }),

/***/ "./node_modules/underscore/modules/isEmpty.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/isEmpty.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isEmpty)
/* harmony export */ });
/* harmony import */ var _getLength_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getLength.js */ "./node_modules/underscore/modules/_getLength.js");
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/underscore/modules/isArray.js");
/* harmony import */ var _isString_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isString.js */ "./node_modules/underscore/modules/isString.js");
/* harmony import */ var _isArguments_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isArguments.js */ "./node_modules/underscore/modules/isArguments.js");
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./keys.js */ "./node_modules/underscore/modules/keys.js");






// Is a given array, string, or object empty?
// An "empty" object has no enumerable own-properties.
function isEmpty(obj) {
  if (obj == null) return true;
  // Skip the more expensive `toString`-based type checks if `obj` has no
  // `.length`.
  var length = (0,_getLength_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj);
  if (typeof length == 'number' && (
    (0,_isArray_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj) || (0,_isString_js__WEBPACK_IMPORTED_MODULE_2__["default"])(obj) || (0,_isArguments_js__WEBPACK_IMPORTED_MODULE_3__["default"])(obj)
  )) return length === 0;
  return (0,_getLength_js__WEBPACK_IMPORTED_MODULE_0__["default"])((0,_keys_js__WEBPACK_IMPORTED_MODULE_4__["default"])(obj)) === 0;
}


/***/ }),

/***/ "./node_modules/underscore/modules/isEqual.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/isEqual.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isEqual)
/* harmony export */ });
/* harmony import */ var _underscore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./underscore.js */ "./node_modules/underscore/modules/underscore.js");
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");
/* harmony import */ var _getByteLength_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_getByteLength.js */ "./node_modules/underscore/modules/_getByteLength.js");
/* harmony import */ var _isTypedArray_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isTypedArray.js */ "./node_modules/underscore/modules/isTypedArray.js");
/* harmony import */ var _isFunction_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./isFunction.js */ "./node_modules/underscore/modules/isFunction.js");
/* harmony import */ var _stringTagBug_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_stringTagBug.js */ "./node_modules/underscore/modules/_stringTagBug.js");
/* harmony import */ var _isDataView_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./isDataView.js */ "./node_modules/underscore/modules/isDataView.js");
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./keys.js */ "./node_modules/underscore/modules/keys.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./_has.js */ "./node_modules/underscore/modules/_has.js");
/* harmony import */ var _toBufferView_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./_toBufferView.js */ "./node_modules/underscore/modules/_toBufferView.js");











// We use this string twice, so give it a name for minification.
var tagDataView = '[object DataView]';

// Internal recursive comparison function for `_.isEqual`.
function eq(a, b, aStack, bStack) {
  // Identical objects are equal. `0 === -0`, but they aren't identical.
  // See the [Harmony `egal` proposal](https://wiki.ecmascript.org/doku.php?id=harmony:egal).
  if (a === b) return a !== 0 || 1 / a === 1 / b;
  // `null` or `undefined` only equal to itself (strict comparison).
  if (a == null || b == null) return false;
  // `NaN`s are equivalent, but non-reflexive.
  if (a !== a) return b !== b;
  // Exhaust primitive checks
  var type = typeof a;
  if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;
  return deepEq(a, b, aStack, bStack);
}

// Internal recursive comparison function for `_.isEqual`.
function deepEq(a, b, aStack, bStack) {
  // Unwrap any wrapped objects.
  if (a instanceof _underscore_js__WEBPACK_IMPORTED_MODULE_0__["default"]) a = a._wrapped;
  if (b instanceof _underscore_js__WEBPACK_IMPORTED_MODULE_0__["default"]) b = b._wrapped;
  // Compare `[[Class]]` names.
  var className = _setup_js__WEBPACK_IMPORTED_MODULE_1__.toString.call(a);
  if (className !== _setup_js__WEBPACK_IMPORTED_MODULE_1__.toString.call(b)) return false;
  // Work around a bug in IE 10 - Edge 13.
  if (_stringTagBug_js__WEBPACK_IMPORTED_MODULE_5__.hasDataViewBug && className == '[object Object]' && (0,_isDataView_js__WEBPACK_IMPORTED_MODULE_6__["default"])(a)) {
    if (!(0,_isDataView_js__WEBPACK_IMPORTED_MODULE_6__["default"])(b)) return false;
    className = tagDataView;
  }
  switch (className) {
    // These types are compared by value.
    case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
    case '[object String]':
      // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
      // equivalent to `new String("5")`.
      return '' + a === '' + b;
    case '[object Number]':
      // `NaN`s are equivalent, but non-reflexive.
      // Object(NaN) is equivalent to NaN.
      if (+a !== +a) return +b !== +b;
      // An `egal` comparison is performed for other numeric values.
      return +a === 0 ? 1 / +a === 1 / b : +a === +b;
    case '[object Date]':
    case '[object Boolean]':
      // Coerce dates and booleans to numeric primitive values. Dates are compared by their
      // millisecond representations. Note that invalid dates with millisecond representations
      // of `NaN` are not equivalent.
      return +a === +b;
    case '[object Symbol]':
      return _setup_js__WEBPACK_IMPORTED_MODULE_1__.SymbolProto.valueOf.call(a) === _setup_js__WEBPACK_IMPORTED_MODULE_1__.SymbolProto.valueOf.call(b);
    case '[object ArrayBuffer]':
    case tagDataView:
      // Coerce to typed array so we can fall through.
      return deepEq((0,_toBufferView_js__WEBPACK_IMPORTED_MODULE_9__["default"])(a), (0,_toBufferView_js__WEBPACK_IMPORTED_MODULE_9__["default"])(b), aStack, bStack);
  }

  var areArrays = className === '[object Array]';
  if (!areArrays && (0,_isTypedArray_js__WEBPACK_IMPORTED_MODULE_3__["default"])(a)) {
      var byteLength = (0,_getByteLength_js__WEBPACK_IMPORTED_MODULE_2__["default"])(a);
      if (byteLength !== (0,_getByteLength_js__WEBPACK_IMPORTED_MODULE_2__["default"])(b)) return false;
      if (a.buffer === b.buffer && a.byteOffset === b.byteOffset) return true;
      areArrays = true;
  }
  if (!areArrays) {
    if (typeof a != 'object' || typeof b != 'object') return false;

    // Objects with different constructors are not equivalent, but `Object`s or `Array`s
    // from different frames are.
    var aCtor = a.constructor, bCtor = b.constructor;
    if (aCtor !== bCtor && !((0,_isFunction_js__WEBPACK_IMPORTED_MODULE_4__["default"])(aCtor) && aCtor instanceof aCtor &&
                             (0,_isFunction_js__WEBPACK_IMPORTED_MODULE_4__["default"])(bCtor) && bCtor instanceof bCtor)
                        && ('constructor' in a && 'constructor' in b)) {
      return false;
    }
  }
  // Assume equality for cyclic structures. The algorithm for detecting cyclic
  // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

  // Initializing stack of traversed objects.
  // It's done here since we only need them for objects and arrays comparison.
  aStack = aStack || [];
  bStack = bStack || [];
  var length = aStack.length;
  while (length--) {
    // Linear search. Performance is inversely proportional to the number of
    // unique nested structures.
    if (aStack[length] === a) return bStack[length] === b;
  }

  // Add the first object to the stack of traversed objects.
  aStack.push(a);
  bStack.push(b);

  // Recursively compare objects and arrays.
  if (areArrays) {
    // Compare array lengths to determine if a deep comparison is necessary.
    length = a.length;
    if (length !== b.length) return false;
    // Deep compare the contents, ignoring non-numeric properties.
    while (length--) {
      if (!eq(a[length], b[length], aStack, bStack)) return false;
    }
  } else {
    // Deep compare objects.
    var _keys = (0,_keys_js__WEBPACK_IMPORTED_MODULE_7__["default"])(a), key;
    length = _keys.length;
    // Ensure that both objects contain the same number of properties before comparing deep equality.
    if ((0,_keys_js__WEBPACK_IMPORTED_MODULE_7__["default"])(b).length !== length) return false;
    while (length--) {
      // Deep compare each member
      key = _keys[length];
      if (!((0,_has_js__WEBPACK_IMPORTED_MODULE_8__["default"])(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
    }
  }
  // Remove the first object from the stack of traversed objects.
  aStack.pop();
  bStack.pop();
  return true;
}

// Perform a deep comparison to check if two objects are equal.
function isEqual(a, b) {
  return eq(a, b);
}


/***/ }),

/***/ "./node_modules/underscore/modules/isError.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/isError.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _tagTester_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_tagTester.js */ "./node_modules/underscore/modules/_tagTester.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_tagTester_js__WEBPACK_IMPORTED_MODULE_0__["default"])('Error'));


/***/ }),

/***/ "./node_modules/underscore/modules/isFinite.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/isFinite.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isFinite)
/* harmony export */ });
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");
/* harmony import */ var _isSymbol_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isSymbol.js */ "./node_modules/underscore/modules/isSymbol.js");



// Is a given object a finite number?
function isFinite(obj) {
  return !(0,_isSymbol_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj) && (0,_setup_js__WEBPACK_IMPORTED_MODULE_0__._isFinite)(obj) && !isNaN(parseFloat(obj));
}


/***/ }),

/***/ "./node_modules/underscore/modules/isFunction.js":
/*!*******************************************************!*\
  !*** ./node_modules/underscore/modules/isFunction.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _tagTester_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_tagTester.js */ "./node_modules/underscore/modules/_tagTester.js");
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");



var isFunction = (0,_tagTester_js__WEBPACK_IMPORTED_MODULE_0__["default"])('Function');

// Optimize `isFunction` if appropriate. Work around some `typeof` bugs in old
// v8, IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).
var nodelist = _setup_js__WEBPACK_IMPORTED_MODULE_1__.root.document && _setup_js__WEBPACK_IMPORTED_MODULE_1__.root.document.childNodes;
if ( true && typeof Int8Array != 'object' && typeof nodelist != 'function') {
  isFunction = function(obj) {
    return typeof obj == 'function' || false;
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isFunction);


/***/ }),

/***/ "./node_modules/underscore/modules/isMap.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/isMap.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _tagTester_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_tagTester.js */ "./node_modules/underscore/modules/_tagTester.js");
/* harmony import */ var _stringTagBug_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_stringTagBug.js */ "./node_modules/underscore/modules/_stringTagBug.js");
/* harmony import */ var _methodFingerprint_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_methodFingerprint.js */ "./node_modules/underscore/modules/_methodFingerprint.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_stringTagBug_js__WEBPACK_IMPORTED_MODULE_1__.isIE11 ? (0,_methodFingerprint_js__WEBPACK_IMPORTED_MODULE_2__.ie11fingerprint)(_methodFingerprint_js__WEBPACK_IMPORTED_MODULE_2__.mapMethods) : (0,_tagTester_js__WEBPACK_IMPORTED_MODULE_0__["default"])('Map'));


/***/ }),

/***/ "./node_modules/underscore/modules/isMatch.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/isMatch.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isMatch)
/* harmony export */ });
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./keys.js */ "./node_modules/underscore/modules/keys.js");


// Returns whether an object has a given set of `key:value` pairs.
function isMatch(object, attrs) {
  var _keys = (0,_keys_js__WEBPACK_IMPORTED_MODULE_0__["default"])(attrs), length = _keys.length;
  if (object == null) return !length;
  var obj = Object(object);
  for (var i = 0; i < length; i++) {
    var key = _keys[i];
    if (attrs[key] !== obj[key] || !(key in obj)) return false;
  }
  return true;
}


/***/ }),

/***/ "./node_modules/underscore/modules/isNaN.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/isNaN.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isNaN)
/* harmony export */ });
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");
/* harmony import */ var _isNumber_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isNumber.js */ "./node_modules/underscore/modules/isNumber.js");



// Is the given value `NaN`?
function isNaN(obj) {
  return (0,_isNumber_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj) && (0,_setup_js__WEBPACK_IMPORTED_MODULE_0__._isNaN)(obj);
}


/***/ }),

/***/ "./node_modules/underscore/modules/isNull.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/isNull.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isNull)
/* harmony export */ });
// Is a given value equal to null?
function isNull(obj) {
  return obj === null;
}


/***/ }),

/***/ "./node_modules/underscore/modules/isNumber.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/isNumber.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _tagTester_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_tagTester.js */ "./node_modules/underscore/modules/_tagTester.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_tagTester_js__WEBPACK_IMPORTED_MODULE_0__["default"])('Number'));


/***/ }),

/***/ "./node_modules/underscore/modules/isObject.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/isObject.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isObject)
/* harmony export */ });
// Is a given variable an object?
function isObject(obj) {
  var type = typeof obj;
  return type === 'function' || (type === 'object' && !!obj);
}


/***/ }),

/***/ "./node_modules/underscore/modules/isRegExp.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/isRegExp.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _tagTester_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_tagTester.js */ "./node_modules/underscore/modules/_tagTester.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_tagTester_js__WEBPACK_IMPORTED_MODULE_0__["default"])('RegExp'));


/***/ }),

/***/ "./node_modules/underscore/modules/isSet.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/isSet.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _tagTester_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_tagTester.js */ "./node_modules/underscore/modules/_tagTester.js");
/* harmony import */ var _stringTagBug_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_stringTagBug.js */ "./node_modules/underscore/modules/_stringTagBug.js");
/* harmony import */ var _methodFingerprint_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_methodFingerprint.js */ "./node_modules/underscore/modules/_methodFingerprint.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_stringTagBug_js__WEBPACK_IMPORTED_MODULE_1__.isIE11 ? (0,_methodFingerprint_js__WEBPACK_IMPORTED_MODULE_2__.ie11fingerprint)(_methodFingerprint_js__WEBPACK_IMPORTED_MODULE_2__.setMethods) : (0,_tagTester_js__WEBPACK_IMPORTED_MODULE_0__["default"])('Set'));


/***/ }),

/***/ "./node_modules/underscore/modules/isString.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/isString.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _tagTester_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_tagTester.js */ "./node_modules/underscore/modules/_tagTester.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_tagTester_js__WEBPACK_IMPORTED_MODULE_0__["default"])('String'));


/***/ }),

/***/ "./node_modules/underscore/modules/isSymbol.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/isSymbol.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _tagTester_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_tagTester.js */ "./node_modules/underscore/modules/_tagTester.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_tagTester_js__WEBPACK_IMPORTED_MODULE_0__["default"])('Symbol'));


/***/ }),

/***/ "./node_modules/underscore/modules/isTypedArray.js":
/*!*********************************************************!*\
  !*** ./node_modules/underscore/modules/isTypedArray.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");
/* harmony import */ var _isDataView_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isDataView.js */ "./node_modules/underscore/modules/isDataView.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constant.js */ "./node_modules/underscore/modules/constant.js");
/* harmony import */ var _isBufferLike_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_isBufferLike.js */ "./node_modules/underscore/modules/_isBufferLike.js");





// Is a given value a typed array?
var typedArrayPattern = /\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\]/;
function isTypedArray(obj) {
  // `ArrayBuffer.isView` is the most future-proof, so use it when available.
  // Otherwise, fall back on the above regular expression.
  return _setup_js__WEBPACK_IMPORTED_MODULE_0__.nativeIsView ? ((0,_setup_js__WEBPACK_IMPORTED_MODULE_0__.nativeIsView)(obj) && !(0,_isDataView_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj)) :
                (0,_isBufferLike_js__WEBPACK_IMPORTED_MODULE_3__["default"])(obj) && typedArrayPattern.test(_setup_js__WEBPACK_IMPORTED_MODULE_0__.toString.call(obj));
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_setup_js__WEBPACK_IMPORTED_MODULE_0__.supportsArrayBuffer ? isTypedArray : (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(false));


/***/ }),

/***/ "./node_modules/underscore/modules/isUndefined.js":
/*!********************************************************!*\
  !*** ./node_modules/underscore/modules/isUndefined.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isUndefined)
/* harmony export */ });
// Is a given variable undefined?
function isUndefined(obj) {
  return obj === void 0;
}


/***/ }),

/***/ "./node_modules/underscore/modules/isWeakMap.js":
/*!******************************************************!*\
  !*** ./node_modules/underscore/modules/isWeakMap.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _tagTester_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_tagTester.js */ "./node_modules/underscore/modules/_tagTester.js");
/* harmony import */ var _stringTagBug_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_stringTagBug.js */ "./node_modules/underscore/modules/_stringTagBug.js");
/* harmony import */ var _methodFingerprint_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_methodFingerprint.js */ "./node_modules/underscore/modules/_methodFingerprint.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_stringTagBug_js__WEBPACK_IMPORTED_MODULE_1__.isIE11 ? (0,_methodFingerprint_js__WEBPACK_IMPORTED_MODULE_2__.ie11fingerprint)(_methodFingerprint_js__WEBPACK_IMPORTED_MODULE_2__.weakMapMethods) : (0,_tagTester_js__WEBPACK_IMPORTED_MODULE_0__["default"])('WeakMap'));


/***/ }),

/***/ "./node_modules/underscore/modules/isWeakSet.js":
/*!******************************************************!*\
  !*** ./node_modules/underscore/modules/isWeakSet.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _tagTester_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_tagTester.js */ "./node_modules/underscore/modules/_tagTester.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_tagTester_js__WEBPACK_IMPORTED_MODULE_0__["default"])('WeakSet'));


/***/ }),

/***/ "./node_modules/underscore/modules/iteratee.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/iteratee.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ iteratee)
/* harmony export */ });
/* harmony import */ var _underscore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./underscore.js */ "./node_modules/underscore/modules/underscore.js");
/* harmony import */ var _baseIteratee_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseIteratee.js */ "./node_modules/underscore/modules/_baseIteratee.js");



// External wrapper for our callback generator. Users may customize
// `_.iteratee` if they want additional predicate/iteratee shorthand styles.
// This abstraction hides the internal-only `argCount` argument.
function iteratee(value, context) {
  return (0,_baseIteratee_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value, context, Infinity);
}
_underscore_js__WEBPACK_IMPORTED_MODULE_0__["default"].iteratee = iteratee;


/***/ }),

/***/ "./node_modules/underscore/modules/keys.js":
/*!*************************************************!*\
  !*** ./node_modules/underscore/modules/keys.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ keys)
/* harmony export */ });
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObject.js */ "./node_modules/underscore/modules/isObject.js");
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_has.js */ "./node_modules/underscore/modules/_has.js");
/* harmony import */ var _collectNonEnumProps_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_collectNonEnumProps.js */ "./node_modules/underscore/modules/_collectNonEnumProps.js");





// Retrieve the names of an object's own properties.
// Delegates to **ECMAScript 5**'s native `Object.keys`.
function keys(obj) {
  if (!(0,_isObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj)) return [];
  if (_setup_js__WEBPACK_IMPORTED_MODULE_1__.nativeKeys) return (0,_setup_js__WEBPACK_IMPORTED_MODULE_1__.nativeKeys)(obj);
  var keys = [];
  for (var key in obj) if ((0,_has_js__WEBPACK_IMPORTED_MODULE_2__["default"])(obj, key)) keys.push(key);
  // Ahem, IE < 9.
  if (_setup_js__WEBPACK_IMPORTED_MODULE_1__.hasEnumBug) (0,_collectNonEnumProps_js__WEBPACK_IMPORTED_MODULE_3__["default"])(obj, keys);
  return keys;
}


/***/ }),

/***/ "./node_modules/underscore/modules/last.js":
/*!*************************************************!*\
  !*** ./node_modules/underscore/modules/last.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ last)
/* harmony export */ });
/* harmony import */ var _rest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rest.js */ "./node_modules/underscore/modules/rest.js");


// Get the last element of an array. Passing **n** will return the last N
// values in the array.
function last(array, n, guard) {
  if (array == null || array.length < 1) return n == null || guard ? void 0 : [];
  if (n == null || guard) return array[array.length - 1];
  return (0,_rest_js__WEBPACK_IMPORTED_MODULE_0__["default"])(array, Math.max(0, array.length - n));
}


/***/ }),

/***/ "./node_modules/underscore/modules/lastIndexOf.js":
/*!********************************************************!*\
  !*** ./node_modules/underscore/modules/lastIndexOf.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _findLastIndex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./findLastIndex.js */ "./node_modules/underscore/modules/findLastIndex.js");
/* harmony import */ var _createIndexFinder_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_createIndexFinder.js */ "./node_modules/underscore/modules/_createIndexFinder.js");



// Return the position of the last occurrence of an item in an array,
// or -1 if the item is not included in the array.
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_createIndexFinder_js__WEBPACK_IMPORTED_MODULE_1__["default"])(-1, _findLastIndex_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/***/ }),

/***/ "./node_modules/underscore/modules/map.js":
/*!************************************************!*\
  !*** ./node_modules/underscore/modules/map.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ map)
/* harmony export */ });
/* harmony import */ var _cb_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_cb.js */ "./node_modules/underscore/modules/_cb.js");
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_isArrayLike.js */ "./node_modules/underscore/modules/_isArrayLike.js");
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./keys.js */ "./node_modules/underscore/modules/keys.js");




// Return the results of applying the iteratee to each element.
function map(obj, iteratee, context) {
  iteratee = (0,_cb_js__WEBPACK_IMPORTED_MODULE_0__["default"])(iteratee, context);
  var _keys = !(0,_isArrayLike_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj) && (0,_keys_js__WEBPACK_IMPORTED_MODULE_2__["default"])(obj),
      length = (_keys || obj).length,
      results = Array(length);
  for (var index = 0; index < length; index++) {
    var currentKey = _keys ? _keys[index] : index;
    results[index] = iteratee(obj[currentKey], currentKey, obj);
  }
  return results;
}


/***/ }),

/***/ "./node_modules/underscore/modules/mapObject.js":
/*!******************************************************!*\
  !*** ./node_modules/underscore/modules/mapObject.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ mapObject)
/* harmony export */ });
/* harmony import */ var _cb_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_cb.js */ "./node_modules/underscore/modules/_cb.js");
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keys.js */ "./node_modules/underscore/modules/keys.js");



// Returns the results of applying the `iteratee` to each element of `obj`.
// In contrast to `_.map` it returns an object.
function mapObject(obj, iteratee, context) {
  iteratee = (0,_cb_js__WEBPACK_IMPORTED_MODULE_0__["default"])(iteratee, context);
  var _keys = (0,_keys_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj),
      length = _keys.length,
      results = {};
  for (var index = 0; index < length; index++) {
    var currentKey = _keys[index];
    results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
  }
  return results;
}


/***/ }),

/***/ "./node_modules/underscore/modules/matcher.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/matcher.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ matcher)
/* harmony export */ });
/* harmony import */ var _extendOwn_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./extendOwn.js */ "./node_modules/underscore/modules/extendOwn.js");
/* harmony import */ var _isMatch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isMatch.js */ "./node_modules/underscore/modules/isMatch.js");



// Returns a predicate for checking whether an object has a given set of
// `key:value` pairs.
function matcher(attrs) {
  attrs = (0,_extendOwn_js__WEBPACK_IMPORTED_MODULE_0__["default"])({}, attrs);
  return function(obj) {
    return (0,_isMatch_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj, attrs);
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/max.js":
/*!************************************************!*\
  !*** ./node_modules/underscore/modules/max.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ max)
/* harmony export */ });
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_isArrayLike.js */ "./node_modules/underscore/modules/_isArrayLike.js");
/* harmony import */ var _values_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./values.js */ "./node_modules/underscore/modules/values.js");
/* harmony import */ var _cb_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_cb.js */ "./node_modules/underscore/modules/_cb.js");
/* harmony import */ var _each_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./each.js */ "./node_modules/underscore/modules/each.js");





// Return the maximum element (or element-based computation).
function max(obj, iteratee, context) {
  var result = -Infinity, lastComputed = -Infinity,
      value, computed;
  if (iteratee == null || (typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null)) {
    obj = (0,_isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj) ? obj : (0,_values_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj);
    for (var i = 0, length = obj.length; i < length; i++) {
      value = obj[i];
      if (value != null && value > result) {
        result = value;
      }
    }
  } else {
    iteratee = (0,_cb_js__WEBPACK_IMPORTED_MODULE_2__["default"])(iteratee, context);
    (0,_each_js__WEBPACK_IMPORTED_MODULE_3__["default"])(obj, function(v, index, list) {
      computed = iteratee(v, index, list);
      if (computed > lastComputed || (computed === -Infinity && result === -Infinity)) {
        result = v;
        lastComputed = computed;
      }
    });
  }
  return result;
}


/***/ }),

/***/ "./node_modules/underscore/modules/memoize.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/memoize.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ memoize)
/* harmony export */ });
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_has.js */ "./node_modules/underscore/modules/_has.js");


// Memoize an expensive function by storing its results.
function memoize(func, hasher) {
  var memoize = function(key) {
    var cache = memoize.cache;
    var address = '' + (hasher ? hasher.apply(this, arguments) : key);
    if (!(0,_has_js__WEBPACK_IMPORTED_MODULE_0__["default"])(cache, address)) cache[address] = func.apply(this, arguments);
    return cache[address];
  };
  memoize.cache = {};
  return memoize;
}


/***/ }),

/***/ "./node_modules/underscore/modules/min.js":
/*!************************************************!*\
  !*** ./node_modules/underscore/modules/min.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ min)
/* harmony export */ });
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_isArrayLike.js */ "./node_modules/underscore/modules/_isArrayLike.js");
/* harmony import */ var _values_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./values.js */ "./node_modules/underscore/modules/values.js");
/* harmony import */ var _cb_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_cb.js */ "./node_modules/underscore/modules/_cb.js");
/* harmony import */ var _each_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./each.js */ "./node_modules/underscore/modules/each.js");





// Return the minimum element (or element-based computation).
function min(obj, iteratee, context) {
  var result = Infinity, lastComputed = Infinity,
      value, computed;
  if (iteratee == null || (typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null)) {
    obj = (0,_isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj) ? obj : (0,_values_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj);
    for (var i = 0, length = obj.length; i < length; i++) {
      value = obj[i];
      if (value != null && value < result) {
        result = value;
      }
    }
  } else {
    iteratee = (0,_cb_js__WEBPACK_IMPORTED_MODULE_2__["default"])(iteratee, context);
    (0,_each_js__WEBPACK_IMPORTED_MODULE_3__["default"])(obj, function(v, index, list) {
      computed = iteratee(v, index, list);
      if (computed < lastComputed || (computed === Infinity && result === Infinity)) {
        result = v;
        lastComputed = computed;
      }
    });
  }
  return result;
}


/***/ }),

/***/ "./node_modules/underscore/modules/mixin.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/mixin.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ mixin)
/* harmony export */ });
/* harmony import */ var _underscore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./underscore.js */ "./node_modules/underscore/modules/underscore.js");
/* harmony import */ var _each_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./each.js */ "./node_modules/underscore/modules/each.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./functions.js */ "./node_modules/underscore/modules/functions.js");
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");
/* harmony import */ var _chainResult_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_chainResult.js */ "./node_modules/underscore/modules/_chainResult.js");






// Add your own custom functions to the Underscore object.
function mixin(obj) {
  (0,_each_js__WEBPACK_IMPORTED_MODULE_1__["default"])((0,_functions_js__WEBPACK_IMPORTED_MODULE_2__["default"])(obj), function(name) {
    var func = _underscore_js__WEBPACK_IMPORTED_MODULE_0__["default"][name] = obj[name];
    _underscore_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype[name] = function() {
      var args = [this._wrapped];
      _setup_js__WEBPACK_IMPORTED_MODULE_3__.push.apply(args, arguments);
      return (0,_chainResult_js__WEBPACK_IMPORTED_MODULE_4__["default"])(this, func.apply(_underscore_js__WEBPACK_IMPORTED_MODULE_0__["default"], args));
    };
  });
  return _underscore_js__WEBPACK_IMPORTED_MODULE_0__["default"];
}


/***/ }),

/***/ "./node_modules/underscore/modules/negate.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/negate.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ negate)
/* harmony export */ });
// Returns a negated version of the passed-in predicate.
function negate(predicate) {
  return function() {
    return !predicate.apply(this, arguments);
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/noop.js":
/*!*************************************************!*\
  !*** ./node_modules/underscore/modules/noop.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ noop)
/* harmony export */ });
// Predicate-generating function. Often useful outside of Underscore.
function noop(){}


/***/ }),

/***/ "./node_modules/underscore/modules/now.js":
/*!************************************************!*\
  !*** ./node_modules/underscore/modules/now.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// A (possibly faster) way to get the current timestamp as an integer.
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Date.now || function() {
  return new Date().getTime();
});


/***/ }),

/***/ "./node_modules/underscore/modules/object.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/object.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ object)
/* harmony export */ });
/* harmony import */ var _getLength_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getLength.js */ "./node_modules/underscore/modules/_getLength.js");


// Converts lists into objects. Pass either a single array of `[key, value]`
// pairs, or two parallel arrays of the same length -- one of keys, and one of
// the corresponding values. Passing by pairs is the reverse of `_.pairs`.
function object(list, values) {
  var result = {};
  for (var i = 0, length = (0,_getLength_js__WEBPACK_IMPORTED_MODULE_0__["default"])(list); i < length; i++) {
    if (values) {
      result[list[i]] = values[i];
    } else {
      result[list[i][0]] = list[i][1];
    }
  }
  return result;
}


/***/ }),

/***/ "./node_modules/underscore/modules/omit.js":
/*!*************************************************!*\
  !*** ./node_modules/underscore/modules/omit.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _restArguments_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./restArguments.js */ "./node_modules/underscore/modules/restArguments.js");
/* harmony import */ var _isFunction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isFunction.js */ "./node_modules/underscore/modules/isFunction.js");
/* harmony import */ var _negate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./negate.js */ "./node_modules/underscore/modules/negate.js");
/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./map.js */ "./node_modules/underscore/modules/map.js");
/* harmony import */ var _flatten_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_flatten.js */ "./node_modules/underscore/modules/_flatten.js");
/* harmony import */ var _contains_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./contains.js */ "./node_modules/underscore/modules/contains.js");
/* harmony import */ var _pick_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./pick.js */ "./node_modules/underscore/modules/pick.js");








// Return a copy of the object without the disallowed properties.
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_restArguments_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(obj, keys) {
  var iteratee = keys[0], context;
  if ((0,_isFunction_js__WEBPACK_IMPORTED_MODULE_1__["default"])(iteratee)) {
    iteratee = (0,_negate_js__WEBPACK_IMPORTED_MODULE_2__["default"])(iteratee);
    if (keys.length > 1) context = keys[1];
  } else {
    keys = (0,_map_js__WEBPACK_IMPORTED_MODULE_3__["default"])((0,_flatten_js__WEBPACK_IMPORTED_MODULE_4__["default"])(keys, false, false), String);
    iteratee = function(value, key) {
      return !(0,_contains_js__WEBPACK_IMPORTED_MODULE_5__["default"])(keys, key);
    };
  }
  return (0,_pick_js__WEBPACK_IMPORTED_MODULE_6__["default"])(obj, iteratee, context);
}));


/***/ }),

/***/ "./node_modules/underscore/modules/once.js":
/*!*************************************************!*\
  !*** ./node_modules/underscore/modules/once.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _partial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./partial.js */ "./node_modules/underscore/modules/partial.js");
/* harmony import */ var _before_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./before.js */ "./node_modules/underscore/modules/before.js");



// Returns a function that will be executed at most one time, no matter how
// often you call it. Useful for lazy initialization.
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_partial_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_before_js__WEBPACK_IMPORTED_MODULE_1__["default"], 2));


/***/ }),

/***/ "./node_modules/underscore/modules/pairs.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/pairs.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ pairs)
/* harmony export */ });
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./keys.js */ "./node_modules/underscore/modules/keys.js");


// Convert an object into a list of `[key, value]` pairs.
// The opposite of `_.object` with one argument.
function pairs(obj) {
  var _keys = (0,_keys_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj);
  var length = _keys.length;
  var pairs = Array(length);
  for (var i = 0; i < length; i++) {
    pairs[i] = [_keys[i], obj[_keys[i]]];
  }
  return pairs;
}


/***/ }),

/***/ "./node_modules/underscore/modules/partial.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/partial.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _restArguments_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./restArguments.js */ "./node_modules/underscore/modules/restArguments.js");
/* harmony import */ var _executeBound_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_executeBound.js */ "./node_modules/underscore/modules/_executeBound.js");
/* harmony import */ var _underscore_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./underscore.js */ "./node_modules/underscore/modules/underscore.js");




// Partially apply a function by creating a version that has had some of its
// arguments pre-filled, without changing its dynamic `this` context. `_` acts
// as a placeholder by default, allowing any combination of arguments to be
// pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.
var partial = (0,_restArguments_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(func, boundArgs) {
  var placeholder = partial.placeholder;
  var bound = function() {
    var position = 0, length = boundArgs.length;
    var args = Array(length);
    for (var i = 0; i < length; i++) {
      args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
    }
    while (position < arguments.length) args.push(arguments[position++]);
    return (0,_executeBound_js__WEBPACK_IMPORTED_MODULE_1__["default"])(func, bound, this, this, args);
  };
  return bound;
});

partial.placeholder = _underscore_js__WEBPACK_IMPORTED_MODULE_2__["default"];
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (partial);


/***/ }),

/***/ "./node_modules/underscore/modules/partition.js":
/*!******************************************************!*\
  !*** ./node_modules/underscore/modules/partition.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _group_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_group.js */ "./node_modules/underscore/modules/_group.js");


// Split a collection into two arrays: one whose elements all pass the given
// truth test, and one whose elements all do not pass the truth test.
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_group_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(result, value, pass) {
  result[pass ? 0 : 1].push(value);
}, true));


/***/ }),

/***/ "./node_modules/underscore/modules/pick.js":
/*!*************************************************!*\
  !*** ./node_modules/underscore/modules/pick.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _restArguments_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./restArguments.js */ "./node_modules/underscore/modules/restArguments.js");
/* harmony import */ var _isFunction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isFunction.js */ "./node_modules/underscore/modules/isFunction.js");
/* harmony import */ var _optimizeCb_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_optimizeCb.js */ "./node_modules/underscore/modules/_optimizeCb.js");
/* harmony import */ var _allKeys_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./allKeys.js */ "./node_modules/underscore/modules/allKeys.js");
/* harmony import */ var _keyInObj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_keyInObj.js */ "./node_modules/underscore/modules/_keyInObj.js");
/* harmony import */ var _flatten_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_flatten.js */ "./node_modules/underscore/modules/_flatten.js");







// Return a copy of the object only containing the allowed properties.
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_restArguments_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(obj, keys) {
  var result = {}, iteratee = keys[0];
  if (obj == null) return result;
  if ((0,_isFunction_js__WEBPACK_IMPORTED_MODULE_1__["default"])(iteratee)) {
    if (keys.length > 1) iteratee = (0,_optimizeCb_js__WEBPACK_IMPORTED_MODULE_2__["default"])(iteratee, keys[1]);
    keys = (0,_allKeys_js__WEBPACK_IMPORTED_MODULE_3__["default"])(obj);
  } else {
    iteratee = _keyInObj_js__WEBPACK_IMPORTED_MODULE_4__["default"];
    keys = (0,_flatten_js__WEBPACK_IMPORTED_MODULE_5__["default"])(keys, false, false);
    obj = Object(obj);
  }
  for (var i = 0, length = keys.length; i < length; i++) {
    var key = keys[i];
    var value = obj[key];
    if (iteratee(value, key, obj)) result[key] = value;
  }
  return result;
}));


/***/ }),

/***/ "./node_modules/underscore/modules/pluck.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/pluck.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ pluck)
/* harmony export */ });
/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./map.js */ "./node_modules/underscore/modules/map.js");
/* harmony import */ var _property_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./property.js */ "./node_modules/underscore/modules/property.js");



// Convenience version of a common use case of `_.map`: fetching a property.
function pluck(obj, key) {
  return (0,_map_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj, (0,_property_js__WEBPACK_IMPORTED_MODULE_1__["default"])(key));
}


/***/ }),

/***/ "./node_modules/underscore/modules/property.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/property.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ property)
/* harmony export */ });
/* harmony import */ var _deepGet_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_deepGet.js */ "./node_modules/underscore/modules/_deepGet.js");
/* harmony import */ var _toPath_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_toPath.js */ "./node_modules/underscore/modules/_toPath.js");



// Creates a function that, when passed an object, will traverse that object’s
// properties down the given `path`, specified as an array of keys or indices.
function property(path) {
  path = (0,_toPath_js__WEBPACK_IMPORTED_MODULE_1__["default"])(path);
  return function(obj) {
    return (0,_deepGet_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj, path);
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/propertyOf.js":
/*!*******************************************************!*\
  !*** ./node_modules/underscore/modules/propertyOf.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ propertyOf)
/* harmony export */ });
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./noop.js */ "./node_modules/underscore/modules/noop.js");
/* harmony import */ var _get_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get.js */ "./node_modules/underscore/modules/get.js");



// Generates a function for a given object that returns a given property.
function propertyOf(obj) {
  if (obj == null) return _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"];
  return function(path) {
    return (0,_get_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj, path);
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/random.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/random.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ random)
/* harmony export */ });
// Return a random integer between `min` and `max` (inclusive).
function random(min, max) {
  if (max == null) {
    max = min;
    min = 0;
  }
  return min + Math.floor(Math.random() * (max - min + 1));
}


/***/ }),

/***/ "./node_modules/underscore/modules/range.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/range.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ range)
/* harmony export */ });
// Generate an integer Array containing an arithmetic progression. A port of
// the native Python `range()` function. See
// [the Python documentation](https://docs.python.org/library/functions.html#range).
function range(start, stop, step) {
  if (stop == null) {
    stop = start || 0;
    start = 0;
  }
  if (!step) {
    step = stop < start ? -1 : 1;
  }

  var length = Math.max(Math.ceil((stop - start) / step), 0);
  var range = Array(length);

  for (var idx = 0; idx < length; idx++, start += step) {
    range[idx] = start;
  }

  return range;
}


/***/ }),

/***/ "./node_modules/underscore/modules/reduce.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/reduce.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _createReduce_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createReduce.js */ "./node_modules/underscore/modules/_createReduce.js");


// **Reduce** builds up a single result from a list of values, aka `inject`,
// or `foldl`.
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_createReduce_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1));


/***/ }),

/***/ "./node_modules/underscore/modules/reduceRight.js":
/*!********************************************************!*\
  !*** ./node_modules/underscore/modules/reduceRight.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _createReduce_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createReduce.js */ "./node_modules/underscore/modules/_createReduce.js");


// The right-associative version of reduce, also known as `foldr`.
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_createReduce_js__WEBPACK_IMPORTED_MODULE_0__["default"])(-1));


/***/ }),

/***/ "./node_modules/underscore/modules/reject.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/reject.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ reject)
/* harmony export */ });
/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./filter.js */ "./node_modules/underscore/modules/filter.js");
/* harmony import */ var _negate_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./negate.js */ "./node_modules/underscore/modules/negate.js");
/* harmony import */ var _cb_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_cb.js */ "./node_modules/underscore/modules/_cb.js");




// Return all the elements for which a truth test fails.
function reject(obj, predicate, context) {
  return (0,_filter_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj, (0,_negate_js__WEBPACK_IMPORTED_MODULE_1__["default"])((0,_cb_js__WEBPACK_IMPORTED_MODULE_2__["default"])(predicate)), context);
}


/***/ }),

/***/ "./node_modules/underscore/modules/rest.js":
/*!*************************************************!*\
  !*** ./node_modules/underscore/modules/rest.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ rest)
/* harmony export */ });
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");


// Returns everything but the first entry of the `array`. Especially useful on
// the `arguments` object. Passing an **n** will return the rest N values in the
// `array`.
function rest(array, n, guard) {
  return _setup_js__WEBPACK_IMPORTED_MODULE_0__.slice.call(array, n == null || guard ? 1 : n);
}


/***/ }),

/***/ "./node_modules/underscore/modules/restArguments.js":
/*!**********************************************************!*\
  !*** ./node_modules/underscore/modules/restArguments.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ restArguments)
/* harmony export */ });
// Some functions take a variable number of arguments, or a few expected
// arguments at the beginning and then a variable number of values to operate
// on. This helper accumulates all remaining arguments past the function’s
// argument length (or an explicit `startIndex`), into an array that becomes
// the last argument. Similar to ES6’s "rest parameter".
function restArguments(func, startIndex) {
  startIndex = startIndex == null ? func.length - 1 : +startIndex;
  return function() {
    var length = Math.max(arguments.length - startIndex, 0),
        rest = Array(length),
        index = 0;
    for (; index < length; index++) {
      rest[index] = arguments[index + startIndex];
    }
    switch (startIndex) {
      case 0: return func.call(this, rest);
      case 1: return func.call(this, arguments[0], rest);
      case 2: return func.call(this, arguments[0], arguments[1], rest);
    }
    var args = Array(startIndex + 1);
    for (index = 0; index < startIndex; index++) {
      args[index] = arguments[index];
    }
    args[startIndex] = rest;
    return func.apply(this, args);
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/result.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/result.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ result)
/* harmony export */ });
/* harmony import */ var _isFunction_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isFunction.js */ "./node_modules/underscore/modules/isFunction.js");
/* harmony import */ var _toPath_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_toPath.js */ "./node_modules/underscore/modules/_toPath.js");



// Traverses the children of `obj` along `path`. If a child is a function, it
// is invoked with its parent as context. Returns the value of the final
// child, or `fallback` if any child is undefined.
function result(obj, path, fallback) {
  path = (0,_toPath_js__WEBPACK_IMPORTED_MODULE_1__["default"])(path);
  var length = path.length;
  if (!length) {
    return (0,_isFunction_js__WEBPACK_IMPORTED_MODULE_0__["default"])(fallback) ? fallback.call(obj) : fallback;
  }
  for (var i = 0; i < length; i++) {
    var prop = obj == null ? void 0 : obj[path[i]];
    if (prop === void 0) {
      prop = fallback;
      i = length; // Ensure we don't continue iterating.
    }
    obj = (0,_isFunction_js__WEBPACK_IMPORTED_MODULE_0__["default"])(prop) ? prop.call(obj) : prop;
  }
  return obj;
}


/***/ }),

/***/ "./node_modules/underscore/modules/sample.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/sample.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ sample)
/* harmony export */ });
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_isArrayLike.js */ "./node_modules/underscore/modules/_isArrayLike.js");
/* harmony import */ var _values_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./values.js */ "./node_modules/underscore/modules/values.js");
/* harmony import */ var _getLength_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_getLength.js */ "./node_modules/underscore/modules/_getLength.js");
/* harmony import */ var _random_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./random.js */ "./node_modules/underscore/modules/random.js");
/* harmony import */ var _toArray_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./toArray.js */ "./node_modules/underscore/modules/toArray.js");






// Sample **n** random values from a collection using the modern version of the
// [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
// If **n** is not specified, returns a single random element.
// The internal `guard` argument allows it to work with `_.map`.
function sample(obj, n, guard) {
  if (n == null || guard) {
    if (!(0,_isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj)) obj = (0,_values_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj);
    return obj[(0,_random_js__WEBPACK_IMPORTED_MODULE_3__["default"])(obj.length - 1)];
  }
  var sample = (0,_toArray_js__WEBPACK_IMPORTED_MODULE_4__["default"])(obj);
  var length = (0,_getLength_js__WEBPACK_IMPORTED_MODULE_2__["default"])(sample);
  n = Math.max(Math.min(n, length), 0);
  var last = length - 1;
  for (var index = 0; index < n; index++) {
    var rand = (0,_random_js__WEBPACK_IMPORTED_MODULE_3__["default"])(index, last);
    var temp = sample[index];
    sample[index] = sample[rand];
    sample[rand] = temp;
  }
  return sample.slice(0, n);
}


/***/ }),

/***/ "./node_modules/underscore/modules/shuffle.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/shuffle.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ shuffle)
/* harmony export */ });
/* harmony import */ var _sample_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sample.js */ "./node_modules/underscore/modules/sample.js");


// Shuffle a collection.
function shuffle(obj) {
  return (0,_sample_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj, Infinity);
}


/***/ }),

/***/ "./node_modules/underscore/modules/size.js":
/*!*************************************************!*\
  !*** ./node_modules/underscore/modules/size.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ size)
/* harmony export */ });
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_isArrayLike.js */ "./node_modules/underscore/modules/_isArrayLike.js");
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keys.js */ "./node_modules/underscore/modules/keys.js");



// Return the number of elements in a collection.
function size(obj) {
  if (obj == null) return 0;
  return (0,_isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj) ? obj.length : (0,_keys_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj).length;
}


/***/ }),

/***/ "./node_modules/underscore/modules/some.js":
/*!*************************************************!*\
  !*** ./node_modules/underscore/modules/some.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ some)
/* harmony export */ });
/* harmony import */ var _cb_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_cb.js */ "./node_modules/underscore/modules/_cb.js");
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_isArrayLike.js */ "./node_modules/underscore/modules/_isArrayLike.js");
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./keys.js */ "./node_modules/underscore/modules/keys.js");




// Determine if at least one element in the object passes a truth test.
function some(obj, predicate, context) {
  predicate = (0,_cb_js__WEBPACK_IMPORTED_MODULE_0__["default"])(predicate, context);
  var _keys = !(0,_isArrayLike_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj) && (0,_keys_js__WEBPACK_IMPORTED_MODULE_2__["default"])(obj),
      length = (_keys || obj).length;
  for (var index = 0; index < length; index++) {
    var currentKey = _keys ? _keys[index] : index;
    if (predicate(obj[currentKey], currentKey, obj)) return true;
  }
  return false;
}


/***/ }),

/***/ "./node_modules/underscore/modules/sortBy.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/sortBy.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ sortBy)
/* harmony export */ });
/* harmony import */ var _cb_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_cb.js */ "./node_modules/underscore/modules/_cb.js");
/* harmony import */ var _pluck_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pluck.js */ "./node_modules/underscore/modules/pluck.js");
/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./map.js */ "./node_modules/underscore/modules/map.js");




// Sort the object's values by a criterion produced by an iteratee.
function sortBy(obj, iteratee, context) {
  var index = 0;
  iteratee = (0,_cb_js__WEBPACK_IMPORTED_MODULE_0__["default"])(iteratee, context);
  return (0,_pluck_js__WEBPACK_IMPORTED_MODULE_1__["default"])((0,_map_js__WEBPACK_IMPORTED_MODULE_2__["default"])(obj, function(value, key, list) {
    return {
      value: value,
      index: index++,
      criteria: iteratee(value, key, list)
    };
  }).sort(function(left, right) {
    var a = left.criteria;
    var b = right.criteria;
    if (a !== b) {
      if (a > b || a === void 0) return 1;
      if (a < b || b === void 0) return -1;
    }
    return left.index - right.index;
  }), 'value');
}


/***/ }),

/***/ "./node_modules/underscore/modules/sortedIndex.js":
/*!********************************************************!*\
  !*** ./node_modules/underscore/modules/sortedIndex.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ sortedIndex)
/* harmony export */ });
/* harmony import */ var _cb_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_cb.js */ "./node_modules/underscore/modules/_cb.js");
/* harmony import */ var _getLength_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_getLength.js */ "./node_modules/underscore/modules/_getLength.js");



// Use a comparator function to figure out the smallest index at which
// an object should be inserted so as to maintain order. Uses binary search.
function sortedIndex(array, obj, iteratee, context) {
  iteratee = (0,_cb_js__WEBPACK_IMPORTED_MODULE_0__["default"])(iteratee, context, 1);
  var value = iteratee(obj);
  var low = 0, high = (0,_getLength_js__WEBPACK_IMPORTED_MODULE_1__["default"])(array);
  while (low < high) {
    var mid = Math.floor((low + high) / 2);
    if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
  }
  return low;
}


/***/ }),

/***/ "./node_modules/underscore/modules/tap.js":
/*!************************************************!*\
  !*** ./node_modules/underscore/modules/tap.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ tap)
/* harmony export */ });
// Invokes `interceptor` with the `obj` and then returns `obj`.
// The primary purpose of this method is to "tap into" a method chain, in
// order to perform operations on intermediate results within the chain.
function tap(obj, interceptor) {
  interceptor(obj);
  return obj;
}


/***/ }),

/***/ "./node_modules/underscore/modules/template.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/template.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ template)
/* harmony export */ });
/* harmony import */ var _defaults_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defaults.js */ "./node_modules/underscore/modules/defaults.js");
/* harmony import */ var _underscore_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./underscore.js */ "./node_modules/underscore/modules/underscore.js");
/* harmony import */ var _templateSettings_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./templateSettings.js */ "./node_modules/underscore/modules/templateSettings.js");




// When customizing `_.templateSettings`, if you don't want to define an
// interpolation, evaluation or escaping regex, we need one that is
// guaranteed not to match.
var noMatch = /(.)^/;

// Certain characters need to be escaped so that they can be put into a
// string literal.
var escapes = {
  "'": "'",
  '\\': '\\',
  '\r': 'r',
  '\n': 'n',
  '\u2028': 'u2028',
  '\u2029': 'u2029'
};

var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;

function escapeChar(match) {
  return '\\' + escapes[match];
}

// In order to prevent third-party code injection through
// `_.templateSettings.variable`, we test it against the following regular
// expression. It is intentionally a bit more liberal than just matching valid
// identifiers, but still prevents possible loopholes through defaults or
// destructuring assignment.
var bareIdentifier = /^\s*(\w|\$)+\s*$/;

// JavaScript micro-templating, similar to John Resig's implementation.
// Underscore templating handles arbitrary delimiters, preserves whitespace,
// and correctly escapes quotes within interpolated code.
// NB: `oldSettings` only exists for backwards compatibility.
function template(text, settings, oldSettings) {
  if (!settings && oldSettings) settings = oldSettings;
  settings = (0,_defaults_js__WEBPACK_IMPORTED_MODULE_0__["default"])({}, settings, _underscore_js__WEBPACK_IMPORTED_MODULE_1__["default"].templateSettings);

  // Combine delimiters into one regular expression via alternation.
  var matcher = RegExp([
    (settings.escape || noMatch).source,
    (settings.interpolate || noMatch).source,
    (settings.evaluate || noMatch).source
  ].join('|') + '|$', 'g');

  // Compile the template source, escaping string literals appropriately.
  var index = 0;
  var source = "__p+='";
  text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
    source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
    index = offset + match.length;

    if (escape) {
      source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
    } else if (interpolate) {
      source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
    } else if (evaluate) {
      source += "';\n" + evaluate + "\n__p+='";
    }

    // Adobe VMs need the match returned to produce the correct offset.
    return match;
  });
  source += "';\n";

  var argument = settings.variable;
  if (argument) {
    // Insure against third-party code injection. (CVE-2021-23358)
    if (!bareIdentifier.test(argument)) throw new Error(
      'variable is not a bare identifier: ' + argument
    );
  } else {
    // If a variable is not specified, place data values in local scope.
    source = 'with(obj||{}){\n' + source + '}\n';
    argument = 'obj';
  }

  source = "var __t,__p='',__j=Array.prototype.join," +
    "print=function(){__p+=__j.call(arguments,'');};\n" +
    source + 'return __p;\n';

  var render;
  try {
    render = new Function(argument, '_', source);
  } catch (e) {
    e.source = source;
    throw e;
  }

  var template = function(data) {
    return render.call(this, data, _underscore_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
  };

  // Provide the compiled source as a convenience for precompilation.
  template.source = 'function(' + argument + '){\n' + source + '}';

  return template;
}


/***/ }),

/***/ "./node_modules/underscore/modules/templateSettings.js":
/*!*************************************************************!*\
  !*** ./node_modules/underscore/modules/templateSettings.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _underscore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./underscore.js */ "./node_modules/underscore/modules/underscore.js");


// By default, Underscore uses ERB-style template delimiters. Change the
// following template settings to use alternative delimiters.
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_underscore_js__WEBPACK_IMPORTED_MODULE_0__["default"].templateSettings = {
  evaluate: /<%([\s\S]+?)%>/g,
  interpolate: /<%=([\s\S]+?)%>/g,
  escape: /<%-([\s\S]+?)%>/g
});


/***/ }),

/***/ "./node_modules/underscore/modules/throttle.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/throttle.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ throttle)
/* harmony export */ });
/* harmony import */ var _now_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./now.js */ "./node_modules/underscore/modules/now.js");


// Returns a function, that, when invoked, will only be triggered at most once
// during a given window of time. Normally, the throttled function will run
// as much as it can, without ever going more than once per `wait` duration;
// but if you'd like to disable the execution on the leading edge, pass
// `{leading: false}`. To disable execution on the trailing edge, ditto.
function throttle(func, wait, options) {
  var timeout, context, args, result;
  var previous = 0;
  if (!options) options = {};

  var later = function() {
    previous = options.leading === false ? 0 : (0,_now_js__WEBPACK_IMPORTED_MODULE_0__["default"])();
    timeout = null;
    result = func.apply(context, args);
    if (!timeout) context = args = null;
  };

  var throttled = function() {
    var _now = (0,_now_js__WEBPACK_IMPORTED_MODULE_0__["default"])();
    if (!previous && options.leading === false) previous = _now;
    var remaining = wait - (_now - previous);
    context = this;
    args = arguments;
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous = _now;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    } else if (!timeout && options.trailing !== false) {
      timeout = setTimeout(later, remaining);
    }
    return result;
  };

  throttled.cancel = function() {
    clearTimeout(timeout);
    previous = 0;
    timeout = context = args = null;
  };

  return throttled;
}


/***/ }),

/***/ "./node_modules/underscore/modules/times.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/times.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ times)
/* harmony export */ });
/* harmony import */ var _optimizeCb_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_optimizeCb.js */ "./node_modules/underscore/modules/_optimizeCb.js");


// Run a function **n** times.
function times(n, iteratee, context) {
  var accum = Array(Math.max(0, n));
  iteratee = (0,_optimizeCb_js__WEBPACK_IMPORTED_MODULE_0__["default"])(iteratee, context, 1);
  for (var i = 0; i < n; i++) accum[i] = iteratee(i);
  return accum;
}


/***/ }),

/***/ "./node_modules/underscore/modules/toArray.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/toArray.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toArray)
/* harmony export */ });
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/underscore/modules/isArray.js");
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");
/* harmony import */ var _isString_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isString.js */ "./node_modules/underscore/modules/isString.js");
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_isArrayLike.js */ "./node_modules/underscore/modules/_isArrayLike.js");
/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./map.js */ "./node_modules/underscore/modules/map.js");
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./identity.js */ "./node_modules/underscore/modules/identity.js");
/* harmony import */ var _values_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./values.js */ "./node_modules/underscore/modules/values.js");








// Safely create a real, live array from anything iterable.
var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
function toArray(obj) {
  if (!obj) return [];
  if ((0,_isArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj)) return _setup_js__WEBPACK_IMPORTED_MODULE_1__.slice.call(obj);
  if ((0,_isString_js__WEBPACK_IMPORTED_MODULE_2__["default"])(obj)) {
    // Keep surrogate pair characters together.
    return obj.match(reStrSymbol);
  }
  if ((0,_isArrayLike_js__WEBPACK_IMPORTED_MODULE_3__["default"])(obj)) return (0,_map_js__WEBPACK_IMPORTED_MODULE_4__["default"])(obj, _identity_js__WEBPACK_IMPORTED_MODULE_5__["default"]);
  return (0,_values_js__WEBPACK_IMPORTED_MODULE_6__["default"])(obj);
}


/***/ }),

/***/ "./node_modules/underscore/modules/toPath.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/toPath.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toPath)
/* harmony export */ });
/* harmony import */ var _underscore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./underscore.js */ "./node_modules/underscore/modules/underscore.js");
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/underscore/modules/isArray.js");



// Normalize a (deep) property `path` to array.
// Like `_.iteratee`, this function can be customized.
function toPath(path) {
  return (0,_isArray_js__WEBPACK_IMPORTED_MODULE_1__["default"])(path) ? path : [path];
}
_underscore_js__WEBPACK_IMPORTED_MODULE_0__["default"].toPath = toPath;


/***/ }),

/***/ "./node_modules/underscore/modules/underscore-array-methods.js":
/*!*********************************************************************!*\
  !*** ./node_modules/underscore/modules/underscore-array-methods.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _underscore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./underscore.js */ "./node_modules/underscore/modules/underscore.js");
/* harmony import */ var _each_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./each.js */ "./node_modules/underscore/modules/each.js");
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");
/* harmony import */ var _chainResult_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_chainResult.js */ "./node_modules/underscore/modules/_chainResult.js");





// Add all mutator `Array` functions to the wrapper.
(0,_each_js__WEBPACK_IMPORTED_MODULE_1__["default"])(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
  var method = _setup_js__WEBPACK_IMPORTED_MODULE_2__.ArrayProto[name];
  _underscore_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype[name] = function() {
    var obj = this._wrapped;
    if (obj != null) {
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) {
        delete obj[0];
      }
    }
    return (0,_chainResult_js__WEBPACK_IMPORTED_MODULE_3__["default"])(this, obj);
  };
});

// Add all accessor `Array` functions to the wrapper.
(0,_each_js__WEBPACK_IMPORTED_MODULE_1__["default"])(['concat', 'join', 'slice'], function(name) {
  var method = _setup_js__WEBPACK_IMPORTED_MODULE_2__.ArrayProto[name];
  _underscore_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype[name] = function() {
    var obj = this._wrapped;
    if (obj != null) obj = method.apply(obj, arguments);
    return (0,_chainResult_js__WEBPACK_IMPORTED_MODULE_3__["default"])(this, obj);
  };
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_underscore_js__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./node_modules/underscore/modules/underscore.js":
/*!*******************************************************!*\
  !*** ./node_modules/underscore/modules/underscore.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _)
/* harmony export */ });
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");


// If Underscore is called as a function, it returns a wrapped object that can
// be used OO-style. This wrapper holds altered versions of all functions added
// through `_.mixin`. Wrapped objects may be chained.
function _(obj) {
  if (obj instanceof _) return obj;
  if (!(this instanceof _)) return new _(obj);
  this._wrapped = obj;
}

_.VERSION = _setup_js__WEBPACK_IMPORTED_MODULE_0__.VERSION;

// Extracts the result from a wrapped and chained object.
_.prototype.value = function() {
  return this._wrapped;
};

// Provide unwrapping proxies for some methods used in engine operations
// such as arithmetic and JSON stringification.
_.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

_.prototype.toString = function() {
  return String(this._wrapped);
};


/***/ }),

/***/ "./node_modules/underscore/modules/unescape.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/unescape.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _createEscaper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createEscaper.js */ "./node_modules/underscore/modules/_createEscaper.js");
/* harmony import */ var _unescapeMap_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_unescapeMap.js */ "./node_modules/underscore/modules/_unescapeMap.js");



// Function for unescaping strings from HTML interpolation.
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_createEscaper_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_unescapeMap_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/***/ }),

/***/ "./node_modules/underscore/modules/union.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/union.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _restArguments_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./restArguments.js */ "./node_modules/underscore/modules/restArguments.js");
/* harmony import */ var _uniq_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./uniq.js */ "./node_modules/underscore/modules/uniq.js");
/* harmony import */ var _flatten_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_flatten.js */ "./node_modules/underscore/modules/_flatten.js");




// Produce an array that contains the union: each distinct element from all of
// the passed-in arrays.
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_restArguments_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(arrays) {
  return (0,_uniq_js__WEBPACK_IMPORTED_MODULE_1__["default"])((0,_flatten_js__WEBPACK_IMPORTED_MODULE_2__["default"])(arrays, true, true));
}));


/***/ }),

/***/ "./node_modules/underscore/modules/uniq.js":
/*!*************************************************!*\
  !*** ./node_modules/underscore/modules/uniq.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ uniq)
/* harmony export */ });
/* harmony import */ var _isBoolean_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isBoolean.js */ "./node_modules/underscore/modules/isBoolean.js");
/* harmony import */ var _cb_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_cb.js */ "./node_modules/underscore/modules/_cb.js");
/* harmony import */ var _getLength_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_getLength.js */ "./node_modules/underscore/modules/_getLength.js");
/* harmony import */ var _contains_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./contains.js */ "./node_modules/underscore/modules/contains.js");





// Produce a duplicate-free version of the array. If the array has already
// been sorted, you have the option of using a faster algorithm.
// The faster algorithm will not work with an iteratee if the iteratee
// is not a one-to-one function, so providing an iteratee will disable
// the faster algorithm.
function uniq(array, isSorted, iteratee, context) {
  if (!(0,_isBoolean_js__WEBPACK_IMPORTED_MODULE_0__["default"])(isSorted)) {
    context = iteratee;
    iteratee = isSorted;
    isSorted = false;
  }
  if (iteratee != null) iteratee = (0,_cb_js__WEBPACK_IMPORTED_MODULE_1__["default"])(iteratee, context);
  var result = [];
  var seen = [];
  for (var i = 0, length = (0,_getLength_js__WEBPACK_IMPORTED_MODULE_2__["default"])(array); i < length; i++) {
    var value = array[i],
        computed = iteratee ? iteratee(value, i, array) : value;
    if (isSorted && !iteratee) {
      if (!i || seen !== computed) result.push(value);
      seen = computed;
    } else if (iteratee) {
      if (!(0,_contains_js__WEBPACK_IMPORTED_MODULE_3__["default"])(seen, computed)) {
        seen.push(computed);
        result.push(value);
      }
    } else if (!(0,_contains_js__WEBPACK_IMPORTED_MODULE_3__["default"])(result, value)) {
      result.push(value);
    }
  }
  return result;
}


/***/ }),

/***/ "./node_modules/underscore/modules/uniqueId.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/uniqueId.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ uniqueId)
/* harmony export */ });
// Generate a unique integer id (unique within the entire client session).
// Useful for temporary DOM ids.
var idCounter = 0;
function uniqueId(prefix) {
  var id = ++idCounter + '';
  return prefix ? prefix + id : id;
}


/***/ }),

/***/ "./node_modules/underscore/modules/unzip.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/unzip.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ unzip)
/* harmony export */ });
/* harmony import */ var _max_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./max.js */ "./node_modules/underscore/modules/max.js");
/* harmony import */ var _getLength_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_getLength.js */ "./node_modules/underscore/modules/_getLength.js");
/* harmony import */ var _pluck_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pluck.js */ "./node_modules/underscore/modules/pluck.js");




// Complement of zip. Unzip accepts an array of arrays and groups
// each array's elements on shared indices.
function unzip(array) {
  var length = (array && (0,_max_js__WEBPACK_IMPORTED_MODULE_0__["default"])(array, _getLength_js__WEBPACK_IMPORTED_MODULE_1__["default"]).length) || 0;
  var result = Array(length);

  for (var index = 0; index < length; index++) {
    result[index] = (0,_pluck_js__WEBPACK_IMPORTED_MODULE_2__["default"])(array, index);
  }
  return result;
}


/***/ }),

/***/ "./node_modules/underscore/modules/values.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/values.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ values)
/* harmony export */ });
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./keys.js */ "./node_modules/underscore/modules/keys.js");


// Retrieve the values of an object's properties.
function values(obj) {
  var _keys = (0,_keys_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj);
  var length = _keys.length;
  var values = Array(length);
  for (var i = 0; i < length; i++) {
    values[i] = obj[_keys[i]];
  }
  return values;
}


/***/ }),

/***/ "./node_modules/underscore/modules/where.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/where.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ where)
/* harmony export */ });
/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./filter.js */ "./node_modules/underscore/modules/filter.js");
/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./matcher.js */ "./node_modules/underscore/modules/matcher.js");



// Convenience version of a common use case of `_.filter`: selecting only
// objects containing specific `key:value` pairs.
function where(obj, attrs) {
  return (0,_filter_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj, (0,_matcher_js__WEBPACK_IMPORTED_MODULE_1__["default"])(attrs));
}


/***/ }),

/***/ "./node_modules/underscore/modules/without.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/without.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _restArguments_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./restArguments.js */ "./node_modules/underscore/modules/restArguments.js");
/* harmony import */ var _difference_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./difference.js */ "./node_modules/underscore/modules/difference.js");



// Return a version of the array that does not contain the specified value(s).
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_restArguments_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(array, otherArrays) {
  return (0,_difference_js__WEBPACK_IMPORTED_MODULE_1__["default"])(array, otherArrays);
}));


/***/ }),

/***/ "./node_modules/underscore/modules/wrap.js":
/*!*************************************************!*\
  !*** ./node_modules/underscore/modules/wrap.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ wrap)
/* harmony export */ });
/* harmony import */ var _partial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./partial.js */ "./node_modules/underscore/modules/partial.js");


// Returns the first function passed as an argument to the second,
// allowing you to adjust arguments, run code before and after, and
// conditionally execute the original function.
function wrap(func, wrapper) {
  return (0,_partial_js__WEBPACK_IMPORTED_MODULE_0__["default"])(wrapper, func);
}


/***/ }),

/***/ "./node_modules/underscore/modules/zip.js":
/*!************************************************!*\
  !*** ./node_modules/underscore/modules/zip.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _restArguments_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./restArguments.js */ "./node_modules/underscore/modules/restArguments.js");
/* harmony import */ var _unzip_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./unzip.js */ "./node_modules/underscore/modules/unzip.js");



// Zip together multiple lists into a single array -- elements that share
// an index go together.
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_restArguments_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_unzip_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/***/ }),

/***/ "./src/app.ts":
/*!********************!*\
  !*** ./src/app.ts ***!
  \********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// New modernized Road Traffic Simulator with separation of concerns
__webpack_require__(/*! ./helpers */ "./src/helpers.ts");
// Import theme CSS files in the correct order for precedence
__webpack_require__(/*! ../css/style.css */ "./css/style.css");
__webpack_require__(/*! ../css/dat-gui.css */ "./css/dat-gui.css");
__webpack_require__(/*! ../css/dark-theme.css */ "./css/dark-theme.css"); // This theme will override other styles
__webpack_require__(/*! ../css/kpi-visualization.css */ "./css/kpi-visualization.css"); // KPI visualization component styles
const $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
__webpack_require__(/*! jquery-mousewheel */ "./node_modules/jquery-mousewheel/jquery.mousewheel.js");
// Import the new architecture components
const AppState_1 = __webpack_require__(/*! ./core/AppState */ "./src/core/AppState.ts");
const Router_1 = __webpack_require__(/*! ./core/Router */ "./src/core/Router.ts");
const NavigationComponent_1 = __webpack_require__(/*! ./components/NavigationComponent */ "./src/components/NavigationComponent.ts");
const HomePage_1 = __webpack_require__(/*! ./pages/HomePage */ "./src/pages/HomePage.ts");
const BuilderPageComponent_1 = __webpack_require__(/*! ./pages/BuilderPageComponent */ "./src/pages/BuilderPageComponent.ts");
const SimulationPageComponent_1 = __webpack_require__(/*! ./pages/SimulationPageComponent */ "./src/pages/SimulationPageComponent.ts");
// Import tests in development mode
__webpack_require__(/*! ./model/traffic-control/tests */ "./src/model/traffic-control/tests/index.ts");
// Initialize the modernized application
$(() => {
    console.log('🚀 Road Traffic Simulator starting with new architecture...');
    // Wait for DOM to be ready
    setTimeout(() => {
        // Clear any existing content
        document.body.innerHTML = '';
        // Create main application container
        const appContainer = $('<div id="app-container"></div>');
        $(document.body).append(appContainer);
        // Create navigation container
        const navContainer = $('<div id="nav-container"></div>')[0];
        appContainer.append(navContainer);
        // Create main content area
        const mainContent = $('<div id="main-content"></div>')[0];
        appContainer.append(mainContent);
        // Initialize router
        const router = new Router_1.Router();
        // Initialize navigation component
        const navigation = new NavigationComponent_1.NavigationComponent(navContainer, router);
        // Initialize page components (lazy loading)
        let homePage = null;
        let builderPage = null;
        let simulationPage = null;
        // Add routes
        router.addRoute('/', () => {
            console.log('🏠 Navigating to Home page');
            // Properly destroy any existing pages
            if (builderPage) {
                builderPage.destroy();
                builderPage = null;
            }
            if (simulationPage) {
                simulationPage.destroy();
                simulationPage = null;
            }
            // Allow scrolling on home page
            document.body.classList.remove('no-scroll');
            document.body.classList.add('allow-scroll');
            // Clear content and create fresh home page
            mainContent.innerHTML = '';
            homePage = new HomePage_1.HomePage(mainContent, router);
        });
        router.addRoute('/builder', () => {
            console.log('📐 Navigating to Builder page');
            // Properly destroy any existing pages
            if (homePage) {
                homePage = null;
            }
            if (simulationPage) {
                simulationPage.destroy();
                simulationPage = null;
            }
            if (builderPage) {
                builderPage.destroy();
                builderPage = null;
            }
            // Prevent scrolling on builder page
            document.body.classList.remove('allow-scroll');
            document.body.classList.add('no-scroll');
            // Clear content and create fresh builder page
            mainContent.innerHTML = '';
            builderPage = new BuilderPageComponent_1.BuilderPageComponent(mainContent);
        });
        router.addRoute('/simulation', () => {
            console.log('🏃 Navigating to Simulation page');
            // Properly destroy any existing pages
            if (homePage) {
                homePage = null;
            }
            if (builderPage) {
                builderPage.destroy();
                builderPage = null;
            }
            if (simulationPage) {
                simulationPage.destroy();
                simulationPage = null;
            }
            // Prevent scrolling on simulation page
            document.body.classList.remove('allow-scroll');
            document.body.classList.add('no-scroll');
            // Clear content and create fresh simulation page
            mainContent.innerHTML = '';
            simulationPage = new SimulationPageComponent_1.SimulationPageComponent(mainContent);
        });
        // Start the router (which will trigger the initial route)
        router.start();
        console.log('🚀 Modern application ready');
        console.log('🏠 Home page: Welcome and navigation');
        console.log('📐 Builder mode: Create and edit road layouts');
        console.log('🏃 Simulation mode: Run traffic simulations on saved layouts');
        // Expose useful debugging functions
        window.appState = AppState_1.appState;
        window.router = router;
        window.getBuilderPage = () => builderPage;
        window.getSimulationPage = () => simulationPage;
        // Navigation helper functions for debugging
        window.goToHome = () => router.navigate('/');
        window.goToBuilder = () => router.navigate('/builder');
        window.goToSimulation = () => router.navigate('/simulation');
        console.log('🛠️ Debug functions available: appState, router, getBuilderPage(), getSimulationPage(), goToHome(), goToBuilder(), goToSimulation()');
    }, 10);
});


/***/ }),

/***/ "./src/components/KPIVisualizationComponent.ts":
/*!*****************************************************!*\
  !*** ./src/components/KPIVisualizationComponent.ts ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * KPI Visualization Component - Creates interactive tables and charts for KPI display
 *
 * This component provides:
 * - Interactive tables with sorting and filtering
 * - Time-series charts for metrics evolution
 * - Export functionality for CSV and JSON
 * - Side-by-side comparison of benchmark runs
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KPIVisualizationComponent = void 0;
// Import Chart.js with auto-registration of all components
const auto_1 = __importDefault(__webpack_require__(/*! chart.js/auto */ "./node_modules/chart.js/auto/auto.cjs"));
class KPIVisualizationComponent {
    constructor(container) {
        this.charts = {};
        this.currentBenchmark = null;
        this.benchmarkHistory = [];
        this.container = container;
        this.loadBenchmarkHistory();
    }
    /**
     * Display benchmark results with interactive tables and charts
     */
    displayBenchmarkResults(benchmarkData) {
        this.currentBenchmark = benchmarkData;
        this.addToBenchmarkHistory(benchmarkData);
        this.render();
    }
    /**
     * Render the complete KPI visualization interface
     */
    render() {
        if (!this.currentBenchmark) {
            this.container.innerHTML = '<div class="kpi-message">No benchmark data available</div>';
            return;
        }
        this.container.innerHTML = `
      <div class="kpi-visualization">
        <!-- Header Controls -->
        <div class="kpi-header">
          <h3>KPI Benchmark Results</h3>
          <div class="kpi-controls">
            <button id="export-csv-btn" class="btn btn-success btn-sm">📄 Export CSV</button>
            <button id="export-json-btn" class="btn btn-info btn-sm">📋 Export JSON</button>
            <button id="compare-runs-btn" class="btn btn-warning btn-sm">📊 Compare Runs</button>
            <button id="validate-data-btn" class="btn btn-secondary btn-sm">✓ Validate Data</button>
          </div>
        </div>

        <!-- Summary Cards -->
        <div class="kpi-summary">
          ${this.renderSummaryCards()}
        </div>

        <!-- Time Series Charts -->
        <div class="kpi-charts">
          <div class="chart-section">
            <h4>Performance Over Time</h4>
            <div class="chart-grid">
              <div class="chart-container">
                <canvas id="speed-chart"></canvas>
              </div>
              <div class="chart-container">
                <canvas id="throughput-chart"></canvas>
              </div>
              <div class="chart-container">
                <canvas id="wait-time-chart"></canvas>
              </div>
              <div class="chart-container">
                <canvas id="congestion-chart"></canvas>
              </div>
            </div>
          </div>
        </div>

        <!-- Interactive Tables -->
        <div class="kpi-tables">
          <!-- Lane Metrics Table -->
          <div class="table-section">
            <h4>Lane Performance Metrics</h4>
            <div class="table-controls">
              <input type="text" id="lane-search" placeholder="Search lanes..." class="form-control">
              <select id="lane-sort" class="form-control">
                <option value="">Sort by...</option>
                <option value="averageSpeed">Average Speed</option>
                <option value="throughput">Throughput</option>
                <option value="congestionRate">Congestion Rate</option>
                <option value="queueLength">Queue Length</option>
              </select>
            </div>
            <div class="table-wrapper">
              <table id="lane-metrics-table" class="interactive-table">
                <thead>
                  <tr>
                    <th data-sort="laneId">Lane ID</th>
                    <th data-sort="averageSpeed">Avg Speed (m/s)</th>
                    <th data-sort="vehicleCount">Vehicle Count</th>
                    <th data-sort="throughput">Throughput (veh/min)</th>
                    <th data-sort="congestionRate">Congestion Rate</th>
                    <th data-sort="queueLength">Queue Length</th>
                    <th data-sort="averageWaitTime">Avg Wait Time (s)</th>
                    <th data-sort="totalVehiclesPassed">Total Passed</th>
                  </tr>
                </thead>
                <tbody></tbody>
              </table>
            </div>
          </div>

          <!-- Intersection Metrics Table -->
          <div class="table-section">
            <h4>Intersection Performance Metrics</h4>
            <div class="table-controls">
              <input type="text" id="intersection-search" placeholder="Search intersections..." class="form-control">
              <select id="intersection-sort" class="form-control">
                <option value="">Sort by...</option>
                <option value="throughput">Throughput</option>
                <option value="averageWaitTime">Average Wait Time</option>
                <option value="averageQueueLength">Average Queue Length</option>
                <option value="congestionRate">Congestion Rate</option>
              </select>
            </div>
            <div class="table-wrapper">
              <table id="intersection-metrics-table" class="interactive-table">
                <thead>
                  <tr>
                    <th data-sort="intersectionId">Intersection ID</th>
                    <th data-sort="throughput">Throughput (veh/min)</th>
                    <th data-sort="averageWaitTime">Avg Wait Time (s)</th>
                    <th data-sort="maxWaitTime">Max Wait Time (s)</th>
                    <th data-sort="averageQueueLength">Avg Queue Length</th>
                    <th data-sort="maxQueueLength">Max Queue Length</th>
                    <th data-sort="congestionRate">Congestion Rate</th>
                    <th data-sort="totalVehiclesPassed">Total Passed</th>
                  </tr>
                </thead>
                <tbody></tbody>
              </table>
            </div>
          </div>
        </div>

        <!-- Comparison Panel (hidden by default) -->
        <div id="comparison-panel" class="comparison-panel" style="display: none;">
          <h4>Benchmark Comparison</h4>
          <div class="comparison-controls">
            <select id="comparison-benchmark" class="form-control">
              <option value="">Select benchmark to compare...</option>
            </select>
            <button id="close-comparison" class="btn btn-secondary btn-sm">Close</button>
          </div>
          <div id="comparison-content"></div>
        </div>

        <!-- Validation Results (hidden by default) -->
        <div id="validation-panel" class="validation-panel" style="display: none;">
          <h4>Data Validation Results</h4>
          <div id="validation-content"></div>
        </div>
      </div>
    `;
        // Initialize event listeners
        this.initializeEventListeners();
        // Populate tables
        this.populateTables();
        // Create charts
        this.createCharts();
    }
    /**
     * Render summary cards for key metrics
     */
    renderSummaryCards() {
        const metrics = this.currentBenchmark.finalMetrics;
        return `
      <div class="summary-grid">
        <div class="summary-card">
          <div class="card-value">${metrics.averageSpeed.toFixed(2)}</div>
          <div class="card-label">Average Speed (m/s)</div>
          <div class="card-change ${this.getChangeClass('speed')}">${this.getChangeText('speed')}</div>
        </div>
        <div class="summary-card">
          <div class="card-value">${metrics.globalThroughput.toFixed(1)}</div>
          <div class="card-label">Global Throughput (veh/min)</div>
          <div class="card-change ${this.getChangeClass('throughput')}">${this.getChangeText('throughput')}</div>
        </div>
        <div class="summary-card">
          <div class="card-value">${metrics.averageWaitTime.toFixed(1)}</div>
          <div class="card-label">Avg Wait Time (s)</div>
          <div class="card-change ${this.getChangeClass('waitTime')}">${this.getChangeText('waitTime')}</div>
        </div>
        <div class="summary-card">
          <div class="card-value">${(metrics.congestionIndex * 100).toFixed(1)}%</div>
          <div class="card-label">Congestion Index</div>
          <div class="card-change ${this.getChangeClass('congestion')}">${this.getChangeText('congestion')}</div>
        </div>
        <div class="summary-card">
          <div class="card-value">${metrics.totalVehicles}</div>
          <div class="card-label">Total Vehicles</div>
          <div class="card-change">-</div>
        </div>
        <div class="summary-card">
          <div class="card-value">${metrics.completedTrips}</div>
          <div class="card-label">Completed Trips</div>
          <div class="card-change">-</div>
        </div>
      </div>
    `;
    }
    /**
     * Get change class for metric comparison
     */
    getChangeClass(metric) {
        // For now, return neutral. In the future, this could compare with previous runs
        return 'neutral';
    }
    /**
     * Get change text for metric comparison
     */
    getChangeText(metric) {
        // For now, return no change. In the future, this could show actual changes
        return '-';
    }
    /**
     * Initialize event listeners for interactive elements
     */
    initializeEventListeners() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        // Export buttons
        (_a = document.getElementById('export-csv-btn')) === null || _a === void 0 ? void 0 : _a.addEventListener('click', () => this.exportCSV());
        (_b = document.getElementById('export-json-btn')) === null || _b === void 0 ? void 0 : _b.addEventListener('click', () => this.exportJSON());
        (_c = document.getElementById('compare-runs-btn')) === null || _c === void 0 ? void 0 : _c.addEventListener('click', () => this.showComparisonPanel());
        (_d = document.getElementById('validate-data-btn')) === null || _d === void 0 ? void 0 : _d.addEventListener('click', () => this.showValidationPanel());
        // Table search and sort
        (_e = document.getElementById('lane-search')) === null || _e === void 0 ? void 0 : _e.addEventListener('input', (e) => this.filterTable('lane-metrics-table', e.target.value));
        (_f = document.getElementById('intersection-search')) === null || _f === void 0 ? void 0 : _f.addEventListener('input', (e) => this.filterTable('intersection-metrics-table', e.target.value));
        (_g = document.getElementById('lane-sort')) === null || _g === void 0 ? void 0 : _g.addEventListener('change', (e) => this.sortTable('lane-metrics-table', e.target.value));
        (_h = document.getElementById('intersection-sort')) === null || _h === void 0 ? void 0 : _h.addEventListener('change', (e) => this.sortTable('intersection-metrics-table', e.target.value));
        // Table header sorting
        document.querySelectorAll('#lane-metrics-table th[data-sort]').forEach(th => {
            th.addEventListener('click', () => {
                const sortKey = th.getAttribute('data-sort');
                this.sortTable('lane-metrics-table', sortKey);
            });
        });
        document.querySelectorAll('#intersection-metrics-table th[data-sort]').forEach(th => {
            th.addEventListener('click', () => {
                const sortKey = th.getAttribute('data-sort');
                this.sortTable('intersection-metrics-table', sortKey);
            });
        });
        // Comparison panel
        (_j = document.getElementById('close-comparison')) === null || _j === void 0 ? void 0 : _j.addEventListener('click', () => {
            document.getElementById('comparison-panel').style.display = 'none';
        });
        (_k = document.getElementById('comparison-benchmark')) === null || _k === void 0 ? void 0 : _k.addEventListener('change', (e) => {
            const selectedId = e.target.value;
            if (selectedId) {
                this.showComparison(selectedId);
            }
        });
    }
    /**
     * Populate interactive tables with data
     */
    populateTables() {
        this.populateLaneTable();
        this.populateIntersectionTable();
    }
    /**
     * Populate lane metrics table
     */
    populateLaneTable() {
        const tbody = document.querySelector('#lane-metrics-table tbody');
        const metrics = this.currentBenchmark.finalMetrics;
        tbody.innerHTML = '';
        Object.values(metrics.laneMetrics).forEach((lane) => {
            const row = document.createElement('tr');
            row.innerHTML = `
        <td>${lane.laneId}</td>
        <td>${lane.averageSpeed.toFixed(2)}</td>
        <td>${lane.vehicleCount}</td>
        <td>${lane.throughput.toFixed(2)}</td>
        <td><span class="congestion-indicator" style="background-color: ${this.getCongestionColor(lane.congestionRate)}">${(lane.congestionRate * 100).toFixed(1)}%</span></td>
        <td>${lane.queueLength}</td>
        <td>${lane.averageWaitTime.toFixed(1)}</td>
        <td>${lane.totalVehiclesPassed}</td>
      `;
            tbody.appendChild(row);
        });
    }
    /**
     * Populate intersection metrics table
     */
    populateIntersectionTable() {
        const tbody = document.querySelector('#intersection-metrics-table tbody');
        const metrics = this.currentBenchmark.finalMetrics;
        tbody.innerHTML = '';
        Object.values(metrics.intersectionMetrics).forEach((intersection) => {
            const row = document.createElement('tr');
            row.innerHTML = `
        <td>${intersection.intersectionId}</td>
        <td>${intersection.throughput.toFixed(2)}</td>
        <td>${intersection.averageWaitTime.toFixed(1)}</td>
        <td>${intersection.maxWaitTime.toFixed(1)}</td>
        <td>${intersection.averageQueueLength.toFixed(1)}</td>
        <td>${intersection.maxQueueLength}</td>
        <td><span class="congestion-indicator" style="background-color: ${this.getCongestionColor(intersection.congestionRate)}">${(intersection.congestionRate * 100).toFixed(1)}%</span></td>
        <td>${intersection.totalVehiclesPassed}</td>
      `;
            tbody.appendChild(row);
        });
    }
    /**
     * Get color for congestion rate visualization
     */
    getCongestionColor(rate) {
        if (rate < 0.3)
            return '#4CAF50'; // Green
        if (rate < 0.6)
            return '#FF9800'; // Orange
        return '#F44336'; // Red
    }
    /**
     * Filter table based on search term
     */
    filterTable(tableId, searchTerm) {
        const table = document.getElementById(tableId);
        const rows = table.querySelectorAll('tbody tr');
        rows.forEach(row => {
            var _a;
            const text = ((_a = row.textContent) === null || _a === void 0 ? void 0 : _a.toLowerCase()) || '';
            if (text.includes(searchTerm.toLowerCase())) {
                row.style.display = '';
            }
            else {
                row.style.display = 'none';
            }
        });
    }
    /**
     * Sort table by specified column
     */
    sortTable(tableId, sortKey) {
        if (!sortKey)
            return;
        const table = document.getElementById(tableId);
        const tbody = table.querySelector('tbody');
        const rows = Array.from(tbody.querySelectorAll('tr'));
        const isNumeric = this.isNumericColumn(sortKey);
        rows.sort((a, b) => {
            const aValue = this.getCellValue(a, sortKey);
            const bValue = this.getCellValue(b, sortKey);
            if (isNumeric) {
                return parseFloat(bValue) - parseFloat(aValue); // Descending for numeric
            }
            else {
                return aValue.localeCompare(bValue); // Ascending for text
            }
        });
        rows.forEach(row => tbody.appendChild(row));
    }
    /**
     * Check if column should be sorted numerically
     */
    isNumericColumn(sortKey) {
        return [
            'averageSpeed', 'vehicleCount', 'throughput', 'congestionRate',
            'queueLength', 'averageWaitTime', 'totalVehiclesPassed',
            'maxWaitTime', 'averageQueueLength', 'maxQueueLength'
        ].includes(sortKey);
    }
    /**
     * Get cell value for sorting
     */
    getCellValue(row, sortKey) {
        var _a;
        const headers = Array.from(row.parentElement.parentElement.querySelectorAll('th[data-sort]'));
        const index = headers.findIndex(th => th.getAttribute('data-sort') === sortKey);
        if (index >= 0) {
            const cell = row.children[index];
            return ((_a = cell.textContent) === null || _a === void 0 ? void 0 : _a.replace(/[^\d.-]/g, '')) || '0';
        }
        return '0';
    }
    /**
     * Create time-series charts
     */
    createCharts() {
        this.createSpeedChart();
        this.createThroughputChart();
        this.createWaitTimeChart();
        this.createCongestionChart();
    }
    /**
     * Create speed over time chart
     */
    createSpeedChart() {
        const ctx = document.getElementById('speed-chart');
        if (!ctx)
            return;
        const samples = this.currentBenchmark.samples;
        const labels = samples.map((_, index) => `${index * 1}s`); // 1-second intervals
        const data = samples.map(sample => sample.averageSpeed);
        const config = {
            type: 'line',
            data: {
                labels,
                datasets: [{
                        label: 'Average Speed (m/s)',
                        data,
                        borderColor: '#2196F3',
                        backgroundColor: 'rgba(33, 150, 243, 0.1)',
                        tension: 0.4
                    }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Average Speed Over Time',
                        color: '#ffffff'
                    },
                    legend: {
                        labels: {
                            color: '#ffffff'
                        }
                    }
                },
                scales: {
                    x: {
                        ticks: { color: '#ffffff' },
                        grid: { color: 'rgba(255, 255, 255, 0.1)' }
                    },
                    y: {
                        ticks: { color: '#ffffff' },
                        grid: { color: 'rgba(255, 255, 255, 0.1)' }
                    }
                }
            }
        };
        this.charts['speed'] = new auto_1.default(ctx, config);
    }
    /**
     * Create throughput over time chart
     */
    createThroughputChart() {
        const ctx = document.getElementById('throughput-chart');
        if (!ctx)
            return;
        const samples = this.currentBenchmark.samples;
        const labels = samples.map((_, index) => `${index * 1}s`);
        const data = samples.map(sample => sample.globalThroughput);
        const config = {
            type: 'line',
            data: {
                labels,
                datasets: [{
                        label: 'Global Throughput (veh/min)',
                        data,
                        borderColor: '#4CAF50',
                        backgroundColor: 'rgba(76, 175, 80, 0.1)',
                        tension: 0.4
                    }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Global Throughput Over Time',
                        color: '#ffffff'
                    },
                    legend: {
                        labels: {
                            color: '#ffffff'
                        }
                    }
                },
                scales: {
                    x: {
                        ticks: { color: '#ffffff' },
                        grid: { color: 'rgba(255, 255, 255, 0.1)' }
                    },
                    y: {
                        ticks: { color: '#ffffff' },
                        grid: { color: 'rgba(255, 255, 255, 0.1)' }
                    }
                }
            }
        };
        this.charts['throughput'] = new auto_1.default(ctx, config);
    }
    /**
     * Create wait time over time chart
     */
    createWaitTimeChart() {
        const ctx = document.getElementById('wait-time-chart');
        if (!ctx)
            return;
        const samples = this.currentBenchmark.samples;
        const labels = samples.map((_, index) => `${index * 1}s`);
        const avgWaitData = samples.map(sample => sample.averageWaitTime);
        const maxWaitData = samples.map(sample => sample.maxWaitTime);
        const config = {
            type: 'line',
            data: {
                labels,
                datasets: [
                    {
                        label: 'Average Wait Time (s)',
                        data: avgWaitData,
                        borderColor: '#FF9800',
                        backgroundColor: 'rgba(255, 152, 0, 0.1)',
                        tension: 0.4
                    },
                    {
                        label: 'Max Wait Time (s)',
                        data: maxWaitData,
                        borderColor: '#F44336',
                        backgroundColor: 'rgba(244, 67, 54, 0.1)',
                        tension: 0.4
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Wait Times Over Time',
                        color: '#ffffff'
                    },
                    legend: {
                        labels: {
                            color: '#ffffff'
                        }
                    }
                },
                scales: {
                    x: {
                        ticks: { color: '#ffffff' },
                        grid: { color: 'rgba(255, 255, 255, 0.1)' }
                    },
                    y: {
                        ticks: { color: '#ffffff' },
                        grid: { color: 'rgba(255, 255, 255, 0.1)' }
                    }
                }
            }
        };
        this.charts['waitTime'] = new auto_1.default(ctx, config);
    }
    /**
     * Create congestion over time chart
     */
    createCongestionChart() {
        const ctx = document.getElementById('congestion-chart');
        if (!ctx)
            return;
        const samples = this.currentBenchmark.samples;
        const labels = samples.map((_, index) => `${index * 1}s`);
        const data = samples.map(sample => sample.congestionIndex * 100); // Convert to percentage
        const config = {
            type: 'line',
            data: {
                labels,
                datasets: [{
                        label: 'Congestion Index (%)',
                        data,
                        borderColor: '#9C27B0',
                        backgroundColor: 'rgba(156, 39, 176, 0.2)',
                        fill: true,
                        tension: 0.4
                    }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Congestion Index Over Time',
                        color: '#ffffff'
                    },
                    legend: {
                        labels: {
                            color: '#ffffff'
                        }
                    }
                },
                scales: {
                    x: {
                        ticks: { color: '#ffffff' },
                        grid: { color: 'rgba(255, 255, 255, 0.1)' }
                    },
                    y: {
                        ticks: { color: '#ffffff' },
                        grid: { color: 'rgba(255, 255, 255, 0.1)' },
                        min: 0,
                        max: 100
                    }
                }
            }
        };
        this.charts['congestion'] = new auto_1.default(ctx, config);
    }
    /**
     * Export current benchmark data as CSV
     */
    exportCSV() {
        var _a, _b, _c;
        if (!this.currentBenchmark)
            return;
        const benchmark = this.currentBenchmark;
        let csv = 'Traffic Simulation Benchmark Results\n\n';
        // Summary information
        csv += 'Benchmark Summary\n';
        csv += `Name,${benchmark.name}\n`;
        csv += `Timestamp,${benchmark.timestamp}\n`;
        csv += `Duration,${((_a = benchmark.settings) === null || _a === void 0 ? void 0 : _a.duration) || 'Unknown'} seconds\n`;
        csv += `Traffic Control Model,${((_b = benchmark.settings) === null || _b === void 0 ? void 0 : _b.trafficControlModel) || 'Unknown'}\n`;
        csv += `Vehicle Count,${((_c = benchmark.settings) === null || _c === void 0 ? void 0 : _c.carsNumber) || 'Unknown'}\n\n`;
        // Key metrics
        const metrics = benchmark.finalMetrics;
        csv += 'Key Performance Metrics\n';
        csv += 'Metric,Value\n';
        csv += `Average Speed (m/s),${metrics.averageSpeed.toFixed(2)}\n`;
        csv += `Global Throughput (veh/min),${metrics.globalThroughput.toFixed(2)}\n`;
        csv += `Average Wait Time (s),${metrics.averageWaitTime.toFixed(2)}\n`;
        csv += `Max Wait Time (s),${metrics.maxWaitTime.toFixed(2)}\n`;
        csv += `Congestion Index,${metrics.congestionIndex.toFixed(3)}\n`;
        csv += `Total Vehicles,${metrics.totalVehicles}\n`;
        csv += `Completed Trips,${metrics.completedTrips}\n`;
        csv += `Total Stops,${metrics.totalStops}\n\n`;
        // Lane metrics
        csv += 'Lane Performance Metrics\n';
        csv += 'Lane ID,Average Speed (m/s),Vehicle Count,Throughput (veh/min),Congestion Rate,Queue Length,Average Wait Time (s),Total Vehicles Passed\n';
        Object.values(metrics.laneMetrics).forEach((lane) => {
            csv += `${lane.laneId},${lane.averageSpeed.toFixed(2)},${lane.vehicleCount},${lane.throughput.toFixed(2)},${lane.congestionRate.toFixed(3)},${lane.queueLength},${lane.averageWaitTime.toFixed(2)},${lane.totalVehiclesPassed}\n`;
        });
        csv += '\n';
        // Intersection metrics
        csv += 'Intersection Performance Metrics\n';
        csv += 'Intersection ID,Throughput (veh/min),Average Wait Time (s),Max Wait Time (s),Average Queue Length,Max Queue Length,Congestion Rate,Total Vehicles Passed\n';
        Object.values(metrics.intersectionMetrics).forEach((intersection) => {
            csv += `${intersection.intersectionId},${intersection.throughput.toFixed(2)},${intersection.averageWaitTime.toFixed(2)},${intersection.maxWaitTime.toFixed(2)},${intersection.averageQueueLength.toFixed(2)},${intersection.maxQueueLength},${intersection.congestionRate.toFixed(3)},${intersection.totalVehiclesPassed}\n`;
        });
        csv += '\n';
        // Time series data
        if (benchmark.samples && benchmark.samples.length > 0) {
            csv += 'Time Series Data\n';
            csv += 'Time (s),Average Speed (m/s),Global Throughput (veh/min),Average Wait Time (s),Max Wait Time (s),Congestion Index,Active Vehicles,Completed Trips\n';
            benchmark.samples.forEach((sample, index) => {
                csv += `${index},${sample.averageSpeed.toFixed(2)},${sample.globalThroughput.toFixed(2)},${sample.averageWaitTime.toFixed(2)},${sample.maxWaitTime.toFixed(2)},${sample.congestionIndex.toFixed(3)},${sample.activeVehicles},${sample.completedTrips}\n`;
            });
        }
        // Download the file
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.setAttribute('href', url);
        link.setAttribute('download', `benchmark-${benchmark.name.replace(/[^a-z0-9]/gi, '_').toLowerCase()}-${new Date().toISOString().slice(0, 10)}.csv`);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        this.showToast('CSV exported successfully', 'success');
    }
    /**
     * Export current benchmark data as JSON
     */
    exportJSON() {
        if (!this.currentBenchmark)
            return;
        const exportData = {
            metadata: {
                exportTimestamp: new Date().toISOString(),
                version: '1.0.0',
                description: 'Traffic Simulation Benchmark Results'
            },
            benchmark: this.currentBenchmark
        };
        const json = JSON.stringify(exportData, null, 2);
        const blob = new Blob([json], { type: 'application/json;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.setAttribute('href', url);
        link.setAttribute('download', `benchmark-${this.currentBenchmark.name.replace(/[^a-z0-9]/gi, '_').toLowerCase()}-${new Date().toISOString().slice(0, 10)}.json`);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        this.showToast('JSON exported successfully', 'success');
    }
    /**
     * Show comparison panel
     */
    showComparisonPanel() {
        const panel = document.getElementById('comparison-panel');
        const select = document.getElementById('comparison-benchmark');
        // Populate comparison options
        select.innerHTML = '<option value="">Select benchmark to compare...</option>';
        this.benchmarkHistory.forEach(benchmark => {
            var _a;
            if (benchmark.id !== ((_a = this.currentBenchmark) === null || _a === void 0 ? void 0 : _a.id)) {
                const option = document.createElement('option');
                option.value = benchmark.id;
                option.textContent = `${benchmark.name} (${new Date(benchmark.timestamp).toLocaleDateString()})`;
                select.appendChild(option);
            }
        });
        panel.style.display = 'block';
    }
    /**
     * Show comparison between two benchmarks
     */
    showComparison(compareId) {
        const compareRun = this.benchmarkHistory.find(b => b.id === compareId);
        if (!compareRun || !this.currentBenchmark)
            return;
        const content = document.getElementById('comparison-content');
        const current = this.currentBenchmark.finalMetrics;
        const compare = compareRun.finalMetrics;
        content.innerHTML = `
      <div class="comparison-grid">
        <div class="comparison-section">
          <h5>Performance Comparison</h5>
          <table class="comparison-table">
            <thead>
              <tr>
                <th>Metric</th>
                <th>Current</th>
                <th>Compare</th>
                <th>Difference</th>
              </tr>
            </thead>
            <tbody>
              ${this.renderComparisonRow('Average Speed (m/s)', current.averageSpeed, compare.averageSpeed, true)}
              ${this.renderComparisonRow('Global Throughput (veh/min)', current.globalThroughput, compare.globalThroughput, true)}
              ${this.renderComparisonRow('Average Wait Time (s)', current.averageWaitTime, compare.averageWaitTime, false)}
              ${this.renderComparisonRow('Congestion Index', current.congestionIndex, compare.congestionIndex, false)}
              ${this.renderComparisonRow('Completed Trips', current.completedTrips, compare.completedTrips, true)}
              ${this.renderComparisonRow('Total Stops', current.totalStops, compare.totalStops, false)}
            </tbody>
          </table>
        </div>
      </div>
    `;
    }
    /**
     * Render a comparison row for the comparison table
     */
    renderComparisonRow(label, current, compare, higherIsBetter) {
        const diff = current - compare;
        const diffPercent = compare !== 0 ? (diff / compare) * 100 : 0;
        const isPositive = diff > 0;
        const isBetter = higherIsBetter ? isPositive : !isPositive;
        const diffClass = diff === 0 ? 'neutral' : (isBetter ? 'positive' : 'negative');
        const diffSymbol = diff > 0 ? '+' : '';
        return `
      <tr>
        <td>${label}</td>
        <td>${current.toFixed(2)}</td>
        <td>${compare.toFixed(2)}</td>
        <td class="diff-${diffClass}">
          ${diffSymbol}${diff.toFixed(2)} (${diffSymbol}${diffPercent.toFixed(1)}%)
        </td>
      </tr>
    `;
    }
    /**
     * Show validation panel
     */
    showValidationPanel() {
        const panel = document.getElementById('validation-panel');
        const content = document.getElementById('validation-content');
        if (this.currentBenchmark && this.currentBenchmark.validation) {
            content.innerHTML = this.currentBenchmark.validation;
        }
        else {
            content.innerHTML = '<div class="validation-message">No validation data available</div>';
        }
        panel.style.display = 'block';
    }
    /**
     * Add benchmark to history
     */
    addToBenchmarkHistory(benchmark) {
        // Remove existing entry with same ID
        this.benchmarkHistory = this.benchmarkHistory.filter(b => b.id !== benchmark.id);
        // Add to beginning of array
        this.benchmarkHistory.unshift(benchmark);
        // Keep only last 10 runs
        if (this.benchmarkHistory.length > 10) {
            this.benchmarkHistory = this.benchmarkHistory.slice(0, 10);
        }
        // Save to localStorage
        this.saveBenchmarkHistory();
    }
    /**
     * Load benchmark history from localStorage
     */
    loadBenchmarkHistory() {
        try {
            const stored = localStorage.getItem('kpi_benchmark_history');
            if (stored) {
                this.benchmarkHistory = JSON.parse(stored);
            }
        }
        catch (error) {
            console.warn('Failed to load benchmark history:', error);
            this.benchmarkHistory = [];
        }
    }
    /**
     * Save benchmark history to localStorage
     */
    saveBenchmarkHistory() {
        try {
            localStorage.setItem('kpi_benchmark_history', JSON.stringify(this.benchmarkHistory));
        }
        catch (error) {
            console.warn('Failed to save benchmark history:', error);
        }
    }
    /**
     * Show toast notification
     */
    showToast(message, type = 'info') {
        // Create toast container if it doesn't exist
        let container = document.getElementById('toast-container');
        if (!container) {
            container = document.createElement('div');
            container.id = 'toast-container';
            container.style.position = 'fixed';
            container.style.top = '20px';
            container.style.right = '20px';
            container.style.zIndex = '10000';
            document.body.appendChild(container);
        }
        // Create toast
        const toast = document.createElement('div');
        toast.className = `toast toast-${type}`;
        toast.textContent = message;
        toast.style.backgroundColor = type === 'success' ? '#4CAF50' : type === 'error' ? '#F44336' : '#2196F3';
        toast.style.color = '#fff';
        toast.style.padding = '12px 20px';
        toast.style.marginBottom = '10px';
        toast.style.borderRadius = '4px';
        toast.style.boxShadow = '0 2px 10px rgba(0,0,0,0.2)';
        toast.style.transition = 'all 0.3s ease';
        container.appendChild(toast);
        // Auto-remove after 3 seconds
        setTimeout(() => {
            toast.style.opacity = '0';
            setTimeout(() => toast.remove(), 300);
        }, 3000);
    }
    /**
     * Destroy the component and clean up resources
     */
    destroy() {
        // Destroy all charts
        Object.values(this.charts).forEach(chart => {
            chart.destroy();
        });
        this.charts = {};
        // Clear container
        this.container.innerHTML = '';
    }
}
exports.KPIVisualizationComponent = KPIVisualizationComponent;


/***/ }),

/***/ "./src/components/NavigationComponent.ts":
/*!***********************************************!*\
  !*** ./src/components/NavigationComponent.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NavigationComponent = void 0;
/**
 * Navigation bar component for switching between builder and simulation
 */
class NavigationComponent {
    constructor(container, router) {
        this.container = container;
        this.router = router;
        this.render();
    }
    render() {
        console.log('🧭 [NAV] Rendering navigation bar');
        // Ensure container is empty before rendering
        this.container.innerHTML = '';
        this.container.innerHTML = `
      <nav class="navbar">
        <div class="nav-container">
          <div class="nav-brand">
            <h1>Traffic Simulator</h1>
          </div>
          
          <div class="nav-links">
            <a href="/" class="nav-link" data-route="/">
              🏠 Home
            </a>
            
            <a href="/builder" class="nav-link" data-route="/builder">
              🏗️ Builder
            </a>
            
            <a href="/simulation" class="nav-link" data-route="/simulation">
              🚦 Simulation
            </a>
          </div>
        </div>
      </nav>
    `;
        // Add click handlers
        this.container.querySelectorAll('[data-route]').forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const route = e.target.getAttribute('data-route') || '/';
                this.router.navigate(route);
                this.updateActiveLink(route);
            });
        });
        // Set initial active state
        this.updateActiveLink(this.router.getCurrentRoute());
        // Add styles
        this.addStyles();
    }
    updateActiveLink(currentRoute) {
        this.container.querySelectorAll('.nav-link').forEach(link => {
            link.classList.remove('active');
        });
        const activeLink = this.container.querySelector(`[data-route="${currentRoute}"]`);
        if (activeLink) {
            activeLink.classList.add('active');
        }
    }
    addStyles() {
        if (!document.getElementById('navbar-styles')) {
            const style = document.createElement('style');
            style.id = 'navbar-styles';
            style.textContent = `
        .navbar {
          background: #2d2d2d;
          color: white;
          padding: 0;
          box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
          position: relative;
          z-index: 1000;
          border-bottom: 1px solid #404040;
        }
        
        .nav-container {
          display: flex;
          justify-content: space-between;
          align-items: center;
          max-width: 1200px;
          margin: 0 auto;
          padding: 0 20px;
          height: 60px;
        }
        
        .nav-brand h1 {
          margin: 0;
          font-size: 1.5rem;
          font-weight: 600;
          color: #ffffff;
        }
        
        .nav-links {
          display: flex;
          gap: 20px;
        }
        
        .nav-link {
          color: rgba(255, 255, 255, 0.9);
          text-decoration: none;
          padding: 10px 20px;
          border-radius: 8px;
          transition: all 0.3s ease;
          font-weight: 500;
          font-size: 1rem;
          display: flex;
          align-items: center;
          gap: 8px;
        }
        
        .nav-link:hover {
          background: #404040;
          color: white;
          transform: translateY(-1px);
        }
        
        .nav-link.active {
          background: #007bff;
          color: white;
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        @media (max-width: 768px) {
          .nav-container {
            padding: 0 15px;
          }
          
          .nav-brand h1 {
            font-size: 1.2rem;
          }
          
          .nav-links {
            gap: 10px;
          }
          
          .nav-link {
            padding: 8px 15px;
            font-size: 0.9rem;
          }
        }
      `;
            document.head.appendChild(style);
        }
    }
}
exports.NavigationComponent = NavigationComponent;


/***/ }),

/***/ "./src/core/AppState.ts":
/*!******************************!*\
  !*** ./src/core/AppState.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.appState = void 0;
const LocalStorage_1 = __webpack_require__(/*! ../lib/storage/LocalStorage */ "./src/lib/storage/LocalStorage.ts");
/**
 * Simple state management for the application
 */
class AppState {
    constructor() {
        this._currentPage = 'builder';
        this._storage = new LocalStorage_1.LocalStorage();
        this._listeners = {};
        this._selectedLayoutId = null;
    }
    get currentPage() {
        return this._currentPage;
    }
    set currentPage(page) {
        const oldPage = this._currentPage;
        this._currentPage = page;
        this.emit('pageChanged', { oldPage, newPage: page });
    }
    get storage() {
        return this._storage;
    }
    setStorage(storage) {
        this._storage = storage;
        this.emit('storageChanged', storage);
    }
    get selectedLayoutId() {
        return this._selectedLayoutId;
    }
    set selectedLayoutId(layoutId) {
        this._selectedLayoutId = layoutId;
        this.emit('selectedLayoutChanged', layoutId);
    }
    on(event, callback) {
        if (!this._listeners[event]) {
            this._listeners[event] = [];
        }
        this._listeners[event].push(callback);
    }
    emit(event, data) {
        if (this._listeners[event]) {
            this._listeners[event].forEach(callback => callback(data));
        }
    }
}
exports.appState = new AppState();


/***/ }),

/***/ "./src/core/Router.ts":
/*!****************************!*\
  !*** ./src/core/Router.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Router = void 0;
/**
 * Simple router for single-page application
 */
class Router {
    constructor() {
        this.routes = {};
        this.currentRoute = '/';
        this.init();
    }
    addRoute(path, handler) {
        this.routes[path] = handler;
    }
    navigate(path) {
        console.log(`Router attempting to navigate to: ${path}`);
        if (this.routes[path]) {
            console.log(`Route handler found for ${path}, updating state and history`);
            this.currentRoute = path;
            window.history.pushState({ path }, '', path);
            try {
                this.routes[path]();
                console.log(`Successfully navigated to ${path}`);
            }
            catch (error) {
                console.error(`Error executing route handler for ${path}:`, error);
            }
        }
        else {
            console.warn(`No route handler registered for path: ${path}`);
        }
    }
    getCurrentRoute() {
        return this.currentRoute;
    }
    init() {
        // Handle browser back/forward buttons
        window.addEventListener('popstate', (event) => {
            var _a;
            const path = ((_a = event.state) === null || _a === void 0 ? void 0 : _a.path) || '/';
            if (this.routes[path]) {
                this.currentRoute = path;
                this.routes[path]();
            }
        });
        // Handle initial route - always start at home
        const path = window.location.pathname;
        this.currentRoute = '/'; // Always start at home page
        // If user directly navigates to a specific page, redirect to home
        if (path !== '/') {
            window.history.replaceState({ path: '/' }, '', '/');
        }
    }
    start() {
        if (this.routes[this.currentRoute]) {
            this.routes[this.currentRoute]();
        }
    }
}
exports.Router = Router;


/***/ }),

/***/ "./src/geom/curve.ts":
/*!***************************!*\
  !*** ./src/geom/curve.ts ***!
  \***************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! ../helpers */ "./src/helpers.ts");
const Segment = __webpack_require__(/*! ./segment */ "./src/geom/segment.ts");
class Curve {
    constructor(A, B, O, Q) {
        this.A = A;
        this.B = B;
        this.O = O;
        this.Q = Q;
        this.AB = new Segment(this.A, this.B);
        this.AO = new Segment(this.A, this.O);
        this.OQ = new Segment(this.O, this.Q);
        this.QB = new Segment(this.Q, this.B);
        this._length = null;
    }
    get length() {
        if (this._length == null) {
            const pointsNumber = 10;
            let previousPoint = null;
            this._length = 0;
            for (let i = 0; i <= pointsNumber; i++) {
                const point = this.getPoint(i / pointsNumber);
                if (previousPoint) {
                    this._length += point.subtract(previousPoint).length;
                }
                previousPoint = point;
            }
        }
        return this._length;
    }
    getPoint(a) {
        // OPTIMIZE avoid points and segments
        const p0 = this.AO.getPoint(a);
        const p1 = this.OQ.getPoint(a);
        const p2 = this.QB.getPoint(a);
        const r0 = (new Segment(p0, p1)).getPoint(a);
        const r1 = (new Segment(p1, p2)).getPoint(a);
        return (new Segment(r0, r1)).getPoint(a);
    }
    getDirection(a) {
        // OPTIMIZE avoid points and segments
        const p0 = this.AO.getPoint(a);
        const p1 = this.OQ.getPoint(a);
        const p2 = this.QB.getPoint(a);
        const r0 = (new Segment(p0, p1)).getPoint(a);
        const r1 = (new Segment(p1, p2)).getPoint(a);
        return (new Segment(r0, r1)).direction;
    }
}
// Set up properties using the CoffeeScript-style property decorator
Curve.property('length', {
    get: function () {
        if (this._length == null) {
            const pointsNumber = 10;
            let previousPoint = null;
            this._length = 0;
            for (let i = 0; i <= pointsNumber; i++) {
                const point = this.getPoint(i / pointsNumber);
                if (previousPoint) {
                    this._length += point.subtract(previousPoint).length;
                }
                previousPoint = point;
            }
        }
        return this._length;
    }
});
module.exports = Curve;


/***/ }),

/***/ "./src/geom/point.ts":
/*!***************************!*\
  !*** ./src/geom/point.ts ***!
  \***************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! ../helpers */ "./src/helpers.ts");
const { sqrt, atan2 } = Math;
class Point {
    constructor(x = 0, y = 0) {
        this.x = x;
        this.y = y;
    }
    get length() {
        return sqrt(this.x * this.x + this.y * this.y);
    }
    get direction() {
        return atan2(this.y, this.x);
    }
    get normalized() {
        return new Point(this.x / this.length, this.y / this.length);
    }
    add(o) {
        return new Point(this.x + o.x, this.y + o.y);
    }
    subtract(o) {
        return new Point(this.x - o.x, this.y - o.y);
    }
    mult(k) {
        return new Point(this.x * k, this.y * k);
    }
    divide(k) {
        return new Point(this.x / k, this.y / k);
    }
}
Point.property = Function.prototype.property;
// Set up properties using the CoffeeScript-style property decorator
Point.property('length', {
    get: function () {
        return sqrt(this.x * this.x + this.y * this.y);
    }
});
Point.property('direction', {
    get: function () {
        return atan2(this.y, this.x);
    }
});
Point.property('normalized', {
    get: function () {
        return new Point(this.x / this.length, this.y / this.length);
    }
});
module.exports = Point;


/***/ }),

/***/ "./src/geom/rect.ts":
/*!**************************!*\
  !*** ./src/geom/rect.ts ***!
  \**************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! ../helpers */ "./src/helpers.ts");
const _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/modules/index-all.js");
const Point = __webpack_require__(/*! ./point */ "./src/geom/point.ts");
const Segment = __webpack_require__(/*! ./segment */ "./src/geom/segment.ts");
const { abs } = Math;
class Rect {
    constructor(x, y, _width = 0, _height = 0) {
        this.x = x;
        this.y = y;
        this._width = _width;
        this._height = _height;
    }
    static copy(rect) {
        return new Rect(rect.x, rect.y, rect._width, rect._height);
    }
    toJSON() {
        return _.extend({}, this);
    }
    area() {
        return this.width() * this.height();
    }
    left(left) {
        if (left !== undefined) {
            this.x = left;
        }
        return this.x;
    }
    right(right) {
        if (right !== undefined) {
            this.x = right - this.width();
        }
        return this.x + this.width();
    }
    width(width) {
        if (width !== undefined) {
            this._width = width;
        }
        return this._width;
    }
    top(top) {
        if (top !== undefined) {
            this.y = top;
        }
        return this.y;
    }
    bottom(bottom) {
        if (bottom !== undefined) {
            this.y = bottom - this.height();
        }
        return this.y + this.height();
    }
    height(height) {
        if (height !== undefined) {
            this._height = height;
        }
        return this._height;
    }
    center(center) {
        if (center) {
            this.x = center.x - this.width() / 2;
            this.y = center.y - this.height() / 2;
        }
        return new Point(this.x + this.width() / 2, this.y + this.height() / 2);
    }
    containsPoint(point) {
        return this.left() <= point.x && point.x <= this.right() &&
            this.top() <= point.y && point.y <= this.bottom();
    }
    containsRect(rect) {
        return this.left() <= rect.left() && rect.right() <= this.right() &&
            this.top() <= rect.top() && rect.bottom() <= this.bottom();
    }
    getVertices() {
        return [
            new Point(this.left(), this.top()),
            new Point(this.right(), this.top()),
            new Point(this.right(), this.bottom()),
            new Point(this.left(), this.bottom()),
        ];
    }
    getSide(i) {
        const vertices = this.getVertices();
        return new Segment(vertices[i], vertices[(i + 1) % 4]);
    }
    getSectorId(point) {
        const offset = point.subtract(this.center());
        if (offset.y <= 0 && abs(offset.x) <= abs(offset.y)) {
            return 0;
        }
        if (offset.x >= 0 && abs(offset.x) >= abs(offset.y)) {
            return 1;
        }
        if (offset.y >= 0 && abs(offset.x) <= abs(offset.y)) {
            return 2;
        }
        if (offset.x <= 0 && abs(offset.x) >= abs(offset.y)) {
            return 3;
        }
        throw new Error('algorithm error');
    }
    getSector(point) {
        return this.getSide(this.getSectorId(point));
    }
}
module.exports = Rect;


/***/ }),

/***/ "./src/geom/segment.ts":
/*!*****************************!*\
  !*** ./src/geom/segment.ts ***!
  \*****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! ../helpers */ "./src/helpers.ts");
class Segment {
    constructor(source, target) {
        this.source = source;
        this.target = target;
    }
    get vector() {
        return this.target.subtract(this.source);
    }
    get length() {
        return this.vector.length;
    }
    get direction() {
        return this.vector.direction;
    }
    get center() {
        return this.getPoint(0.5);
    }
    split(n, reverse) {
        const order = reverse ?
            Array.from({ length: n }, (_, i) => n - 1 - i) :
            Array.from({ length: n }, (_, i) => i);
        return order.map(k => this.subsegment(k / n, (k + 1) / n));
    }
    getPoint(a) {
        return this.source.add(this.vector.mult(a));
    }
    subsegment(a, b) {
        const offset = this.vector;
        const start = this.source.add(offset.mult(a));
        const end = this.source.add(offset.mult(b));
        return new Segment(start, end);
    }
}
// Set up properties using the CoffeeScript-style property decorator
Segment.property('vector', {
    get: function () {
        return this.target.subtract(this.source);
    }
});
Segment.property('length', {
    get: function () {
        return this.vector.length;
    }
});
Segment.property('direction', {
    get: function () {
        return this.vector.direction;
    }
});
Segment.property('center', {
    get: function () {
        return this.getPoint(0.5);
    }
});
module.exports = Segment;


/***/ }),

/***/ "./src/helpers.ts":
/*!************************!*\
  !*** ./src/helpers.ts ***!
  \************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// TypeScript equivalent of CoffeeScript property decorator functionality
Object.defineProperty(exports, "__esModule", ({ value: true }));
Function.prototype.property = function (prop, desc) {
    Object.defineProperty(this.prototype, prop, desc);
};


/***/ }),

/***/ "./src/lib/storage/LocalStorage.ts":
/*!*****************************************!*\
  !*** ./src/lib/storage/LocalStorage.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LocalStorage = void 0;
/**
 * Local storage implementation of the storage interface
 * Uses browser localStorage for data persistence
 */
class LocalStorage {
    constructor() {
        this.LAYOUT_KEY = 'traffic_simulator_layouts';
        this.ANALYTICS_KEY = 'traffic_simulator_analytics';
        this.CURRENT_LAYOUT_KEY = 'traffic_simulator_current_layout';
        this.SCENARIO_KEY = 'traffic_simulator_scenarios';
    }
    async saveLayout(layout, layoutName) {
        try {
            // Only add to layouts collection - don't auto-save as current layout
            const layouts = await this.loadAllLayouts();
            const newLayout = {
                id: `layout_${Date.now()}`,
                name: layoutName || `Layout ${new Date().toLocaleString()}`,
                data: layout,
                createdAt: new Date().toISOString()
            };
            layouts.push(newLayout);
            localStorage.setItem(this.LAYOUT_KEY, JSON.stringify(layouts));
        }
        catch (error) {
            console.error('Failed to save layout:', error);
            throw new Error('Failed to save layout to local storage');
        }
    }
    async loadLayout() {
        try {
            const data = localStorage.getItem(this.CURRENT_LAYOUT_KEY);
            return data ? JSON.parse(data) : null;
        }
        catch (error) {
            console.error('Failed to load layout:', error);
            return null;
        }
    }
    async loadAllLayouts() {
        try {
            const data = localStorage.getItem(this.LAYOUT_KEY);
            return data ? JSON.parse(data) : [];
        }
        catch (error) {
            console.error('Failed to load layouts:', error);
            return [];
        }
    }
    async saveAnalytics(data) {
        try {
            const analytics = await this.loadAnalytics();
            const newAnalytics = {
                id: `analytics_${Date.now()}`,
                timestamp: new Date().toISOString(),
                data: data
            };
            analytics.push(newAnalytics);
            localStorage.setItem(this.ANALYTICS_KEY, JSON.stringify(analytics));
        }
        catch (error) {
            console.error('Failed to save analytics:', error);
            throw new Error('Failed to save analytics to local storage');
        }
    }
    async loadAnalytics() {
        try {
            const data = localStorage.getItem(this.ANALYTICS_KEY);
            return data ? JSON.parse(data) : [];
        }
        catch (error) {
            console.error('Failed to load analytics:', error);
            return [];
        }
    }
    async saveScenario(scenario, scenarioName) {
        try {
            const scenarios = await this.loadAllScenarios();
            const newScenario = {
                id: `scenario_${Date.now()}`,
                name: scenarioName || `Scenario ${new Date().toLocaleString()}`,
                data: scenario,
                createdAt: new Date().toISOString()
            };
            scenarios.push(newScenario);
            localStorage.setItem(this.SCENARIO_KEY, JSON.stringify(scenarios));
        }
        catch (error) {
            console.error('Failed to save scenario:', error);
            throw new Error('Failed to save scenario to local storage');
        }
    }
    async loadScenario(id) {
        try {
            console.log(`LocalStorage: Loading scenario with ID: ${id}`);
            const scenarios = await this.loadAllScenarios();
            console.log(`LocalStorage: Found ${scenarios.length} total scenarios`);
            console.log('LocalStorage: Available scenario IDs:', scenarios.map(s => s.id));
            const scenario = scenarios.find(s => s.id === id);
            if (!scenario) {
                console.error(`LocalStorage: No scenario found with ID: ${id}`);
                return null;
            }
            console.log(`LocalStorage: Found scenario: ${scenario.name}`);
            // Ensure data exists
            if (!scenario.data) {
                console.error(`LocalStorage: Scenario ${id} has no data property`);
                return null;
            }
            return scenario.data;
        }
        catch (error) {
            console.error('LocalStorage: Failed to load scenario:', error);
            return null;
        }
    }
    async loadAllScenarios() {
        try {
            const data = localStorage.getItem(this.SCENARIO_KEY);
            return data ? JSON.parse(data) : [];
        }
        catch (error) {
            console.error('Failed to load scenarios:', error);
            return [];
        }
    }
    async deleteScenario(id) {
        try {
            // Get current scenarios
            const scenarios = await this.loadAllScenarios();
            // Filter out the scenario to delete
            const updatedScenarios = scenarios.filter(s => s.id !== id);
            // Save the updated list back to localStorage
            localStorage.setItem(this.SCENARIO_KEY, JSON.stringify(updatedScenarios));
        }
        catch (error) {
            console.error('Failed to delete scenario:', error);
            throw new Error('Failed to delete scenario from local storage');
        }
    }
    async clear() {
        try {
            localStorage.removeItem(this.LAYOUT_KEY);
            localStorage.removeItem(this.ANALYTICS_KEY);
            localStorage.removeItem(this.CURRENT_LAYOUT_KEY);
            localStorage.removeItem(this.SCENARIO_KEY);
            // Keep the legacy 'world' key for now
        }
        catch (error) {
            console.error('Failed to clear storage:', error);
            throw new Error('Failed to clear local storage');
        }
    }
}
exports.LocalStorage = LocalStorage;


/***/ }),

/***/ "./src/model/car.ts":
/*!**************************!*\
  !*** ./src/model/car.ts ***!
  \**************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! ../helpers */ "./src/helpers.ts");
const _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/modules/index-all.js");
const Trajectory = __webpack_require__(/*! ./trajectory */ "./src/model/trajectory.ts");
const kpi_collector_1 = __webpack_require__(/*! ./kpi-collector */ "./src/model/kpi-collector.ts");
const { max, min, random, sqrt } = Math;
class Car {
    // Static method to update world time from World class
    static updateWorldTime(time) {
        Car.worldTime = time;
    }
    // Get current world time
    static getWorldTime() {
        return Car.worldTime;
    }
    constructor(lane, position) {
        this.id = _.uniqueId('car');
        this.color = (300 + 240 * random()) % 360;
        this._speed = 0;
        this.width = 1.7;
        this.length = 3 + 2 * random();
        // IDM parameters - exactly as reference implementation
        this.maxSpeed = 30;
        this.s0 = 2;
        this.timeHeadway = 1.5;
        this.maxAcceleration = 1;
        this.maxDeceleration = 3;
        this.trajectory = new Trajectory(this, lane, position);
        this.alive = true;
        this.preferedLane = null;
        this.nextLane = null;
        // Notify KPI collector when a new car enters the simulation
        kpi_collector_1.kpiCollector.recordVehicleEnter(this, Car.worldTime);
        // Record initial lane entry
        kpi_collector_1.kpiCollector.recordLaneEnter(this, lane, Car.worldTime);
    }
    static copy(car) {
        const result = Object.create(Car.prototype);
        _.extend(result, car);
        return result;
    }
    get coords() {
        return this.trajectory.coords;
    }
    get speed() {
        return this._speed;
    }
    set speed(speed) {
        if (speed < 0)
            speed = 0;
        if (speed > this.maxSpeed)
            speed = this.maxSpeed;
        // Track significant speed changes for KPI collection
        // We only record changes greater than 20% of max speed to avoid flooding with minor changes
        if (Math.abs(speed - this._speed) > (this.maxSpeed * 0.2)) {
            kpi_collector_1.kpiCollector.recordSpeedChange(this, Car.worldTime, this._speed, speed);
            // If car is in a lane, update lane speed metrics
            if (this.trajectory && this.trajectory.current && this.trajectory.current.lane) {
                kpi_collector_1.kpiCollector.updateLaneSpeedMetrics(this, this.trajectory.current.lane.id, speed);
            }
        }
        this._speed = speed;
    }
    get direction() {
        return this.trajectory.direction;
    }
    release() {
        // Record exit from current lane
        if (this.trajectory && this.trajectory.current && this.trajectory.current.lane) {
            kpi_collector_1.kpiCollector.recordLaneExit(this, this.trajectory.current.lane, Car.worldTime);
        }
        // Notify KPI collector that a car is exiting the simulation
        kpi_collector_1.kpiCollector.recordVehicleExit(this, Car.worldTime);
        this.trajectory.release();
    }
    // Calculate acceleration based on Intelligent Driver Model (exact reference implementation)
    getAcceleration() {
        var _a;
        // Get the distance to the next car ahead
        const nextCarDistance = this.trajectory.nextCarDistance;
        const distanceToNextCar = max(nextCarDistance.distance, 0);
        // IDM parameters - directly from reference
        const a = this.maxAcceleration;
        const b = this.maxDeceleration;
        // Calculate relative speed difference
        const deltaSpeed = (this.speed - (((_a = nextCarDistance.car) === null || _a === void 0 ? void 0 : _a.speed) || 0));
        // === INTELLIGENT DRIVER MODEL (IDM) CALCULATION - Reference Implementation ===
        // 1. Free road coefficient - (v/v_0)^4
        const freeRoadCoeff = Math.pow(this.speed / this.maxSpeed, 4);
        // 2. Calculate desired safe following distance
        const distanceGap = this.s0; // Minimum gap when stopped
        const timeGap = this.speed * this.timeHeadway; // Time headway component
        const breakGap = this.speed * deltaSpeed / (2 * sqrt(a * b)); // Breaking gap component
        const safeDistance = distanceGap + timeGap + breakGap;
        // 3. Calculate interaction coefficient with leading vehicle
        const busyRoadCoeff = Math.pow(safeDistance / distanceToNextCar, 2);
        // 4. Intersection handling - exactly as reference
        const safeIntersectionDistance = 1 + timeGap + Math.pow(this.speed, 2) / (2 * b);
        const intersectionCoeff = Math.pow(safeIntersectionDistance / this.trajectory.distanceToStopLine, 2);
        // 5. Calculate final acceleration coefficient
        const coeff = 1 - freeRoadCoeff - busyRoadCoeff - intersectionCoeff;
        // Return the final acceleration
        return this.maxAcceleration * coeff;
    }
    move(delta) {
        // Calculate acceleration using the Intelligent Driver Model
        const acceleration = this.getAcceleration();
        // Get previous speed for change detection
        const previousSpeed = this._speed;
        // Update speed based on acceleration
        this.speed += acceleration * delta;
        // Check for stop/start events for KPI collection
        if (previousSpeed > 0.1 && this._speed <= 0.1) {
            // Vehicle has stopped
            kpi_collector_1.kpiCollector.recordVehicleStop(this, Car.worldTime);
        }
        else if (previousSpeed <= 0.1 && this._speed > 0.1) {
            // Vehicle has started moving
            kpi_collector_1.kpiCollector.recordVehicleStart(this, Car.worldTime);
        }
        // === LANE CHANGING LOGIC (exactly from reference) ===
        if (!this.trajectory.isChangingLanes && this.nextLane) {
            const currentLane = this.trajectory.current.lane;
            const turnNumber = currentLane.getTurnDirection(this.nextLane);
            // Choose preferred lane based on turn direction (exactly from reference)
            let preferedLane;
            switch (turnNumber) {
                case 0: // Left turn
                    preferedLane = currentLane.leftmostAdjacent;
                    break;
                case 2: // Right turn
                    preferedLane = currentLane.rightmostAdjacent;
                    break;
                default: // Forward
                    preferedLane = currentLane;
            }
            // Attempt lane change if not in preferred lane
            if (preferedLane !== currentLane) {
                const previousLane = this.trajectory.current.lane;
                try {
                    // Record exit from previous lane before changing
                    kpi_collector_1.kpiCollector.recordLaneExit(this, previousLane, Car.worldTime);
                    this.trajectory.changeLane(preferedLane);
                    // If lane change was successful
                    if (this.trajectory.current.lane !== previousLane) {
                        // Record lane change and entry into new lane
                        kpi_collector_1.kpiCollector.recordLaneChange(this, Car.worldTime);
                        kpi_collector_1.kpiCollector.recordLaneEnter(this, this.trajectory.current.lane, Car.worldTime);
                    }
                    else {
                        // If lane change failed, re-enter the previous lane
                        kpi_collector_1.kpiCollector.recordLaneEnter(this, previousLane, Car.worldTime);
                    }
                }
                catch (error) {
                    // Lane change failed, continue in current lane
                }
            }
        }
        // Calculate distance to travel in this step
        const step = this.speed * delta + 0.5 * acceleration * delta * delta;
        // Debug IDM behavior as in reference (only in debug mode)
        if (this.trajectory.nextCarDistance.distance < step) {
            // console.log('bad IDM'); // Commented out to prevent console spam
        }
        // Check if we need to make a turn at intersection
        if (this.trajectory.timeToMakeTurn(step)) {
            // If no next lane available, car dies (reaches destination)
            if (!this.nextLane) {
                this.alive = false;
                return;
            }
        }
        // Move forward
        this.trajectory.moveForward(step);
    }
    // Select a road to turn to at the next intersection (directly from reference)
    pickNextRoad() {
        const intersection = this.trajectory.nextIntersection;
        const currentLane = this.trajectory.current.lane;
        // Filter possible roads to avoid U-turns (directly from reference)
        const possibleRoads = intersection.roads.filter((road) => road.target !== currentLane.road.source);
        // If no roads available, return null (car will be despawned)
        if (possibleRoads.length === 0) {
            return null;
        }
        // Randomly select a road (directly from reference)
        return _.sample(possibleRoads);
    }
    // Choose the next lane based on where we want to turn
    pickNextLane() {
        // Make sure we don't already have a next lane (directly from reference)
        if (this.nextLane) {
            throw Error('next lane is already chosen');
        }
        // Reset next lane and preferred lane references
        this.nextLane = null;
        this.preferedLane = null;
        // Get the next road to turn into
        const nextRoad = this.pickNextRoad();
        // If no road is available, return null - car will be marked not alive
        if (!nextRoad) {
            return null;
        }
        // Choose lane based on the turn we're about to make (directly from reference)
        const turnNumber = this.trajectory.current.lane.road.getTurnDirection(nextRoad);
        let laneNumber;
        switch (turnNumber) {
            case 0: // Left turn - use leftmost lane
                laneNumber = nextRoad.lanesNumber - 1;
                break;
            case 1: // Straight - use a random lane
                laneNumber = _.random(0, nextRoad.lanesNumber - 1);
                break;
            case 2: // Right turn - use rightmost lane
                laneNumber = 0;
                break;
            default:
                laneNumber = 0;
        }
        // Set the next lane
        this.nextLane = nextRoad.lanes[laneNumber];
        // Verify that we have a valid lane
        if (!this.nextLane) {
            throw Error('cannot pick next lane');
        }
        return this.nextLane;
    }
    // Return the next lane and clear the stored reference (directly from reference)
    popNextLane() {
        const nextLane = this.nextLane;
        this.nextLane = null;
        this.preferedLane = null;
        return nextLane;
    }
}
// Track world time for KPI reporting
Car.worldTime = 0;
// Set up properties using the CoffeeScript-style property decorator
Car.property('coords', {
    get: function () {
        return this.trajectory.coords;
    }
});
Car.property('speed', {
    get: function () {
        return this._speed;
    },
    set: function (speed) {
        if (speed < 0)
            speed = 0;
        if (speed > this.maxSpeed)
            speed = this.maxSpeed;
        // Track significant speed changes for KPI collection
        // We only record changes greater than 20% of max speed to avoid flooding with minor changes
        if (Math.abs(speed - this._speed) > (this.maxSpeed * 0.2)) {
            kpi_collector_1.kpiCollector.recordSpeedChange(this, Car.worldTime, this._speed, speed);
        }
        this._speed = speed;
    }
});
Car.property('direction', {
    get: function () {
        return this.trajectory.direction;
    }
});
// Set up properties using the CoffeeScript-style property decorator
Car.property('coords', {
    get: function () {
        return this.trajectory.coords;
    }
});
Car.property('speed', {
    get: function () {
        return this._speed;
    },
    set: function (speed) {
        if (speed < 0)
            speed = 0;
        if (speed > this.maxSpeed)
            speed = this.maxSpeed;
        // Track significant speed changes for KPI collection
        // We only record changes greater than 20% of max speed to avoid flooding with minor changes
        if (Math.abs(speed - this._speed) > (this.maxSpeed * 0.2)) {
            kpi_collector_1.kpiCollector.recordSpeedChange(this, Car.worldTime, this._speed, speed);
        }
        this._speed = speed;
    }
});
Car.property('direction', {
    get: function () {
        return this.trajectory.direction;
    }
});
module.exports = Car;


/***/ }),

/***/ "./src/model/control-signals.ts":
/*!**************************************!*\
  !*** ./src/model/control-signals.ts ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! ../helpers */ "./src/helpers.ts");
const settings = __webpack_require__(/*! ../settings */ "./src/settings.ts");
const { random } = Math;
class ControlSignals {
    constructor(intersection) {
        // Traffic signal patterns for intersections
        // 'L' = Left turn, 'F' = Forward, 'R' = Right turn
        // Each array represents a phase of the traffic light cycle
        // Each element in the array represents a direction (N, E, S, W)
        this.states = [
            ['L', '', 'L', ''],
            ['FR', '', 'FR', ''],
            ['', 'L', '', 'L'],
            ['', 'FR', '', 'FR'] // Phase 4: East & West forward and right
        ];
        // Update the traffic light state based on elapsed time
        this.onTick = (delta) => {
            // Update timer
            this.time += delta;
            // When the interval is reached, change the light
            if (this.time > this.lastFlipTime + this.flipInterval) {
                this.flip();
            }
        };
        this.intersection = intersection;
        this.flipMultiplier = random(); // Randomize cycle timing for variety
        this.phaseOffset = 100 * random(); // Randomize starting phase
        this.time = this.phaseOffset;
        this.stateNum = 0;
        this.lastFlipTime = 0;
    }
    static copy(controlSignals, intersection) {
        if (!controlSignals) {
            return new ControlSignals(intersection);
        }
        // Create a proper instance with the correct prototype
        const result = new ControlSignals(intersection);
        // Copy over the data properties
        result.flipMultiplier = controlSignals.flipMultiplier || Math.random();
        result.phaseOffset = controlSignals.phaseOffset || 100 * Math.random();
        result.time = result.phaseOffset;
        result.stateNum = controlSignals.stateNum || 0;
        result.lastFlipTime = 0;
        // Ensure we have the proper states array if it was serialized
        result.states = controlSignals.states || [
            ['L', '', 'L', ''],
            ['FR', '', 'FR', ''],
            ['', 'L', '', 'L'],
            ['', 'FR', '', 'FR']
        ];
        return result;
    }
    toJSON() {
        return {
            flipMultiplier: this.flipMultiplier,
            phaseOffset: this.phaseOffset,
            stateNum: this.stateNum,
            states: this.states
        };
    }
    // Calculate the interval between light changes based on the flipMultiplier
    get flipInterval() {
        // This formula matches the reference implementation
        return (0.1 + 0.05 * this.flipMultiplier) * settings.lightsFlipInterval;
    }
    // Convert string representation to numeric state array
    // e.g., "LFR" -> [1,1,1] (left, forward, right allowed)
    _decode(str) {
        const state = [0, 0, 0];
        if (str.includes('L'))
            state[0] = 1;
        if (str.includes('F'))
            state[1] = 1;
        if (str.includes('R'))
            state[2] = 1;
        return state;
    }
    // Get the current state of all traffic lights
    get state() {
        let stringState = this.states[this.stateNum % this.states.length];
        // For 2-way or T-intersections, always allow all movements
        if (this.intersection.roads && this.intersection.roads.length <= 2) {
            stringState = ['LFR', 'LFR', 'LFR', 'LFR'];
        }
        // Convert string patterns to numeric state arrays
        return stringState.map(x => this._decode(x));
    }
    // Advance to the next traffic light phase
    flip() {
        this.stateNum += 1;
        this.lastFlipTime = this.time;
    }
    /**
     * Reset the control signals to initial state
     */
    reset() {
        this.time = this.phaseOffset;
        this.stateNum = 0;
        this.lastFlipTime = 0;
    }
}
// Traffic light states
ControlSignals.STATE = { RED: 0, GREEN: 1 };
// Set up properties using the CoffeeScript-style property decorator
ControlSignals.property('flipInterval', {
    get: function () {
        return (0.1 + 0.05 * this.flipMultiplier) * settings.lightsFlipInterval;
    }
});
ControlSignals.property('state', {
    get: function () {
        let stringState = this.states[this.stateNum % this.states.length];
        // For 2-way or T-intersections, always allow all movements
        if (this.intersection.roads && this.intersection.roads.length <= 2) {
            stringState = ['LFR', 'LFR', 'LFR', 'LFR'];
        }
        // Convert string patterns to numeric state arrays
        return stringState.map(x => this._decode(x));
    }
});
module.exports = ControlSignals;


/***/ }),

/***/ "./src/model/intersection.ts":
/*!***********************************!*\
  !*** ./src/model/intersection.ts ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! ../helpers */ "./src/helpers.ts");
const _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/modules/index-all.js");
const Rect = __webpack_require__(/*! ../geom/rect */ "./src/geom/rect.ts");
const TrafficLightController = __webpack_require__(/*! ./traffic-control/TrafficLightController */ "./src/model/traffic-control/TrafficLightController.ts");
const ControlSignals = __webpack_require__(/*! ./control-signals */ "./src/model/control-signals.ts"); // Keep for backward compatibility
class Intersection {
    // For backward compatibility
    get controlSignals() {
        console.warn('Deprecated: controlSignals is deprecated. Use trafficLightController instead.');
        return this._legacyControlSignals;
    }
    set controlSignals(value) {
        console.warn('Deprecated: Setting controlSignals is deprecated. Use trafficLightController instead.');
        this._legacyControlSignals = value;
    }
    constructor(rect) {
        this.rect = rect;
        this.id = _.uniqueId('intersection');
        this.roads = [];
        this.inRoads = [];
        // Initialize the traffic light controller
        this.trafficLightController = new TrafficLightController(this);
        // Initialize legacy control signals for backward compatibility
        this._legacyControlSignals = new ControlSignals(this);
    }
    static copy(intersection) {
        intersection.rect = Rect.copy(intersection.rect);
        const result = Object.create(Intersection.prototype);
        _.extend(result, intersection);
        result.roads = [];
        result.inRoads = [];
        // Initialize the traffic light controller with the intersection
        if (intersection.trafficLightController) {
            result.trafficLightController = TrafficLightController.copy(intersection.trafficLightController, result);
        }
        else {
            result.trafficLightController = new TrafficLightController(result);
        }
        // For backward compatibility
        if (intersection.controlSignals) {
            result._legacyControlSignals = ControlSignals.copy(intersection.controlSignals, result);
        }
        else {
            result._legacyControlSignals = new ControlSignals(result);
        }
        return result;
    }
    toJSON() {
        return {
            id: this.id,
            rect: this.rect,
            trafficLightController: this.trafficLightController,
            // Include controlSignals for backward compatibility
            controlSignals: this._legacyControlSignals
        };
    }
    update() {
        // Update connected roads
        for (const road of this.roads) {
            road.update();
        }
        for (const road of this.inRoads) {
            road.update();
        }
    }
    /**
     * Process a simulation tick
     * @param delta Time elapsed since last tick in seconds
     */
    onTick(delta) {
        // Delegate to the traffic light controller
        if (this.trafficLightController) {
            this.trafficLightController.onTick(delta);
        }
        // For backward compatibility
        if (this._legacyControlSignals && this._legacyControlSignals.onTick) {
            this._legacyControlSignals.onTick(delta);
        }
    }
    /**
     * Get the current traffic signal state
     * @returns A 2D array where [approach][movement] represents the signal state
     *          (0 = RED, 1 = GREEN) for each approach (N,E,S,W) and movement (L,F,R)
     */
    getSignalState() {
        // Get state from the traffic light controller
        if (this.trafficLightController) {
            return this.trafficLightController.state;
        }
        // Fallback to legacy control signals for backward compatibility
        if (this._legacyControlSignals) {
            return this._legacyControlSignals.state;
        }
        // Default to all red if no controller is available
        return [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]];
    }
    /**
     * Set the traffic control strategy
     * @param strategyType The type of strategy to use
     * @returns True if the strategy was successfully applied, false otherwise
     */
    setTrafficControlStrategy(strategyType) {
        if (this.trafficLightController) {
            return this.trafficLightController.setStrategy(strategyType);
        }
        return false;
    }
}
module.exports = Intersection;


/***/ }),

/***/ "./src/model/kpi-collector.ts":
/*!************************************!*\
  !*** ./src/model/kpi-collector.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * KPICollector - Collects and aggregates Key Performance Indicators for the traffic simulation
 *
 * This class is responsible for:
 * - Recording events from vehicles, lanes, and intersections
 * - Calculating metrics based on these events
 * - Providing an API for the UI to display these metrics
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.kpiCollector = exports.KPICollector = exports.VehicleEvent = void 0;
var VehicleEvent;
(function (VehicleEvent) {
    VehicleEvent["ENTER_SIMULATION"] = "enter_simulation";
    VehicleEvent["EXIT_SIMULATION"] = "exit_simulation";
    VehicleEvent["ENTER_INTERSECTION"] = "enter_intersection";
    VehicleEvent["EXIT_INTERSECTION"] = "exit_intersection";
    VehicleEvent["START_MOVING"] = "start_moving";
    VehicleEvent["STOP_MOVING"] = "stop_moving";
    VehicleEvent["CHANGE_LANE"] = "change_lane";
    VehicleEvent["SPEED_CHANGE"] = "speed_change";
    VehicleEvent["ENTER_LANE"] = "enter_lane";
    VehicleEvent["EXIT_LANE"] = "exit_lane";
})(VehicleEvent = exports.VehicleEvent || (exports.VehicleEvent = {}));
class KPICollector {
    constructor() {
        // Store metrics
        this.vehicleMetrics = [];
        this.intersectionMetrics = [];
        this.laneMetrics = [];
        this.activeVehicles = new Set();
        this.stoppedVehicles = new Set();
        this.stoppedTimestamps = {};
        this.completedTrips = 0;
        this.simulationStartTime = 0;
        // Summary metrics (calculated on demand)
        this.totalSpeed = 0;
        this.speedMeasurements = 0;
        this.waitTimes = [];
        // Lane tracking
        this.vehiclesInLane = {}; // laneId -> Set of vehicleIds
        this.laneEntryTimes = {}; // vehicleId -> {laneId -> entryTime}
        this.laneThroughput = {}; // laneId -> count
        this.laneWaitTimes = {}; // laneId -> waitTimes array
        this.laneTotalSpeeds = {}; // laneId -> {total, count}
        // Intersection tracking
        this.intersectionEntryTimes = {}; // vehicleId -> {intersectionId -> entryTime}
        this.intersectionThroughput = {}; // intersectionId -> count
        this.intersectionWaitTimes = {}; // intersectionId -> waitTimes array
        this.intersectionQueueHistory = {}; // intersectionId -> queueLengths array
        // Settings
        this.sampleInterval = 0.5; // How often to sample speed (in simulation seconds)
        this.lastSampleTime = 0;
        this.isRecording = false;
        this.cleanupTimeout = null;
        this.reset();
    }
    /**
     * Start collecting metrics
     */
    startRecording(initialTime = 0) {
        this.isRecording = true;
        this.simulationStartTime = initialTime;
        this.lastSampleTime = initialTime;
        console.log('🔄 KPI Collector: Started recording metrics');
    }
    /**
     * Stop collecting metrics
     */
    stopRecording() {
        this.isRecording = false;
        console.log('🛑 KPI Collector: Stopped recording metrics');
    }
    /**
     * Reset all collected metrics
     */
    reset() {
        this.vehicleMetrics = [];
        this.intersectionMetrics = [];
        this.laneMetrics = [];
        this.activeVehicles = new Set();
        this.stoppedVehicles = new Set();
        this.stoppedTimestamps = {};
        this.completedTrips = 0;
        this.simulationStartTime = 0;
        this.totalSpeed = 0;
        this.speedMeasurements = 0;
        this.waitTimes = [];
        this.isRecording = false;
        // Reset lane tracking
        this.vehiclesInLane = {};
        this.laneEntryTimes = {};
        this.laneThroughput = {};
        this.laneWaitTimes = {};
        this.laneTotalSpeeds = {};
        // Reset intersection tracking
        this.intersectionEntryTimes = {};
        this.intersectionThroughput = {};
        this.intersectionWaitTimes = {};
        this.intersectionQueueHistory = {};
        if (this.cleanupTimeout !== null) {
            clearTimeout(this.cleanupTimeout);
            this.cleanupTimeout = null;
        }
        console.log('🗑️ KPI Collector: Metrics reset');
    }
    /**
     * Record vehicle entering the simulation
     */
    recordVehicleEnter(vehicle, time) {
        if (!this.isRecording)
            return;
        // Add to active vehicles set
        this.activeVehicles.add(vehicle.id);
        // Record the vehicle event
        this.vehicleMetrics.push({
            vehicleId: vehicle.id,
            timestamp: time,
            speed: vehicle.speed,
            event: VehicleEvent.ENTER_SIMULATION
        });
        console.log(`KPI Collector: Vehicle ${vehicle.id} entered simulation at time ${time}`);
    }
    /**
     * Record vehicle exiting the simulation
     */
    recordVehicleExit(vehicle, time) {
        if (!this.isRecording)
            return;
        // Remove from active vehicles set
        this.activeVehicles.delete(vehicle.id);
        // Increment completed trips counter
        this.completedTrips++;
        // Record the vehicle event
        this.vehicleMetrics.push({
            vehicleId: vehicle.id,
            timestamp: time,
            speed: vehicle.speed,
            event: VehicleEvent.EXIT_SIMULATION
        });
        console.log(`KPI Collector: Vehicle ${vehicle.id} exited simulation at time ${time}`);
    }
    /**
     * Record vehicle stopping (speed ~= 0)
     */
    recordVehicleStop(vehicle, time) {
        if (!this.isRecording)
            return;
        // Add to stopped vehicles set
        this.stoppedVehicles.add(vehicle.id);
        // Record stop timestamp for duration calculation later
        this.stoppedTimestamps[vehicle.id] = time;
        // Record the vehicle event
        this.vehicleMetrics.push({
            vehicleId: vehicle.id,
            timestamp: time,
            speed: vehicle.speed,
            event: VehicleEvent.STOP_MOVING
        });
    }
    /**
     * Record vehicle starting to move again
     */
    recordVehicleStart(vehicle, time) {
        if (!this.isRecording)
            return;
        // Remove from stopped vehicles set
        this.stoppedVehicles.delete(vehicle.id);
        // Calculate stop duration if we have a stop timestamp
        let duration = 0;
        if (this.stoppedTimestamps[vehicle.id]) {
            duration = time - this.stoppedTimestamps[vehicle.id];
            delete this.stoppedTimestamps[vehicle.id];
            // Record wait time for statistics
            this.waitTimes.push(duration);
        }
        // Record the vehicle event
        this.vehicleMetrics.push({
            vehicleId: vehicle.id,
            timestamp: time,
            speed: vehicle.speed,
            event: VehicleEvent.START_MOVING,
            duration: duration
        });
    }
    /**
     * Record vehicle changing lanes
     */
    recordLaneChange(vehicle, time) {
        if (!this.isRecording)
            return;
        this.vehicleMetrics.push({
            vehicleId: vehicle.id,
            timestamp: time,
            speed: vehicle.speed,
            event: VehicleEvent.CHANGE_LANE
        });
    }
    /**
     * Record vehicle entering an intersection
     */
    recordIntersectionEnter(vehicle, intersection, time) {
        if (!this.isRecording)
            return;
        const intersectionId = intersection.id;
        // Initialize intersection tracking structures if needed
        if (!this.intersectionEntryTimes[vehicle.id]) {
            this.intersectionEntryTimes[vehicle.id] = {};
        }
        if (!this.intersectionQueueHistory[intersectionId]) {
            this.intersectionQueueHistory[intersectionId] = [];
        }
        // Record entry time for calculating wait time later
        this.intersectionEntryTimes[vehicle.id][intersectionId] = time;
        // Record the vehicle event
        this.vehicleMetrics.push({
            vehicleId: vehicle.id,
            timestamp: time,
            speed: vehicle.speed,
            intersectionId: intersectionId,
            event: VehicleEvent.ENTER_INTERSECTION
        });
        // Update intersection metrics
        const queueLength = this.getVehiclesAtIntersection(intersectionId).length;
        // Store queue length history
        this.intersectionQueueHistory[intersectionId].push(queueLength);
        // Record updated intersection metrics
        this.intersectionMetrics.push({
            intersectionId: intersectionId,
            timestamp: time,
            queueLength: queueLength
        });
    }
    /**
     * Record vehicle exiting an intersection
     */
    recordIntersectionExit(vehicle, intersection, time) {
        if (!this.isRecording)
            return;
        const intersectionId = intersection.id;
        // Initialize tracking if needed
        if (!this.intersectionEntryTimes[vehicle.id]) {
            this.intersectionEntryTimes[vehicle.id] = {};
        }
        if (!this.intersectionThroughput[intersectionId]) {
            this.intersectionThroughput[intersectionId] = 0;
        }
        if (!this.intersectionWaitTimes[intersectionId]) {
            this.intersectionWaitTimes[intersectionId] = [];
        }
        // Calculate wait time for the vehicle at this intersection
        if (this.intersectionEntryTimes[vehicle.id][intersectionId]) {
            const waitTime = time - this.intersectionEntryTimes[vehicle.id][intersectionId];
            this.intersectionWaitTimes[intersectionId].push(waitTime);
            delete this.intersectionEntryTimes[vehicle.id][intersectionId];
        }
        // Increment throughput counter
        this.intersectionThroughput[intersectionId]++;
        // Record the vehicle event
        this.vehicleMetrics.push({
            vehicleId: vehicle.id,
            timestamp: time,
            speed: vehicle.speed,
            intersectionId: intersectionId,
            event: VehicleEvent.EXIT_INTERSECTION
        });
        // Update intersection metrics
        const queueLength = this.getVehiclesAtIntersection(intersectionId).length;
        // Update queue length history
        if (!this.intersectionQueueHistory[intersectionId]) {
            this.intersectionQueueHistory[intersectionId] = [];
        }
        this.intersectionQueueHistory[intersectionId].push(queueLength);
        // Record updated intersection metrics
        this.intersectionMetrics.push({
            intersectionId: intersectionId,
            timestamp: time,
            queueLength: queueLength,
            // Calculate throughput as vehicles per minute (based on simulation time)
            throughput: this.calculateIntersectionThroughput(intersectionId, time)
        });
    }
    /**
     * Calculate vehicles per minute throughput for an intersection
     */
    calculateIntersectionThroughput(intersectionId, currentTime) {
        const throughput = this.intersectionThroughput[intersectionId] || 0;
        const elapsedMinutes = Math.max(0.001, (currentTime - this.simulationStartTime) / 60);
        return throughput / elapsedMinutes; // Vehicles per minute
    }
    /**
     * Record a vehicle entering a lane
     */
    recordLaneEnter(vehicle, lane, time) {
        if (!this.isRecording)
            return;
        const laneId = lane.id;
        // Initialize lane tracking structures if needed
        if (!this.vehiclesInLane[laneId]) {
            this.vehiclesInLane[laneId] = new Set();
        }
        if (!this.laneEntryTimes[vehicle.id]) {
            this.laneEntryTimes[vehicle.id] = {};
        }
        // Add vehicle to lane set
        this.vehiclesInLane[laneId].add(vehicle.id);
        // Record entry time for calculating wait time later
        this.laneEntryTimes[vehicle.id][laneId] = time;
        // Record the vehicle event
        this.vehicleMetrics.push({
            vehicleId: vehicle.id,
            timestamp: time,
            speed: vehicle.speed,
            laneId: laneId,
            roadId: lane.road ? lane.road.id : undefined,
            event: VehicleEvent.ENTER_LANE
        });
        // Update lane metrics
        const vehicleCount = this.vehiclesInLane[laneId].size;
        const averageSpeed = this.calculateAverageLaneSpeed(laneId);
        const congestionRate = this.calculateLaneCongestion(laneId, lane);
        // Record lane metrics
        this.laneMetrics.push({
            laneId: laneId,
            timestamp: time,
            vehicleCount: vehicleCount,
            averageSpeed: averageSpeed,
            congestionRate: congestionRate
        });
    }
    /**
     * Record a vehicle exiting a lane
     */
    recordLaneExit(vehicle, lane, time) {
        if (!this.isRecording)
            return;
        const laneId = lane.id;
        // Initialize tracking structures if needed
        if (!this.vehiclesInLane[laneId]) {
            this.vehiclesInLane[laneId] = new Set();
        }
        if (!this.laneEntryTimes[vehicle.id]) {
            this.laneEntryTimes[vehicle.id] = {};
        }
        if (!this.laneThroughput[laneId]) {
            this.laneThroughput[laneId] = 0;
        }
        if (!this.laneWaitTimes[laneId]) {
            this.laneWaitTimes[laneId] = [];
        }
        // Remove vehicle from lane set
        this.vehiclesInLane[laneId].delete(vehicle.id);
        // Calculate time spent in lane
        if (this.laneEntryTimes[vehicle.id] && this.laneEntryTimes[vehicle.id][laneId]) {
            const timeInLane = time - this.laneEntryTimes[vehicle.id][laneId];
            this.laneWaitTimes[laneId].push(timeInLane);
            delete this.laneEntryTimes[vehicle.id][laneId];
        }
        // Increment lane throughput counter
        this.laneThroughput[laneId]++;
        // Record the vehicle event
        this.vehicleMetrics.push({
            vehicleId: vehicle.id,
            timestamp: time,
            speed: vehicle.speed,
            laneId: laneId,
            roadId: lane.road ? lane.road.id : undefined,
            event: VehicleEvent.EXIT_LANE
        });
        // Update lane metrics
        const vehicleCount = this.vehiclesInLane[laneId].size;
        const averageSpeed = this.calculateAverageLaneSpeed(laneId);
        const congestionRate = this.calculateLaneCongestion(laneId, lane);
        // Record lane metrics
        this.laneMetrics.push({
            laneId: laneId,
            timestamp: time,
            vehicleCount: vehicleCount,
            averageSpeed: averageSpeed,
            congestionRate: congestionRate
        });
    }
    /**
     * Calculate average speed in a lane
     */
    calculateAverageLaneSpeed(laneId) {
        if (!this.laneTotalSpeeds[laneId] || this.laneTotalSpeeds[laneId].count === 0) {
            return 0;
        }
        return this.laneTotalSpeeds[laneId].total / this.laneTotalSpeeds[laneId].count;
    }
    /**
     * Calculate lane congestion (0-1 scale)
     */
    calculateLaneCongestion(laneId, lane) {
        if (!this.vehiclesInLane[laneId]) {
            return 0;
        }
        // Assuming a lane can fit roughly lane.length / 5 cars (average car length + safety distance)
        const laneCapacity = lane.length ? Math.floor(lane.length / 5) : 10;
        return Math.min(this.vehiclesInLane[laneId].size / laneCapacity, 1);
    }
    /**
     * Sample the current state of a specific lane
     */
    sampleLaneState(lane, time) {
        if (!this.isRecording)
            return;
        const laneId = lane.id;
        if (!this.vehiclesInLane[laneId]) {
            this.vehiclesInLane[laneId] = new Set();
        }
        // Count vehicles in the lane
        const vehicleCount = this.vehiclesInLane[laneId].size;
        // Calculate congestion rate
        const congestionRate = this.calculateLaneCongestion(lane, vehicleCount);
        // Collect speeds of vehicles in the lane to calculate average speed
        let totalSpeed = 0;
        let count = 0;
        // This would require a mapping of which vehicles are in which lane
        // We'll update this in the recordLaneEnter/Exit methods
        // Add this to our lane metrics
        this.laneMetrics.push({
            laneId: laneId,
            timestamp: time,
            vehicleCount: vehicleCount,
            averageSpeed: this.calculateAverageLaneSpeed(laneId),
            congestionRate: congestionRate,
            queueLength: this.calculateLaneQueueLength(laneId)
        });
    }
    /**
     * Calculate queue length in a lane based on stopped vehicles
     */
    calculateLaneQueueLength(laneId) {
        // Count stopped vehicles in the lane
        let queueCount = 0;
        if (this.vehiclesInLane[laneId]) {
            this.vehiclesInLane[laneId].forEach(vehicleId => {
                if (this.stoppedVehicles.has(vehicleId)) {
                    queueCount++;
                }
            });
        }
        return queueCount;
    }
    /**
     * Update lane speed metrics when a vehicle's speed changes
     */
    updateLaneSpeedMetrics(vehicle, laneId, speed) {
        if (!this.isRecording || !laneId)
            return;
        // Initialize if needed
        if (!this.laneTotalSpeeds[laneId]) {
            this.laneTotalSpeeds[laneId] = { total: 0, count: 0 };
        }
        // Update speed metrics for the lane
        this.laneTotalSpeeds[laneId].total += speed;
        this.laneTotalSpeeds[laneId].count++;
    }
    /**
     * Sample the current speeds of all vehicles
     * Called periodically to track overall speed metrics
     */
    sampleSpeeds(vehicles, time) {
        if (!this.isRecording)
            return;
        // Only sample at specific intervals to avoid too much data
        if (time - this.lastSampleTime < this.sampleInterval) {
            return;
        }
        this.lastSampleTime = time;
        // Calculate average speed from all vehicles
        let totalSpeed = 0;
        let count = 0;
        for (const id in vehicles) {
            const vehicle = vehicles[id];
            totalSpeed += vehicle.speed;
            count++;
            // Record significant speed changes individually
            // We could implement this based on threshold if needed
        }
        if (count > 0) {
            this.totalSpeed += totalSpeed;
            this.speedMeasurements += count;
        }
    }
    /**
     * Get currently active vehicles at a specific intersection
     */
    getVehiclesAtIntersection(intersectionId) {
        // This is a simple implementation - in a real system we'd track this more efficiently
        return this.vehicleMetrics.filter(m => m.event === VehicleEvent.ENTER_INTERSECTION &&
            // Check if there's no corresponding exit event yet
            !this.vehicleMetrics.some(exit => exit.vehicleId === m.vehicleId &&
                exit.event === VehicleEvent.EXIT_INTERSECTION &&
                exit.timestamp > m.timestamp));
    }
    /**
     * Get the aggregated metrics for display or export
     */
    getMetrics(currentTime = 0) {
        // Calculate average speed - give more importance to recent measurements
        const avgSpeed = this.speedMeasurements > 0
            ? this.totalSpeed / this.speedMeasurements
            : 0;
        // Calculate wait times
        const avgWaitTime = this.waitTimes.length > 0
            ? this.waitTimes.reduce((a, b) => a + b, 0) / this.waitTimes.length
            : 0;
        const maxWaitTime = this.waitTimes.length > 0
            ? Math.max(...this.waitTimes)
            : 0;
        // Count total stops (unique stop events)
        const totalStops = this.vehicleMetrics.filter(m => m.event === VehicleEvent.STOP_MOVING).length;
        // Calculate intersection utilization
        // Group metrics by intersection ID manually
        const intersectionMetricsByID = {};
        // Group metrics by intersection ID
        this.intersectionMetrics.forEach(metric => {
            const id = metric.intersectionId;
            if (!intersectionMetricsByID[id]) {
                intersectionMetricsByID[id] = [];
            }
            intersectionMetricsByID[id].push(metric);
        });
        const intersectionUtilization = {};
        // Calculate average queue length for each intersection
        Object.entries(intersectionMetricsByID).forEach(([id, metrics]) => {
            let totalQueueLength = 0;
            metrics.forEach(metric => {
                totalQueueLength += metric.queueLength;
            });
            const avgQueueLength = metrics.length > 0 ? totalQueueLength / metrics.length : 0;
            intersectionUtilization[id] = avgQueueLength;
        });
        // Calculate road utilization based on vehicle positions
        // This is an approximation based on event frequency on roads
        const roadUtilization = {};
        // Get true total vehicle count (all unique vehicles that entered)
        const totalVehicleIDs = new Set(this.vehicleMetrics
            .filter(m => m.event === VehicleEvent.ENTER_SIMULATION)
            .map(m => m.vehicleId));
        return {
            totalVehicles: totalVehicleIDs.size,
            activeVehicles: this.activeVehicles.size,
            completedTrips: this.completedTrips,
            averageSpeed: avgSpeed,
            averageWaitTime: avgWaitTime,
            maxWaitTime: maxWaitTime,
            totalStops: totalStops,
            stoppedVehicles: this.stoppedVehicles.size,
            intersectionUtilization,
            roadUtilization,
            simulationTime: currentTime - this.simulationStartTime,
            // New expanded metrics
            laneMetrics: this.calculateLaneMetrics(),
            intersectionMetrics: this.calculateIntersectionMetrics(),
            globalThroughput: this.calculateGlobalThroughput(),
            congestionIndex: this.calculateCongestionIndex()
        };
    }
    /**
     * Validate export data against current UI display for accuracy
     * Returns an object with validation results
     */
    validateExportData() {
        const currentMetrics = this.getMetrics();
        const csvData = this.exportMetricsCSV();
        const jsonData = JSON.parse(this.exportMetricsJSON());
        const discrepancies = [];
        // Validate CSV data structure
        const csvLines = csvData.split('\n');
        let csvGlobalMetricsFound = false;
        let csvLaneMetricsFound = false;
        let csvIntersectionMetricsFound = false;
        for (const line of csvLines) {
            if (line.includes('Total Vehicles,')) {
                const csvValue = parseInt(line.split(',')[1]);
                if (csvValue !== currentMetrics.totalVehicles) {
                    discrepancies.push(`Total Vehicles mismatch: CSV=${csvValue}, UI=${currentMetrics.totalVehicles}`);
                }
                csvGlobalMetricsFound = true;
            }
            if (line.includes('Average Speed (m/s),')) {
                const csvValue = parseFloat(line.split(',')[1]);
                const diff = Math.abs(csvValue - currentMetrics.averageSpeed);
                if (diff > 0.01) {
                    discrepancies.push(`Average Speed mismatch: CSV=${csvValue}, UI=${currentMetrics.averageSpeed.toFixed(2)}`);
                }
            }
            if (line.includes('Lane Performance Metrics')) {
                csvLaneMetricsFound = true;
            }
            if (line.includes('Intersection Performance Metrics')) {
                csvIntersectionMetricsFound = true;
            }
        }
        // Validate JSON data structure
        if (jsonData.summary.totalVehicles !== currentMetrics.totalVehicles) {
            discrepancies.push(`JSON Total Vehicles mismatch: JSON=${jsonData.summary.totalVehicles}, UI=${currentMetrics.totalVehicles}`);
        }
        if (Math.abs(jsonData.summary.averageSpeed - currentMetrics.averageSpeed) > 0.01) {
            discrepancies.push(`JSON Average Speed mismatch: JSON=${jsonData.summary.averageSpeed}, UI=${currentMetrics.averageSpeed.toFixed(2)}`);
        }
        // Check lane metrics count
        const uiLaneCount = Object.keys(currentMetrics.laneMetrics).length;
        const jsonLaneCount = Object.keys(jsonData.laneMetrics).length;
        if (jsonLaneCount !== uiLaneCount) {
            discrepancies.push(`Lane metrics count mismatch: JSON=${jsonLaneCount}, UI=${uiLaneCount}`);
        }
        // Check intersection metrics count
        const uiIntersectionCount = Object.keys(currentMetrics.intersectionMetrics).length;
        const jsonIntersectionCount = Object.keys(jsonData.intersectionMetrics).length;
        if (jsonIntersectionCount !== uiIntersectionCount) {
            discrepancies.push(`Intersection metrics count mismatch: JSON=${jsonIntersectionCount}, UI=${uiIntersectionCount}`);
        }
        // Validate required sections exist
        if (!csvGlobalMetricsFound) {
            discrepancies.push('CSV missing global metrics section');
        }
        if (!csvLaneMetricsFound) {
            discrepancies.push('CSV missing lane metrics section');
        }
        if (!csvIntersectionMetricsFound) {
            discrepancies.push('CSV missing intersection metrics section');
        }
        const isValid = discrepancies.length === 0;
        const summary = isValid
            ? '✅ All export data matches UI display accurately'
            : `❌ Found ${discrepancies.length} discrepancy/discrepancies between export data and UI`;
        return {
            isValid,
            discrepancies,
            summary
        };
    }
    /**
     * Calculate detailed lane metrics
     */
    calculateLaneMetrics() {
        const laneMetrics = {};
        // Calculate metrics for each vehicle
        this.vehicleMetrics.forEach(metric => {
            if (metric.event === VehicleEvent.ENTER_LANE || metric.event === VehicleEvent.EXIT_LANE) {
                const laneId = metric.laneId || '';
                if (!laneMetrics[laneId]) {
                    laneMetrics[laneId] = {
                        laneId: laneId,
                        averageSpeed: 0,
                        vehicleCount: 0,
                        maxVehicleCount: 0,
                        averageVehicleCount: 0,
                        congestionRate: 0,
                        throughput: 0,
                        totalVehiclesPassed: 0,
                        averageWaitTime: 0,
                        queueLength: 0
                    };
                }
                const laneMetric = laneMetrics[laneId];
                // Update counts
                laneMetric.vehicleCount++;
                laneMetric.totalVehiclesPassed++;
                // Update speeds
                laneMetric.averageSpeed += metric.speed;
                // Update queue length (simple approximation)
                if (metric.event === VehicleEvent.ENTER_LANE) {
                    laneMetric.queueLength++;
                }
                else if (metric.event === VehicleEvent.EXIT_LANE) {
                    laneMetric.queueLength = Math.max(0, laneMetric.queueLength - 1);
                }
            }
        });
        // Finalize metrics calculation
        for (const laneId in laneMetrics) {
            const metric = laneMetrics[laneId];
            metric.averageSpeed /= metric.vehicleCount || 1;
            metric.congestionRate = Math.min(1, metric.queueLength / 10); // Assume max 10 vehicles before congestion
            metric.throughput = metric.totalVehiclesPassed / (this.simulationStartTime + 1); // Per minute
        }
        return laneMetrics;
    }
    /**
     * Calculate detailed intersection metrics
     */
    calculateIntersectionMetrics() {
        const intersectionMetrics = {};
        // Calculate metrics for each vehicle
        this.vehicleMetrics.forEach(metric => {
            if (metric.event === VehicleEvent.ENTER_INTERSECTION || metric.event === VehicleEvent.EXIT_INTERSECTION) {
                const intersectionId = metric.intersectionId || '';
                if (!intersectionMetrics[intersectionId]) {
                    intersectionMetrics[intersectionId] = {
                        intersectionId: intersectionId,
                        throughput: 0,
                        averageWaitTime: 0,
                        maxWaitTime: 0,
                        averageQueueLength: 0,
                        maxQueueLength: 0,
                        totalVehiclesPassed: 0,
                        congestionRate: 0
                    };
                }
                const intersectionMetric = intersectionMetrics[intersectionId];
                // Update counts
                intersectionMetric.totalVehiclesPassed++;
                // Update queue length (simple approximation)
                if (metric.event === VehicleEvent.ENTER_INTERSECTION) {
                    intersectionMetric.averageQueueLength++;
                }
                else if (metric.event === VehicleEvent.EXIT_INTERSECTION) {
                    intersectionMetric.averageQueueLength = Math.max(0, intersectionMetric.averageQueueLength - 1);
                }
            }
        });
        // Finalize metrics calculation
        for (const intersectionId in intersectionMetrics) {
            const metric = intersectionMetrics[intersectionId];
            metric.throughput = metric.totalVehiclesPassed / (this.simulationStartTime + 1); // Per minute
            metric.congestionRate = Math.min(1, metric.averageQueueLength / 10); // Assume max 10 vehicles before congestion
        }
        return intersectionMetrics;
    }
    /**
     * Calculate global throughput (vehicles per minute)
     */
    calculateGlobalThroughput() {
        return this.vehicleMetrics.length / (this.simulationStartTime + 1);
    }
    /**
     * Calculate congestion index (0-1)
     */
    calculateCongestionIndex() {
        // Simple index based on average queue length across all intersections and lanes
        const totalQueueLength = Object.values(this.calculateLaneMetrics()).reduce((sum, metric) => sum + metric.queueLength, 0) +
            Object.values(this.calculateIntersectionMetrics()).reduce((sum, metric) => sum + metric.averageQueueLength, 0);
        const maxPossibleQueueLength = (Object.keys(this.calculateLaneMetrics()).length + Object.keys(this.calculateIntersectionMetrics()).length) * 10; // Assume max 10 vehicles before congestion per lane/intersection
        return Math.min(1, totalQueueLength / maxPossibleQueueLength);
    }
    /**
     * Export metrics as CSV format
     */
    exportMetricsCSV() {
        const metrics = this.getMetrics();
        let csv = 'Metric,Value\n';
        // Global metrics
        csv += '# Global Simulation Metrics\n';
        csv += `Total Vehicles,${metrics.totalVehicles}\n`;
        csv += `Active Vehicles,${metrics.activeVehicles}\n`;
        csv += `Completed Trips,${metrics.completedTrips}\n`;
        csv += `Average Speed (m/s),${metrics.averageSpeed.toFixed(2)}\n`;
        csv += `Average Wait Time (s),${metrics.averageWaitTime.toFixed(2)}\n`;
        csv += `Max Wait Time (s),${metrics.maxWaitTime.toFixed(2)}\n`;
        csv += `Total Stops,${metrics.totalStops}\n`;
        csv += `Stopped Vehicles,${metrics.stoppedVehicles}\n`;
        csv += `Global Throughput (vehicles/min),${metrics.globalThroughput.toFixed(2)}\n`;
        csv += `Global Congestion Index,${metrics.congestionIndex.toFixed(2)}\n`;
        csv += `Simulation Time (s),${metrics.simulationTime.toFixed(2)}\n\n`;
        // Lane metrics
        csv += '# Lane Metrics\n';
        csv += 'Lane ID,Average Speed,Vehicle Count,Max Vehicle Count,Average Vehicle Count,Congestion Rate,Throughput,Total Vehicles Passed,Average Wait Time,Queue Length\n';
        Object.values(metrics.laneMetrics).forEach(lane => {
            csv += `${lane.laneId},${lane.averageSpeed.toFixed(2)},${lane.vehicleCount},${lane.maxVehicleCount},`;
            csv += `${lane.averageVehicleCount.toFixed(2)},${lane.congestionRate.toFixed(2)},${lane.throughput.toFixed(2)},`;
            csv += `${lane.totalVehiclesPassed},${lane.averageWaitTime.toFixed(2)},${lane.queueLength}\n`;
        });
        csv += '\n# Intersection Metrics\n';
        csv += 'Intersection ID,Throughput,Average Wait Time,Max Wait Time,Average Queue Length,Max Queue Length,Total Vehicles Passed,Congestion Rate\n';
        Object.values(metrics.intersectionMetrics).forEach(intersection => {
            csv += `${intersection.intersectionId},${intersection.throughput.toFixed(2)},${intersection.averageWaitTime.toFixed(2)},`;
            csv += `${intersection.maxWaitTime.toFixed(2)},${intersection.averageQueueLength.toFixed(2)},${intersection.maxQueueLength},`;
            csv += `${intersection.totalVehiclesPassed},${intersection.congestionRate.toFixed(2)}\n`;
        });
        return csv;
    }
    /**
     * Helper to download metrics as a CSV file
     */
    downloadMetricsCSV() {
        const csv = this.exportMetricsCSV();
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.setAttribute('href', url);
        link.setAttribute('download', `traffic-metrics-${new Date().toISOString().slice(0, 10)}.csv`);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }
    /**
     * Export metrics as JSON format
     */
    exportMetricsJSON() {
        const metrics = this.getMetrics();
        const exportData = {
            timestamp: new Date().toISOString(),
            summary: {
                totalVehicles: metrics.totalVehicles,
                activeVehicles: metrics.activeVehicles,
                completedTrips: metrics.completedTrips,
                averageSpeed: metrics.averageSpeed,
                averageWaitTime: metrics.averageWaitTime,
                maxWaitTime: metrics.maxWaitTime,
                totalStops: metrics.totalStops,
                stoppedVehicles: metrics.stoppedVehicles,
                globalThroughput: metrics.globalThroughput,
                congestionIndex: metrics.congestionIndex,
                simulationTime: metrics.simulationTime
            },
            laneMetrics: metrics.laneMetrics,
            intersectionMetrics: metrics.intersectionMetrics,
            intersectionUtilization: metrics.intersectionUtilization,
            roadUtilization: metrics.roadUtilization,
            rawData: {
                vehicleEvents: this.vehicleMetrics,
                intersectionEvents: this.intersectionMetrics,
                laneEvents: this.laneMetrics
            }
        };
        return JSON.stringify(exportData, null, 2);
    }
    /**
     * Helper to download metrics as a JSON file
     */
    downloadMetricsJSON() {
        const json = this.exportMetricsJSON();
        const blob = new Blob([json], { type: 'application/json;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.setAttribute('href', url);
        link.setAttribute('download', `traffic-metrics-${new Date().toISOString().slice(0, 10)}.json`);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }
    /**
     * Record a significant speed change
     */
    recordSpeedChange(vehicle, time, oldSpeed, newSpeed) {
        if (!this.isRecording)
            return;
        this.vehicleMetrics.push({
            vehicleId: vehicle.id,
            timestamp: time,
            speed: newSpeed,
            oldSpeed: oldSpeed,
            event: VehicleEvent.SPEED_CHANGE
        });
    }
    /**
     * Test function to validate KPI collection accuracy
     * Logs detailed event counts and metrics to validate collection is working properly
     * Returns HTML formatted validation report for UI display
     */
    validateMetrics() {
        // Count events by type
        const eventCounts = {};
        for (const metric of this.vehicleMetrics) {
            eventCounts[metric.event] = (eventCounts[metric.event] || 0) + 1;
        }
        // Get all unique vehicle IDs
        const uniqueVehicleIds = new Set(this.vehicleMetrics.map(m => m.vehicleId));
        // Calculate metrics
        const metrics = this.getMetrics();
        // Print validation report to console
        console.log('=== KPI Collection Validation Report ===');
        console.log('Event counts:', eventCounts);
        console.log('Unique vehicles tracked:', uniqueVehicleIds.size);
        console.log('Active vehicles:', this.activeVehicles.size);
        console.log('Completed trips:', this.completedTrips);
        console.log('Total vehicles processed:', metrics.totalVehicles);
        // Verify data integrity
        const vehiclesWithEntry = new Set(this.vehicleMetrics
            .filter(m => m.event === VehicleEvent.ENTER_SIMULATION)
            .map(m => m.vehicleId));
        const vehiclesWithExit = new Set(this.vehicleMetrics
            .filter(m => m.event === VehicleEvent.EXIT_SIMULATION)
            .map(m => m.vehicleId));
        // Check for vehicles that have exit events but no entry events
        const vehiclesWithExitButNoEntry = [...vehiclesWithExit].filter(id => !vehiclesWithEntry.has(id));
        // Check for vehicles that have speed changes but no entry events
        const vehiclesWithSpeedChangeButNoEntry = new Set(this.vehicleMetrics
            .filter(m => m.event === VehicleEvent.SPEED_CHANGE && !vehiclesWithEntry.has(m.vehicleId))
            .map(m => m.vehicleId));
        // Check for intersection entries without exits
        const vehiclesInIntersectionWithoutExit = new Set();
        this.vehicleMetrics.forEach(m => {
            if (m.event === VehicleEvent.ENTER_INTERSECTION) {
                // Check if there's a matching exit event after this
                const hasExit = this.vehicleMetrics.some(exit => exit.vehicleId === m.vehicleId &&
                    exit.event === VehicleEvent.EXIT_INTERSECTION &&
                    exit.timestamp > m.timestamp);
                if (!hasExit && this.activeVehicles.has(m.vehicleId)) {
                    vehiclesInIntersectionWithoutExit.add(m.vehicleId);
                }
            }
        });
        // Check for lane entries without exits
        const vehiclesInLaneWithoutExit = new Set();
        this.vehicleMetrics.forEach(m => {
            if (m.event === VehicleEvent.ENTER_LANE) {
                // Check if there's a matching exit event after this
                const hasExit = this.vehicleMetrics.some(exit => exit.vehicleId === m.vehicleId &&
                    exit.event === VehicleEvent.EXIT_LANE &&
                    exit.laneId === m.laneId &&
                    exit.timestamp > m.timestamp);
                if (!hasExit && this.activeVehicles.has(m.vehicleId)) {
                    vehiclesInLaneWithoutExit.add(m.vehicleId);
                }
            }
        });
        // Check for stop events without subsequent start events
        const stoppedWithoutStart = new Set();
        this.vehicleMetrics.forEach(m => {
            if (m.event === VehicleEvent.STOP_MOVING) {
                // Check if there's a matching start event after this
                const hasStart = this.vehicleMetrics.some(start => start.vehicleId === m.vehicleId &&
                    start.event === VehicleEvent.START_MOVING &&
                    start.timestamp > m.timestamp);
                if (!hasStart && this.activeVehicles.has(m.vehicleId)) {
                    stoppedWithoutStart.add(m.vehicleId);
                }
            }
        });
        // Check for average speed calculation accuracy
        const calculatedAvgSpeed = this.speedMeasurements > 0
            ? this.totalSpeed / this.speedMeasurements
            : 0;
        // Recalculate by direct measurement to validate
        const allSpeeds = this.vehicleMetrics.map(m => m.speed);
        const directAvgSpeed = allSpeeds.length > 0
            ? allSpeeds.reduce((a, b) => a + b, 0) / allSpeeds.length
            : 0;
        // Validate lane metrics consistency
        const laneEntryEvents = this.vehicleMetrics.filter(m => m.event === VehicleEvent.ENTER_LANE);
        const laneExitEvents = this.vehicleMetrics.filter(m => m.event === VehicleEvent.EXIT_LANE);
        const lanesToValidate = Object.keys(metrics.laneMetrics);
        const laneMetricsValidation = {};
        lanesToValidate.forEach(laneId => {
            const entries = laneEntryEvents.filter(m => m.laneId === laneId).length;
            const exits = laneExitEvents.filter(m => m.laneId === laneId).length;
            laneMetricsValidation[laneId] = {
                entries,
                exits,
                balance: entries - exits
            };
        });
        // Validate intersection metrics consistency
        const intersectionEntryEvents = this.vehicleMetrics.filter(m => m.event === VehicleEvent.ENTER_INTERSECTION);
        const intersectionExitEvents = this.vehicleMetrics.filter(m => m.event === VehicleEvent.EXIT_INTERSECTION);
        const intersectionsToValidate = Object.keys(metrics.intersectionMetrics);
        const intersectionMetricsValidation = {};
        intersectionsToValidate.forEach(intersectionId => {
            const entries = intersectionEntryEvents.filter(m => m.intersectionId === intersectionId).length;
            const exits = intersectionExitEvents.filter(m => m.intersectionId === intersectionId).length;
            intersectionMetricsValidation[intersectionId] = {
                entries,
                exits,
                balance: entries - exits
            };
        });
        // Log integrity issues
        console.log('=== Data Integrity Checks ===');
        console.log('Vehicles with exit but no entry:', vehiclesWithExitButNoEntry.length);
        console.log('Vehicles with speed changes but no entry:', vehiclesWithSpeedChangeButNoEntry.size);
        console.log('Vehicles currently in intersection:', vehiclesInIntersectionWithoutExit.size);
        console.log('Vehicles in lane without exit:', vehiclesInLaneWithoutExit.size);
        console.log('Vehicles stopped without restart:', stoppedWithoutStart.size);
        console.log('Calculated avg speed:', calculatedAvgSpeed);
        console.log('Direct measurement avg speed:', directAvgSpeed);
        console.log('Speed measurement count:', this.speedMeasurements);
        console.log('Lane metrics validation:', laneMetricsValidation);
        console.log('Intersection metrics validation:', intersectionMetricsValidation);
        console.log('Total event records:', this.vehicleMetrics.length);
        console.log('==============================');
        // Create HTML report for UI display
        let html = '<div class="kpi-validation">';
        html += '<h3>KPI Collection Validation Report</h3>';
        html += '<table class="validation-table">';
        html += '<tr><th colspan="2">Event Counts</th></tr>';
        for (const [event, count] of Object.entries(eventCounts)) {
            html += `<tr><td>${event}</td><td>${count}</td></tr>`;
        }
        html += '<tr><th colspan="2">Vehicle Statistics</th></tr>';
        html += `<tr><td>Unique vehicles tracked</td><td>${uniqueVehicleIds.size}</td></tr>`;
        html += `<tr><td>Total vehicles (entry events)</td><td>${vehiclesWithEntry.size}</td></tr>`;
        html += `<tr><td>Vehicles with exit events</td><td>${vehiclesWithExit.size}</td></tr>`;
        html += `<tr><td>Currently active vehicles</td><td>${this.activeVehicles.size}</td></tr>`;
        html += `<tr><td>Completed trips</td><td>${this.completedTrips}</td></tr>`;
        html += '<tr><th colspan="2">Speed Statistics</th></tr>';
        html += `<tr><td>Average speed (calculated)</td><td>${calculatedAvgSpeed.toFixed(2)} m/s</td></tr>`;
        html += `<tr><td>Average speed (direct)</td><td>${directAvgSpeed.toFixed(2)} m/s</td></tr>`;
        html += `<tr><td>Speed measurements</td><td>${this.speedMeasurements}</td></tr>`;
        // Lane and intersection validation
        html += '<tr><th colspan="3">Lane Metrics Validation</th></tr>';
        html += '<tr><td>Lane ID</td><td>Entries</td><td>Exits</td></tr>';
        for (const [laneId, validation] of Object.entries(laneMetricsValidation)) {
            const isBalanced = validation.balance === 0 ||
                (validation.entries > 0 && (validation.balance / validation.entries) < 0.05);
            const rowClass = isBalanced ? '' : 'validation-error';
            html += `<tr class="${rowClass}"><td>${laneId}</td><td>${validation.entries}</td><td>${validation.exits}</td></tr>`;
        }
        html += '<tr><th colspan="3">Intersection Metrics Validation</th></tr>';
        html += '<tr><td>Intersection ID</td><td>Entries</td><td>Exits</td></tr>';
        for (const [intersectionId, validation] of Object.entries(intersectionMetricsValidation)) {
            const isBalanced = validation.balance === 0 ||
                (validation.entries > 0 && (validation.balance / validation.entries) < 0.05);
            const rowClass = isBalanced ? '' : 'validation-error';
            html += `<tr class="${rowClass}"><td>${intersectionId}</td><td>${validation.entries}</td><td>${validation.exits}</td></tr>`;
        }
        html += '<tr><th colspan="2">Data Integrity Issues</th></tr>';
        // Add validation warnings in red if issues found
        const hasIssues = vehiclesWithExitButNoEntry.length > 0 ||
            vehiclesWithSpeedChangeButNoEntry.size > 0 ||
            Math.abs(calculatedAvgSpeed - directAvgSpeed) > 1.0 ||
            vehiclesInLaneWithoutExit.size > 0;
        if (hasIssues) {
            if (vehiclesWithExitButNoEntry.length > 0) {
                html += `<tr class="validation-error"><td>Vehicles with exit but no entry</td><td>${vehiclesWithExitButNoEntry.length}</td></tr>`;
            }
            if (vehiclesWithSpeedChangeButNoEntry.size > 0) {
                html += `<tr class="validation-error"><td>Vehicles with speed changes but no entry</td><td>${vehiclesWithSpeedChangeButNoEntry.size}</td></tr>`;
            }
            if (vehiclesInLaneWithoutExit.size > 0) {
                html += `<tr class="validation-error"><td>Vehicles in lane without exit</td><td>${vehiclesInLaneWithoutExit.size}</td></tr>`;
            }
            if (Math.abs(calculatedAvgSpeed - directAvgSpeed) > 1.0) {
                html += `<tr class="validation-error"><td>Speed calculation discrepancy</td><td>${Math.abs(calculatedAvgSpeed - directAvgSpeed).toFixed(2)}</td></tr>`;
            }
        }
        else {
            html += `<tr class="validation-success"><td colspan="2">All validation checks passed!</td></tr>`;
        }
        // Global metrics summary
        html += '<tr><th colspan="2">Global Metrics</th></tr>';
        html += `<tr><td>Global Throughput (vehicles/min)</td><td>${metrics.globalThroughput.toFixed(2)}</td></tr>`;
        html += `<tr><td>Congestion Index (0-1)</td><td>${metrics.congestionIndex.toFixed(2)}</td></tr>`;
        html += `<tr><td>Total event records</td><td>${this.vehicleMetrics.length}</td></tr>`;
        html += '</table></div>';
        return html;
    }
}
exports.KPICollector = KPICollector;
// Export a singleton instance for application-wide use
exports.kpiCollector = new KPICollector();


/***/ }),

/***/ "./src/model/lane-position.ts":
/*!************************************!*\
  !*** ./src/model/lane-position.ts ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! ../helpers */ "./src/helpers.ts");
const _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/modules/index-all.js");
class LanePosition {
    constructor(car, lane, position) {
        this.car = car;
        this.id = _.uniqueId('laneposition');
        this.free = true;
        this._lane = lane;
        this.position = position || 0;
    }
    get lane() {
        return this._lane;
    }
    set lane(lane) {
        this.release();
        this._lane = lane;
        // this.acquire();
    }
    get relativePosition() {
        return this.position / this.lane.length;
    }
    acquire() {
        if (this.lane && this.lane.addCarPosition) {
            this.free = false;
            this.lane.addCarPosition(this);
        }
    }
    release() {
        if (!this.free && this.lane && this.lane.removeCar) {
            this.free = true;
            this.lane.removeCar(this);
        }
    }
    getNext() {
        if (this.lane && !this.free) {
            return this.lane.getNext(this);
        }
        return null;
    }
    get nextCarDistance() {
        const next = this.getNext();
        if (next) {
            const rearPosition = next.position - next.car.length / 2;
            const frontPosition = this.position + this.car.length / 2;
            return {
                car: next.car,
                distance: rearPosition - frontPosition
            };
        }
        return {
            car: null,
            distance: Infinity
        };
    }
}
// Set up properties using the CoffeeScript-style property decorator
LanePosition.property('lane', {
    get: function () {
        return this._lane;
    },
    set: function (lane) {
        this.release();
        this._lane = lane;
        // this.acquire();
    }
});
LanePosition.property('relativePosition', {
    get: function () {
        return this.position / this.lane.length;
    }
});
LanePosition.property('nextCarDistance', {
    get: function () {
        const next = this.getNext();
        if (next) {
            const rearPosition = next.position - next.car.length / 2;
            const frontPosition = this.position + this.car.length / 2;
            return {
                car: next.car,
                distance: rearPosition - frontPosition
            };
        }
        return {
            car: null,
            distance: Infinity
        };
    }
});
module.exports = LanePosition;


/***/ }),

/***/ "./src/model/lane.ts":
/*!***************************!*\
  !*** ./src/model/lane.ts ***!
  \***************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! ../helpers */ "./src/helpers.ts");
const _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/modules/index-all.js");
const Segment = __webpack_require__(/*! ../geom/segment */ "./src/geom/segment.ts");
class Lane {
    constructor(sourceSegment, targetSegment, road) {
        this.sourceSegment = sourceSegment;
        this.targetSegment = targetSegment;
        this.road = road;
        this.leftAdjacent = null;
        this.rightAdjacent = null;
        this.leftmostAdjacent = null;
        this.rightmostAdjacent = null;
        this.carsPositions = {};
        this.id = _.uniqueId('lane');
        this.update();
    }
    toJSON() {
        const obj = _.extend({}, this);
        delete obj.carsPositions;
        return obj;
    }
    get sourceSideId() {
        return this.road.sourceSideId;
    }
    get targetSideId() {
        return this.road.targetSideId;
    }
    get isRightmost() {
        return this === this.rightmostAdjacent;
    }
    get isLeftmost() {
        return this === this.leftmostAdjacent;
    }
    get leftBorder() {
        return new Segment(this.sourceSegment.source, this.targetSegment.target);
    }
    get rightBorder() {
        return new Segment(this.sourceSegment.target, this.targetSegment.source);
    }
    update() {
        this.middleLine = new Segment(this.sourceSegment.center, this.targetSegment.center);
        this.length = this.middleLine.length;
        this.direction = this.middleLine.direction;
    }
    getTurnDirection(other) {
        return this.road.getTurnDirection(other.road);
    }
    getDirection() {
        return this.direction;
    }
    getPoint(a) {
        return this.middleLine.getPoint(a);
    }
    addCarPosition(carPosition) {
        if (carPosition.id in this.carsPositions) {
            throw new Error('car is already here');
        }
        this.carsPositions[carPosition.id] = carPosition;
    }
    removeCar(carPosition) {
        if (!(carPosition.id in this.carsPositions)) {
            throw new Error('removing unknown car');
        }
        delete this.carsPositions[carPosition.id];
    }
    getNext(carPosition) {
        if (carPosition.lane !== this) {
            throw new Error('car is on other lane');
        }
        let next = null;
        let bestDistance = Infinity;
        for (const id in this.carsPositions) {
            const o = this.carsPositions[id];
            const distance = o.position - carPosition.position;
            if (!o.free && 0 < distance && distance < bestDistance) {
                bestDistance = distance;
                next = o;
            }
        }
        return next;
    }
}
// Set up properties using the CoffeeScript-style property decorator
Lane.property('sourceSideId', {
    get: function () {
        return this.road.sourceSideId;
    }
});
Lane.property('targetSideId', {
    get: function () {
        return this.road.targetSideId;
    }
});
Lane.property('isRightmost', {
    get: function () {
        return this === this.rightmostAdjacent;
    }
});
Lane.property('isLeftmost', {
    get: function () {
        return this === this.leftmostAdjacent;
    }
});
Lane.property('leftBorder', {
    get: function () {
        return new Segment(this.sourceSegment.source, this.targetSegment.target);
    }
});
Lane.property('rightBorder', {
    get: function () {
        return new Segment(this.sourceSegment.target, this.targetSegment.source);
    }
});
module.exports = Lane;


/***/ }),

/***/ "./src/model/pool.ts":
/*!***************************!*\
  !*** ./src/model/pool.ts ***!
  \***************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! ../helpers */ "./src/helpers.ts");
class Pool {
    constructor(factory, pool) {
        this.factory = factory;
        this.objects = {};
        if (pool && pool.objects) {
            for (const k in pool.objects) {
                const v = pool.objects[k];
                this.objects[k] = this.factory.copy(v);
            }
        }
    }
    toJSON() {
        return this.objects;
    }
    get(id) {
        return this.objects[id];
    }
    put(obj) {
        this.objects[obj.id] = obj;
    }
    pop(obj) {
        const id = typeof obj === 'string' ? obj : obj.id;
        const result = this.objects[id];
        if (result) {
            if (result.release) {
                result.release();
            }
            delete this.objects[id];
        }
        return result;
    }
    all() {
        return this.objects;
    }
    clear() {
        this.objects = {};
    }
    get length() {
        return Object.keys(this.objects).length;
    }
}
module.exports = Pool;


/***/ }),

/***/ "./src/model/road.ts":
/*!***************************!*\
  !*** ./src/model/road.ts ***!
  \***************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! ../helpers */ "./src/helpers.ts");
const _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/modules/index-all.js");
const Lane = __webpack_require__(/*! ./lane */ "./src/model/lane.ts");
const settings = __webpack_require__(/*! ../settings */ "./src/settings.ts");
const { min, max } = Math;
class Road {
    constructor(source, target) {
        this.source = source;
        this.target = target;
        this.id = _.uniqueId('road');
        this.lanes = [];
        this.lanesNumber = null;
        this.update();
    }
    static copy(road) {
        const result = Object.create(Road.prototype);
        _.extend(result, road);
        if (!result.lanes) {
            result.lanes = [];
        }
        return result;
    }
    toJSON() {
        return {
            id: this.id,
            source: this.source.id,
            target: this.target.id
        };
    }
    get length() {
        return this.targetSide.target.subtract(this.sourceSide.source).length;
    }
    get leftmostLane() {
        return this.lanes[this.lanesNumber - 1];
    }
    get rightmostLane() {
        return this.lanes[0];
    }
    getTurnDirection(other) {
        if (this.target !== other.source) {
            throw new Error('invalid roads');
        }
        const side1 = this.targetSideId;
        const side2 = other.sourceSideId;
        // 0 - left, 1 - forward, 2 - right
        const turnNumber = (side2 - side1 - 1 + 8) % 4;
        return turnNumber;
    }
    update() {
        if (!this.source || !this.target) {
            throw new Error('incomplete road');
        }
        this.sourceSideId = this.source.rect.getSectorId(this.target.rect.center());
        this.sourceSide = this.source.rect.getSide(this.sourceSideId).subsegment(0.5, 1.0);
        this.targetSideId = this.target.rect.getSectorId(this.source.rect.center());
        this.targetSide = this.target.rect.getSide(this.targetSideId).subsegment(0, 0.5);
        this.lanesNumber = min(this.sourceSide.length, this.targetSide.length) | 0;
        this.lanesNumber = max(2, (this.lanesNumber / settings.gridSize) | 0);
        const sourceSplits = this.sourceSide.split(this.lanesNumber, true);
        const targetSplits = this.targetSide.split(this.lanesNumber);
        if (!this.lanes || this.lanes.length < this.lanesNumber) {
            if (!this.lanes) {
                this.lanes = [];
            }
            for (let i = 0; i < this.lanesNumber; i++) {
                if (!this.lanes[i]) {
                    this.lanes[i] = new Lane(sourceSplits[i], targetSplits[i], this);
                }
            }
        }
        for (let i = 0; i < this.lanesNumber; i++) {
            this.lanes[i].sourceSegment = sourceSplits[i];
            this.lanes[i].targetSegment = targetSplits[i];
            this.lanes[i].leftAdjacent = this.lanes[i + 1] || null;
            this.lanes[i].rightAdjacent = this.lanes[i - 1] || null;
            this.lanes[i].leftmostAdjacent = this.lanes[this.lanesNumber - 1];
            this.lanes[i].rightmostAdjacent = this.lanes[0];
            this.lanes[i].update();
        }
    }
}
// Set up properties using the CoffeeScript-style property decorator
Road.property('length', {
    get: function () {
        return this.targetSide.target.subtract(this.sourceSide.source).length;
    }
});
Road.property('leftmostLane', {
    get: function () {
        return this.lanes[this.lanesNumber - 1];
    }
});
Road.property('rightmostLane', {
    get: function () {
        return this.lanes[0];
    }
});
module.exports = Road;


/***/ }),

/***/ "./src/model/traffic-control/AbstractTrafficControlStrategy.ts":
/*!*********************************************************************!*\
  !*** ./src/model/traffic-control/AbstractTrafficControlStrategy.ts ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * AbstractTrafficControlStrategy
 *
 * Base class for implementing traffic control strategies.
 * Provides common functionality and default implementations.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbstractTrafficControlStrategy = void 0;
/**
 * Abstract base class for traffic control strategies
 */
class AbstractTrafficControlStrategy {
    constructor() {
        /** Reference to the intersection being controlled */
        this.intersection = null;
        /** Current phase number */
        this.currentPhase = 0;
        /** Total phases in cycle */
        this.totalPhases = 4;
        /** Time elapsed in current phase */
        this.timeInPhase = 0;
        /** Time when current phase should end */
        this.nextPhaseChangeTime = 0;
        /** Base duration for each phase (can be overridden by concrete implementations) */
        this.phaseDuration = 30; // seconds
        /** Configuration options specific to this strategy */
        this.configOptions = {};
    }
    /**
     * Initialize the traffic control strategy for a specific intersection
     */
    initialize(intersection) {
        this.intersection = intersection;
        this.reset();
    }
    /**
     * Update the traffic signals based on current traffic conditions
     */
    update(delta, trafficStates) {
        // Increment time in current phase
        this.timeInPhase += delta;
        // Check if it's time to change phases
        if (this.shouldSwitchPhase(trafficStates)) {
            this.advanceToNextPhase();
        }
        // Return current signal states
        return this.getCurrentSignalStates();
    }
    /**
     * Reset the strategy to its initial state
     */
    reset() {
        this.currentPhase = 0;
        this.timeInPhase = 0;
        this.nextPhaseChangeTime = this.getPhaseDuration();
    }
    /**
     * Get the current phase number
     */
    getCurrentPhase() {
        return this.currentPhase;
    }
    /**
     * Get the total number of phases
     */
    getTotalPhases() {
        return this.totalPhases;
    }
    /**
     * Get configuration options
     */
    getConfigOptions() {
        return { ...this.configOptions };
    }
    /**
     * Get the current signal states without updating
     * This method exposes the protected method to satisfy the interface
     */
    getCurrentSignalStates() {
        return this.getSignalStates();
    }
    /**
     * Update configuration options
     */
    updateConfig(options) {
        this.configOptions = { ...this.configOptions, ...options };
    }
    /**
     * Convert to JSON
     */
    toJSON() {
        return {
            strategyType: this.strategyType,
            currentPhase: this.currentPhase,
            timeInPhase: this.timeInPhase,
            totalPhases: this.totalPhases,
            phaseDuration: this.phaseDuration,
            configOptions: this.configOptions
        };
    }
    /**
     * Create from JSON
     */
    fromJSON(data, intersection) {
        throw new Error('Method must be implemented by concrete strategy class');
    }
    /**
     * Check if the signal phase should be changed
     * Can be overridden by concrete implementations for more sophisticated logic
     */
    shouldSwitchPhase(trafficStates) {
        return this.timeInPhase >= this.nextPhaseChangeTime;
    }
    /**
     * Advance to the next phase
     */
    advanceToNextPhase() {
        this.currentPhase = (this.currentPhase + 1) % this.totalPhases;
        this.timeInPhase = 0;
        this.nextPhaseChangeTime = this.getPhaseDuration();
    }
    /**
     * Get the duration for the current phase
     * Can be overridden by concrete implementations for variable phase durations
     */
    getPhaseDuration() {
        return this.phaseDuration;
    }
}
exports.AbstractTrafficControlStrategy = AbstractTrafficControlStrategy;


/***/ }),

/***/ "./src/model/traffic-control/AdaptiveTimingStrategy.ts":
/*!*************************************************************!*\
  !*** ./src/model/traffic-control/AdaptiveTimingStrategy.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * AdaptiveTimingStrategy
 *
 * A more advanced traffic control strategy that adapts to traffic conditions.
 * This strategy adjusts phase durations based on queue lengths and waiting times.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AdaptiveTimingStrategy = void 0;
const AbstractTrafficControlStrategy_1 = __webpack_require__(/*! ./AbstractTrafficControlStrategy */ "./src/model/traffic-control/AbstractTrafficControlStrategy.ts");
const settings = __webpack_require__(/*! ../../settings */ "./src/settings.ts");
/**
 * Adaptive timing traffic control strategy
 * Adjusts signal timing based on traffic conditions
 */
class AdaptiveTimingStrategy extends AbstractTrafficControlStrategy_1.AbstractTrafficControlStrategy {
    constructor() {
        super();
        this.strategyType = 'adaptive-timing';
        this.displayName = 'Adaptive Timing';
        this.description = 'Adapts traffic signal timings based on real-time traffic conditions';
        // Traffic signal patterns (same as fixed timing)
        this.states = [
            ['L', '', 'L', ''],
            ['FR', '', 'FR', ''],
            ['', 'L', '', 'L'],
            ['', 'FR', '', 'FR'] // Phase 4: East & West forward and right
        ];
        // Track traffic metrics for each approach
        this.queueLengths = [0, 0, 0, 0]; // N, E, S, W
        this.waitTimes = [0, 0, 0, 0]; // N, E, S, W
        this.flowRates = [0, 0, 0, 0]; // N, E, S, W
        this.congestionScores = [0, 0, 0, 0]; // N, E, S, W
        this.throughputRates = [0, 0, 0, 0]; // Vehicles passing through per minute
        this.saturationRates = [0, 0, 0, 0]; // How saturated the approach is (0-1)
        // Traffic history for trend analysis
        this.queueHistory = [];
        this.waitTimeHistory = [];
        this.flowRateHistory = []; // Track flow rate history for better trend analysis
        this.historyMaxLength = 10;
        // Minimum and maximum phase durations
        this.minPhaseDuration = 10; // seconds
        this.maxPhaseDuration = 60; // seconds
        this.basePhaseDuration = 30; // seconds
        // Algorithm parameters
        this.trafficSensitivity = 0.5; // How reactive to traffic (0-1)
        this.queueWeight = 1.0; // Weight for queue length in scoring
        this.waitTimeWeight = 1.0; // Weight for wait time in scoring
        this.flowRateWeight = 0.5; // Weight for flow rate in scoring
        this.trendWeight = 0.3; // Weight for trend analysis (0-1)
        this.prioritizeLeftTurns = true; // Give extra weight to left turn phases when congested
        this.enableLogging = false; // Enable detailed logging
        this.emergencyMode = false; // Enable emergency mode for extreme congestion
        this.fairnessWeight = 0.5; // Weight for fairness across approaches (0-1)
        // Timing statistics for analysis
        this.phaseDurationHistory = [];
        this.trafficScoreHistory = [];
        this.phaseChanges = 0;
        this.emergencyActivations = 0; // Track emergency mode activations
        this.fairnessMetric = 1.0; // Track fairness across approaches (0-1)
        this.totalPhases = this.states.length;
        this.configOptions = {
            minPhaseDuration: this.minPhaseDuration,
            maxPhaseDuration: this.maxPhaseDuration,
            baseDuration: settings.lightsFlipInterval / 30,
            trafficSensitivity: this.trafficSensitivity,
            queueWeight: this.queueWeight,
            waitTimeWeight: this.waitTimeWeight,
            flowRateWeight: this.flowRateWeight,
            trendWeight: this.trendWeight,
            prioritizeLeftTurns: this.prioritizeLeftTurns,
            enableLogging: this.enableLogging,
            emergencyMode: this.emergencyMode,
            fairnessWeight: this.fairnessWeight
        };
        this.basePhaseDuration = this.configOptions.baseDuration;
        // Initialize history arrays
        this.resetHistory();
    }
    /**
     * Reset traffic history arrays
     */
    resetHistory() {
        this.queueHistory = [];
        this.waitTimeHistory = [];
        this.flowRateHistory = [];
        this.phaseDurationHistory = [];
        this.trafficScoreHistory = [];
        this.phaseChanges = 0;
    }
    /**
     * Initialize the strategy with an intersection
     */
    initialize(intersection) {
        super.initialize(intersection);
        // If it's a 2-way or T-intersection, use a simplified state cycle
        if (intersection.roads && intersection.roads.length <= 2) {
            this.states = [
                ['LFR', 'LFR', 'LFR', 'LFR'] // Single phase allowing all movements
            ];
            this.totalPhases = 1;
        }
        // Initialize metric tracking
        this.queueLengths = [0, 0, 0, 0];
        this.waitTimes = [0, 0, 0, 0];
        this.flowRates = [0, 0, 0, 0];
        this.congestionScores = [0, 0, 0, 0];
        // Reset history arrays
        this.resetHistory();
        // Apply configuration
        this.minPhaseDuration = this.configOptions.minPhaseDuration || 10;
        this.maxPhaseDuration = this.configOptions.maxPhaseDuration || 60;
        this.basePhaseDuration = this.configOptions.baseDuration || 30;
        this.trafficSensitivity = this.configOptions.trafficSensitivity || 0.5;
        this.queueWeight = this.configOptions.queueWeight || 1.0;
        this.waitTimeWeight = this.configOptions.waitTimeWeight || 1.0;
        this.flowRateWeight = this.configOptions.flowRateWeight || 0.5;
        this.trendWeight = this.configOptions.trendWeight || 0.3;
        this.prioritizeLeftTurns = this.configOptions.prioritizeLeftTurns !== undefined ?
            this.configOptions.prioritizeLeftTurns : true;
        this.enableLogging = this.configOptions.enableLogging || false;
        this.emergencyMode = this.configOptions.emergencyMode || false;
        this.fairnessWeight = this.configOptions.fairnessWeight || 0.5;
        if (this.enableLogging) {
            console.log(`[AdaptiveStrategy] Initialized for intersection ${intersection.id}`);
            console.log(`[AdaptiveStrategy] Config: minDur=${this.minPhaseDuration}s, maxDur=${this.maxPhaseDuration}s, sensitivity=${this.trafficSensitivity}`);
        }
    }
    /**
     * Update the strategy based on elapsed time and traffic conditions
     */
    update(delta, trafficStates) {
        // Add to time in current phase
        this.timeInPhase += delta;
        // Process traffic states if available
        if (trafficStates && trafficStates.length > 0) {
            // This will update internal traffic metrics
            const shouldSwitch = this.shouldSwitchPhase(trafficStates);
            // If it's time to switch, advance to next phase
            if (shouldSwitch) {
                this.advanceToNextPhase();
            }
        }
        else {
            // Default behavior without traffic data
            if (this.timeInPhase >= this.nextPhaseChangeTime) {
                this.advanceToNextPhase();
            }
        }
        // Return current signal states
        return this.getSignalStates();
    }
    /**
     * Update configuration options
     */
    updateConfig(options) {
        super.updateConfig(options);
        // Update internal parameters based on config
        if (options.minPhaseDuration !== undefined)
            this.minPhaseDuration = options.minPhaseDuration;
        if (options.maxPhaseDuration !== undefined)
            this.maxPhaseDuration = options.maxPhaseDuration;
        if (options.baseDuration !== undefined)
            this.basePhaseDuration = options.baseDuration;
        if (options.trafficSensitivity !== undefined)
            this.trafficSensitivity = options.trafficSensitivity;
        if (options.queueWeight !== undefined)
            this.queueWeight = options.queueWeight;
        if (options.waitTimeWeight !== undefined)
            this.waitTimeWeight = options.waitTimeWeight;
        if (options.flowRateWeight !== undefined)
            this.flowRateWeight = options.flowRateWeight;
        if (options.trendWeight !== undefined)
            this.trendWeight = options.trendWeight;
        if (options.prioritizeLeftTurns !== undefined)
            this.prioritizeLeftTurns = options.prioritizeLeftTurns;
        if (options.enableLogging !== undefined)
            this.enableLogging = options.enableLogging;
        if (options.emergencyMode !== undefined)
            this.emergencyMode = options.emergencyMode;
        if (options.fairnessWeight !== undefined)
            this.fairnessWeight = options.fairnessWeight;
        if (this.enableLogging) {
            console.log(`[AdaptiveStrategy] Configuration updated`);
        }
    }
    /**
     * Reset the strategy to initial state
     */
    reset() {
        super.reset();
        // Reset traffic metrics
        this.queueLengths = [0, 0, 0, 0];
        this.waitTimes = [0, 0, 0, 0];
        this.flowRates = [0, 0, 0, 0];
        this.congestionScores = [0, 0, 0, 0];
        // Reset history
        this.resetHistory();
        if (this.enableLogging) {
            console.log(`[AdaptiveStrategy] Reset to initial state`);
        }
    }
    /**
     * Check if the signal phase should be changed based on traffic conditions
     * Overrides the base implementation to add adaptive logic
     */
    shouldSwitchPhase(trafficStates) {
        // Standard time-based check
        const timeBasedSwitch = this.timeInPhase >= this.nextPhaseChangeTime;
        // If we have traffic state data, we can do more sophisticated checks
        if (trafficStates && trafficStates.length > 0) {
            // Has minimum time elapsed?
            if (this.timeInPhase < this.minPhaseDuration) {
                return false; // Don't switch before minimum time
            }
            // Update traffic metrics with latest data
            this.updateTrafficMetrics(trafficStates);
            // Get traffic demand for current phase and all other phases
            const currentDirections = this.getActiveDirectionsForPhase(this.currentPhase);
            const currentTraffic = this.getTrafficDemandForDirections(currentDirections);
            // Find the phase with the highest demand
            let maxTraffic = 0;
            let maxTrafficPhase = this.currentPhase;
            for (let i = 0; i < this.totalPhases; i++) {
                if (i !== this.currentPhase) {
                    const phaseDirections = this.getActiveDirectionsForPhase(i);
                    const phaseTraffic = this.getTrafficDemandForDirections(phaseDirections);
                    if (phaseTraffic > maxTraffic) {
                        maxTraffic = phaseTraffic;
                        maxTrafficPhase = i;
                    }
                }
            }
            // Early switch conditions
            const nextPhase = (this.currentPhase + 1) % this.totalPhases;
            const nextTraffic = this.getTrafficDemandForDirections(this.getActiveDirectionsForPhase(nextPhase));
            // Switch early under specific conditions
            if (this.timeInPhase >= this.nextPhaseChangeTime * 0.75) {
                // If the next phase has substantially more demand, switch early
                if (nextTraffic > currentTraffic * 2) {
                    if (this.enableLogging) {
                        console.log(`[AdaptiveStrategy] Early switch: next phase has ${nextTraffic.toFixed(1)} demand vs current ${currentTraffic.toFixed(1)}`);
                    }
                    return true;
                }
                // If another phase has extremely high demand, consider switching directly to it
                if (maxTraffic > currentTraffic * 3 && maxTraffic > nextTraffic * 2) {
                    if (this.enableLogging) {
                        console.log(`[AdaptiveStrategy] Emergency switch: phase ${maxTrafficPhase + 1} has critical demand ${maxTraffic.toFixed(1)}`);
                    }
                    // Set the next phase to the one with highest demand
                    this.currentPhase = maxTrafficPhase - 1;
                    if (this.currentPhase < 0)
                        this.currentPhase = this.totalPhases - 1;
                    return true;
                }
            }
            // Extend phase if it has significant traffic and hasn't reached max duration
            if (currentTraffic > 0 && this.timeInPhase < this.maxPhaseDuration) {
                // If current phase has more traffic than the next AND we're still processing vehicles
                if (currentTraffic > nextTraffic * 0.8 && timeBasedSwitch) {
                    const remainingPercent = Math.min(1, (currentTraffic - nextTraffic) / currentTraffic);
                    // Extend up to 50% of base duration based on remaining traffic
                    const extensionTime = this.basePhaseDuration * 0.5 * remainingPercent;
                    if (this.timeInPhase < this.nextPhaseChangeTime + extensionTime &&
                        this.timeInPhase < this.maxPhaseDuration) {
                        if (this.enableLogging && this.timeInPhase >= this.nextPhaseChangeTime) {
                            console.log(`[AdaptiveStrategy] Extending phase ${this.currentPhase + 1} by ${extensionTime.toFixed(1)}s due to continuing traffic`);
                        }
                        return false;
                    }
                }
            }
            // If current phase has no traffic but next phase does, switch immediately
            // after minimum time has passed
            if (currentTraffic === 0 && nextTraffic > 0 && this.timeInPhase >= this.minPhaseDuration) {
                if (this.enableLogging) {
                    console.log(`[AdaptiveStrategy] Early switch: current phase empty, next phase has traffic`);
                }
                return true;
            }
        }
        // If we're past the scheduled time, make the switch
        if (timeBasedSwitch) {
            return true;
        }
        return false;
    }
    /**
     * Update internal traffic metrics based on traffic state
     */
    updateTrafficMetrics(trafficStates) {
        // Store previous metrics for trend analysis
        const previousQueues = [...this.queueLengths];
        const previousWaits = [...this.waitTimes];
        const previousFlows = [...this.flowRates];
        // Update current metrics
        for (let i = 0; i < trafficStates.length; i++) {
            if (i < this.queueLengths.length) {
                this.queueLengths[i] = trafficStates[i].queueLength;
                this.waitTimes[i] = trafficStates[i].averageWaitTime;
                this.flowRates[i] = trafficStates[i].flowRate;
                // Calculate throughput rates - if data is available in the traffic state
                this.throughputRates[i] = trafficStates[i].flowRate || 0;
                // Calculate saturation rates - queue length compared to an estimated capacity
                // Higher values indicate more saturation
                const estimatedCapacity = 10; // Estimated capacity per lane
                this.saturationRates[i] = Math.min(1.0, this.queueLengths[i] / estimatedCapacity);
            }
        }
        // Update congestion scores based on metrics
        this.updateCongestionScores();
        // Add to history for trend analysis
        this.queueHistory.push([...this.queueLengths]);
        this.waitTimeHistory.push([...this.waitTimes]);
        this.flowRateHistory.push([...this.flowRates]);
        // Limit history length
        if (this.queueHistory.length > this.historyMaxLength) {
            this.queueHistory.shift();
            this.waitTimeHistory.shift();
            this.flowRateHistory.shift();
        }
        // Check for emergency conditions
        this.checkEmergencyConditions();
        // Calculate fairness across approaches
        this.calculateFairness();
        // Log metrics if logging is enabled
        if (this.enableLogging) {
            console.log(`[AdaptiveStrategy] Traffic metrics updated: Q=${this.queueLengths.join(',')}, W=${this.waitTimes.join(',')}, F=${this.flowRates.join(',')}`);
            console.log(`[AdaptiveStrategy] Saturation rates: ${this.saturationRates.map(r => r.toFixed(2)).join(', ')}`);
        }
    }
    /**
     * Calculate congestion scores for each direction
     * Higher score = more congested
     */
    updateCongestionScores() {
        for (let i = 0; i < 4; i++) {
            // Normalize each metric to a 0-10 scale
            const queueScore = Math.min(10, this.queueLengths[i] / 2);
            const waitScore = Math.min(10, this.waitTimes[i] / 30);
            const flowScore = this.flowRates[i] > 0 ? 10 / Math.max(1, this.flowRates[i]) : 10;
            const saturationScore = this.saturationRates[i] * 10; // Convert 0-1 to 0-10
            // Combine scores with weights
            this.congestionScores[i] = (queueScore * this.queueWeight +
                waitScore * this.waitTimeWeight +
                flowScore * this.flowRateWeight +
                saturationScore * this.flowRateWeight // Use same weight as flow rate for now
            ) / (this.queueWeight + this.waitTimeWeight + this.flowRateWeight * 2);
            // Apply trend analysis if we have history
            if (this.queueHistory.length >= 3) {
                const queueTrend = this.calculateTrend(i, this.queueHistory);
                const waitTrend = this.calculateTrend(i, this.waitTimeHistory);
                const flowTrend = this.calculateTrend(i, this.flowRateHistory);
                // If trends are increasing (positive), increase congestion score
                // Weight queue trend highest, then wait time, then flow
                const trendFactor = (queueTrend * 0.5 + waitTrend * 0.3 + flowTrend * 0.2);
                if (trendFactor > 0) {
                    this.congestionScores[i] += trendFactor * this.trendWeight;
                }
            }
            // Apply fairness adjustment if fairness weight is > 0 
            if (this.fairnessWeight > 0 && this.fairnessMetric < 1.0) {
                // If this direction has been underserved (higher wait times),
                // boost its congestion score to give it higher priority
                const avgWait = this.waitTimes[i];
                const maxWait = Math.max(...this.waitTimes);
                if (avgWait > 0 && avgWait >= maxWait * 0.8) {
                    const fairnessBoost = (avgWait / maxWait) * this.fairnessWeight * 2;
                    this.congestionScores[i] += fairnessBoost;
                }
            }
        }
    }
    /**
     * Calculate trend for a specific direction and metric
     * Returns a value between -1 and 1 (negative = decreasing, positive = increasing)
     */
    calculateTrend(direction, history) {
        if (history.length < 3)
            return 0;
        // Get last 3 values
        const recent = history.slice(-3).map(h => h[direction]);
        // Simple trend calculation
        if (recent[2] > recent[1] && recent[1] > recent[0]) {
            // Consistently increasing
            return 1.0;
        }
        else if (recent[2] < recent[1] && recent[1] < recent[0]) {
            // Consistently decreasing
            return -1.0;
        }
        else if (recent[2] > recent[0]) {
            // Net increase
            return 0.5;
        }
        else if (recent[2] < recent[0]) {
            // Net decrease
            return -0.5;
        }
        // No clear trend
        return 0;
    }
    /**
     * Get the active directions for a specific phase
     * Returns array of direction indices (0=N, 1=E, 2=S, 3=W)
     */
    getActiveDirectionsForPhase(phase) {
        const phaseState = this.states[phase % this.states.length];
        const directions = [];
        for (let i = 0; i < phaseState.length; i++) {
            if (phaseState[i].length > 0) {
                directions.push(i);
            }
        }
        return directions;
    }
    /**
     * Calculate traffic demand for given directions
     * Returns a score based on congestion scores
     */
    getTrafficDemandForDirections(directions) {
        let demand = 0;
        for (const dir of directions) {
            // Use comprehensive congestion score
            demand += this.congestionScores[dir];
            // Add bonus for left turn phases if configured
            if (this.prioritizeLeftTurns) {
                const phaseIdx = this.currentPhase % this.states.length;
                const phaseState = this.states[phaseIdx][dir];
                if (phaseState.includes('L')) {
                    demand *= 1.2; // 20% bonus for left turn phases when congested
                }
            }
        }
        return demand;
    }
    /**
     * Get the duration for the current phase based on traffic conditions
     */
    getPhaseDuration() {
        const baseDuration = this.configOptions.baseDuration || 30; // seconds
        const sensitivity = this.configOptions.trafficSensitivity || 0.5;
        // If we don't have traffic data, use base duration
        if (this.queueLengths.every(q => q === 0) && this.waitTimes.every(w => w === 0)) {
            if (this.enableLogging) {
                console.log(`[AdaptiveStrategy] No traffic data, using base duration: ${baseDuration}s`);
            }
            return baseDuration;
        }
        // Get directions active in current phase
        const currentDirections = this.getActiveDirectionsForPhase(this.currentPhase);
        const currentTraffic = this.getTrafficDemandForDirections(currentDirections);
        // Check other phases' demand to determine relative importance
        let totalDemand = currentTraffic;
        let maxOtherDemand = 0;
        for (let i = 0; i < this.totalPhases; i++) {
            if (i !== this.currentPhase) {
                const phaseDemand = this.getTrafficDemandForDirections(this.getActiveDirectionsForPhase(i));
                totalDemand += phaseDemand;
                maxOtherDemand = Math.max(maxOtherDemand, phaseDemand);
            }
        }
        // Calculate phase importance as ratio of its demand to total demand
        const phaseImportance = totalDemand > 0 ? currentTraffic / totalDemand : 0;
        // Calculate adjusted duration
        let adjustedDuration;
        if (maxOtherDemand > currentTraffic * 2) {
            // If another phase has much more demand, shorten this phase
            adjustedDuration = this.minPhaseDuration;
        }
        else {
            // Normal adjustment based on demand
            const trafficFactor = Math.min(1.0, currentTraffic / 20); // Cap at 20 units of demand
            const importanceFactor = Math.max(0.2, phaseImportance * 2); // Min 0.2, max 2.0
            const durationAdjustment = sensitivity * trafficFactor * importanceFactor * (this.maxPhaseDuration - baseDuration);
            adjustedDuration = Math.min(this.maxPhaseDuration, Math.max(this.minPhaseDuration, baseDuration + durationAdjustment));
        }
        // Store for analysis
        this.phaseDurationHistory.push(adjustedDuration);
        this.trafficScoreHistory.push(currentTraffic);
        if (this.enableLogging) {
            console.log(`[AdaptiveStrategy] Phase ${this.currentPhase + 1}: traffic=${currentTraffic.toFixed(1)}, ` +
                `importance=${phaseImportance.toFixed(2)}, duration=${adjustedDuration.toFixed(1)}s`);
        }
        return adjustedDuration;
    }
    /**
     * Get the current signal states
     */
    getSignalStates() {
        const stringState = this.states[this.currentPhase % this.states.length];
        // For 2-way or T-intersections, always allow all movements
        if (this.intersection && this.intersection.roads && this.intersection.roads.length <= 2) {
            return [
                this._decode('LFR'),
                this._decode('LFR'),
                this._decode('LFR'),
                this._decode('LFR')
            ];
        }
        // Convert string patterns to numeric state arrays
        return stringState.map(x => this._decode(x));
    }
    /**
     * Convert string representation to numeric state array
     * e.g., "LFR" -> [1,1,1] (left, forward, right allowed)
     */
    _decode(str) {
        const state = [0, 0, 0];
        if (str.includes('L'))
            state[0] = 1;
        if (str.includes('F'))
            state[1] = 1;
        if (str.includes('R'))
            state[2] = 1;
        return state;
    }
    /**
     * Add a custom phase advancement method that tracks changes
     */
    advanceToNextPhase() {
        const oldPhase = this.currentPhase;
        // Call parent implementation
        super.advanceToNextPhase();
        // Track phase changes
        this.phaseChanges++;
        if (this.enableLogging) {
            console.log(`[AdaptiveStrategy] Phase changed: ${oldPhase + 1} → ${this.currentPhase + 1}`);
        }
    }
    /**
     * Check for emergency traffic conditions that require immediate intervention
     */
    checkEmergencyConditions() {
        // Check if any direction has extreme congestion
        let emergencyDetected = false;
        let emergencyDirection = -1;
        for (let i = 0; i < 4; i++) {
            // Define emergency conditions:
            // 1. Very high queue length (> 15)
            // 2. Very high wait time (> 60 seconds)
            // 3. Very low flow rate combined with high queue
            const criticalQueue = this.queueLengths[i] > 15;
            const criticalWait = this.waitTimes[i] > 60;
            const criticalFlow = this.flowRates[i] < 1 && this.queueLengths[i] > 10;
            // Consistent growth trend is another emergency indicator
            let growingTrend = false;
            if (this.queueHistory.length >= 5) {
                const trendFactor = this.calculateTrend(i, this.queueHistory);
                growingTrend = trendFactor > 0.8; // Strong upward trend
            }
            if ((criticalQueue || criticalWait || criticalFlow) && growingTrend) {
                emergencyDetected = true;
                emergencyDirection = i;
                break;
            }
        }
        // If emergency detected and emergency mode is enabled in config
        if (emergencyDetected && this.configOptions.emergencyMode) {
            // Check if we're not already servicing this direction
            const currentDirections = this.getActiveDirectionsForPhase(this.currentPhase);
            if (!currentDirections.includes(emergencyDirection)) {
                if (this.enableLogging) {
                    console.log(`[AdaptiveStrategy] 🚨 EMERGENCY condition detected in direction ${emergencyDirection}`);
                }
                // Find the phase that serves this direction
                let targetPhase = -1;
                for (let i = 0; i < this.totalPhases; i++) {
                    const phaseDirections = this.getActiveDirectionsForPhase(i);
                    if (phaseDirections.includes(emergencyDirection)) {
                        targetPhase = i;
                        break;
                    }
                }
                if (targetPhase >= 0 && this.timeInPhase > this.minPhaseDuration) {
                    // Force switch to this phase on next update
                    this.currentPhase = targetPhase - 1;
                    if (this.currentPhase < 0)
                        this.currentPhase = this.totalPhases - 1;
                    this.timeInPhase = this.nextPhaseChangeTime; // Force a phase change
                    this.emergencyActivations++;
                    if (this.enableLogging) {
                        console.log(`[AdaptiveStrategy] Emergency action: Switching to phase ${targetPhase} to address congestion`);
                    }
                }
            }
        }
    }
    /**
     * Calculate fairness metric across approaches
     * A value of 1.0 means perfectly balanced service
     * Lower values indicate some directions are underserved
     */
    calculateFairness() {
        // Calculate service time ratio between most and least served directions
        if (this.phaseDurationHistory.length < this.totalPhases) {
            this.fairnessMetric = 1.0; // Not enough data yet
            return;
        }
        // Get average wait times by direction
        const avgWaitByDirection = [...this.waitTimes];
        // If any wait times are zero, set a minimum value
        for (let i = 0; i < avgWaitByDirection.length; i++) {
            if (avgWaitByDirection[i] === 0)
                avgWaitByDirection[i] = 0.1;
        }
        // Calculate max/min ratio
        const maxWait = Math.max(...avgWaitByDirection);
        const minWait = Math.min(...avgWaitByDirection);
        // Invert and normalize to 0-1 range (1 = perfectly fair, 0 = completely unfair)
        this.fairnessMetric = minWait / maxWait;
        if (this.enableLogging && this.fairnessMetric < 0.5) {
            console.log(`[AdaptiveStrategy] Fairness alert: Low fairness metric ${this.fairnessMetric.toFixed(2)}`);
        }
    }
    /**
     * Get performance analytics for this strategy
     */
    getPerformanceAnalytics() {
        // Calculate statistics
        const durations = this.phaseDurationHistory;
        const trafficScores = this.trafficScoreHistory;
        const phaseDurationAvg = durations.length > 0 ?
            durations.reduce((sum, val) => sum + val, 0) / durations.length : 0;
        const phaseDurationMin = durations.length > 0 ? Math.min(...durations) : 0;
        const phaseDurationMax = durations.length > 0 ? Math.max(...durations) : 0;
        const trafficScoreAvg = trafficScores.length > 0 ?
            trafficScores.reduce((sum, val) => sum + val, 0) / trafficScores.length : 0;
        // Calculate adaptation rate (how much timing varies from base duration)
        let totalVariation = 0;
        const baseDuration = this.basePhaseDuration;
        for (const duration of durations) {
            totalVariation += Math.abs(duration - baseDuration) / baseDuration;
        }
        const adaptationRate = durations.length > 0 ? totalVariation / durations.length : 0;
        return {
            phaseDurationAvg,
            phaseDurationMin,
            phaseDurationMax,
            phaseChanges: this.phaseChanges,
            trafficScoreAvg,
            congestionScores: [...this.congestionScores],
            saturationRates: [...this.saturationRates],
            adaptationRate,
            fairnessMetric: this.fairnessMetric,
            emergencyActivations: this.emergencyActivations,
            throughputRates: [...this.throughputRates]
        };
    }
    /**
     * Create from JSON
     */
    fromJSON(data, intersection) {
        // Initialize with the intersection
        this.initialize(intersection);
        // Restore state from data
        if (data.currentPhase !== undefined) {
            this.currentPhase = data.currentPhase;
        }
        if (data.timeInPhase !== undefined) {
            this.timeInPhase = data.timeInPhase;
        }
        if (data.totalPhases !== undefined) {
            this.totalPhases = data.totalPhases;
        }
        if (data.phaseDuration !== undefined) {
            this.phaseDuration = data.phaseDuration;
        }
        // Restore states array if present
        if (data.states) {
            this.states = data.states;
        }
        // Restore adaptive timing specific properties
        if (data.minPhaseDuration !== undefined)
            this.minPhaseDuration = data.minPhaseDuration;
        if (data.maxPhaseDuration !== undefined)
            this.maxPhaseDuration = data.maxPhaseDuration;
        if (data.basePhaseDuration !== undefined)
            this.basePhaseDuration = data.basePhaseDuration;
        if (data.trafficSensitivity !== undefined)
            this.trafficSensitivity = data.trafficSensitivity;
        if (data.queueWeight !== undefined)
            this.queueWeight = data.queueWeight;
        if (data.waitTimeWeight !== undefined)
            this.waitTimeWeight = data.waitTimeWeight;
        if (data.flowRateWeight !== undefined)
            this.flowRateWeight = data.flowRateWeight;
        if (data.trendWeight !== undefined)
            this.trendWeight = data.trendWeight;
        if (data.prioritizeLeftTurns !== undefined)
            this.prioritizeLeftTurns = data.prioritizeLeftTurns;
        if (data.enableLogging !== undefined)
            this.enableLogging = data.enableLogging;
        if (data.emergencyMode !== undefined)
            this.emergencyMode = data.emergencyMode;
        if (data.fairnessWeight !== undefined)
            this.fairnessWeight = data.fairnessWeight;
        // Restore metrics
        if (data.queueLengths)
            this.queueLengths = data.queueLengths;
        if (data.waitTimes)
            this.waitTimes = data.waitTimes;
        if (data.flowRates)
            this.flowRates = data.flowRates;
        if (data.congestionScores)
            this.congestionScores = data.congestionScores;
        if (data.throughputRates)
            this.throughputRates = data.throughputRates;
        if (data.saturationRates)
            this.saturationRates = data.saturationRates;
        if (data.fairnessMetric !== undefined)
            this.fairnessMetric = data.fairnessMetric;
        if (data.emergencyActivations !== undefined)
            this.emergencyActivations = data.emergencyActivations;
        // Restore history arrays
        if (data.queueHistory)
            this.queueHistory = data.queueHistory;
        if (data.waitTimeHistory)
            this.waitTimeHistory = data.waitTimeHistory;
        if (data.flowRateHistory)
            this.flowRateHistory = data.flowRateHistory;
        if (data.phaseDurationHistory)
            this.phaseDurationHistory = data.phaseDurationHistory;
        if (data.trafficScoreHistory)
            this.trafficScoreHistory = data.trafficScoreHistory;
        if (data.phaseChanges !== undefined)
            this.phaseChanges = data.phaseChanges;
        // Restore configuration
        if (data.configOptions) {
            this.configOptions = { ...this.configOptions, ...data.configOptions };
        }
        if (this.enableLogging) {
            console.log(`Restored AdaptiveTimingStrategy from saved data for intersection ${intersection.id}`);
        }
        return this;
    }
    /**
     * Create strategy from JSON data (static factory method)
     */
    static fromJSON(data, intersection) {
        const strategy = new AdaptiveTimingStrategy();
        // Restore state from data
        if (data.currentPhase !== undefined) {
            strategy.currentPhase = data.currentPhase;
        }
        if (data.timeInPhase !== undefined) {
            strategy.timeInPhase = data.timeInPhase;
        }
        if (data.totalPhases !== undefined) {
            strategy.totalPhases = data.totalPhases;
        }
        if (data.phaseDuration !== undefined) {
            strategy.phaseDuration = data.phaseDuration;
        }
        // Restore states array if present
        if (data.states) {
            strategy.states = data.states;
        }
        // Restore adaptive timing specific properties
        if (data.minPhaseDuration !== undefined)
            strategy.minPhaseDuration = data.minPhaseDuration;
        if (data.maxPhaseDuration !== undefined)
            strategy.maxPhaseDuration = data.maxPhaseDuration;
        if (data.basePhaseDuration !== undefined)
            strategy.basePhaseDuration = data.basePhaseDuration;
        if (data.trafficSensitivity !== undefined)
            strategy.trafficSensitivity = data.trafficSensitivity;
        if (data.queueWeight !== undefined)
            strategy.queueWeight = data.queueWeight;
        if (data.waitTimeWeight !== undefined)
            strategy.waitTimeWeight = data.waitTimeWeight;
        if (data.flowRateWeight !== undefined)
            strategy.flowRateWeight = data.flowRateWeight;
        if (data.trendWeight !== undefined)
            strategy.trendWeight = data.trendWeight;
        if (data.prioritizeLeftTurns !== undefined)
            strategy.prioritizeLeftTurns = data.prioritizeLeftTurns;
        if (data.enableLogging !== undefined)
            strategy.enableLogging = data.enableLogging;
        if (data.emergencyMode !== undefined)
            strategy.emergencyMode = data.emergencyMode;
        if (data.fairnessWeight !== undefined)
            strategy.fairnessWeight = data.fairnessWeight;
        // Restore metrics
        if (data.queueLengths)
            strategy.queueLengths = data.queueLengths;
        if (data.waitTimes)
            strategy.waitTimes = data.waitTimes;
        if (data.flowRates)
            strategy.flowRates = data.flowRates;
        if (data.congestionScores)
            strategy.congestionScores = data.congestionScores;
        if (data.throughputRates)
            strategy.throughputRates = data.throughputRates;
        if (data.saturationRates)
            strategy.saturationRates = data.saturationRates;
        if (data.fairnessMetric !== undefined)
            strategy.fairnessMetric = data.fairnessMetric;
        if (data.emergencyActivations !== undefined)
            strategy.emergencyActivations = data.emergencyActivations;
        // Restore history arrays
        if (data.queueHistory)
            strategy.queueHistory = data.queueHistory;
        if (data.waitTimeHistory)
            strategy.waitTimeHistory = data.waitTimeHistory;
        if (data.flowRateHistory)
            strategy.flowRateHistory = data.flowRateHistory;
        if (data.phaseDurationHistory)
            strategy.phaseDurationHistory = data.phaseDurationHistory;
        if (data.trafficScoreHistory)
            strategy.trafficScoreHistory = data.trafficScoreHistory;
        if (data.phaseChanges !== undefined)
            strategy.phaseChanges = data.phaseChanges;
        // Restore configuration
        if (data.configOptions) {
            strategy.configOptions = { ...strategy.configOptions, ...data.configOptions };
        }
        strategy.initialize(intersection);
        return strategy;
    }
    /**
     * Convert to JSON
     */
    toJSON() {
        return {
            ...super.toJSON(),
            minPhaseDuration: this.minPhaseDuration,
            maxPhaseDuration: this.maxPhaseDuration,
            basePhaseDuration: this.basePhaseDuration,
            trafficSensitivity: this.trafficSensitivity,
            queueWeight: this.queueWeight,
            waitTimeWeight: this.waitTimeWeight,
            flowRateWeight: this.flowRateWeight,
            trendWeight: this.trendWeight,
            prioritizeLeftTurns: this.prioritizeLeftTurns,
            enableLogging: this.enableLogging,
            emergencyMode: this.emergencyMode,
            fairnessWeight: this.fairnessWeight,
            // Current metrics
            states: this.states,
            queueLengths: this.queueLengths,
            waitTimes: this.waitTimes,
            flowRates: this.flowRates,
            congestionScores: this.congestionScores,
            throughputRates: this.throughputRates,
            saturationRates: this.saturationRates,
            fairnessMetric: this.fairnessMetric,
            emergencyActivations: this.emergencyActivations,
            // History data (limited for size)
            queueHistory: this.queueHistory.slice(-5),
            waitTimeHistory: this.waitTimeHistory.slice(-5),
            flowRateHistory: this.flowRateHistory.slice(-5),
            phaseDurationHistory: this.phaseDurationHistory.slice(-10),
            trafficScoreHistory: this.trafficScoreHistory.slice(-10),
            phaseChanges: this.phaseChanges,
            // Analysis
            analytics: this.getPerformanceAnalytics()
        };
    }
}
exports.AdaptiveTimingStrategy = AdaptiveTimingStrategy;


/***/ }),

/***/ "./src/model/traffic-control/AllRedFlashingStrategy.ts":
/*!*************************************************************!*\
  !*** ./src/model/traffic-control/AllRedFlashingStrategy.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * AllRedFlashingStrategy
 *
 * A special traffic control strategy that simulates an emergency mode where all
 * signals flash red, requiring vehicles to treat the intersection as an all-way stop.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AllRedFlashingStrategy = void 0;
const AbstractTrafficControlStrategy_1 = __webpack_require__(/*! ./AbstractTrafficControlStrategy */ "./src/model/traffic-control/AbstractTrafficControlStrategy.ts");
/**
 * All-Red Flashing Strategy
 * Simulates emergency conditions or power outage at intersection
 */
class AllRedFlashingStrategy extends AbstractTrafficControlStrategy_1.AbstractTrafficControlStrategy {
    constructor() {
        super();
        this.strategyType = 'all-red-flashing';
        this.displayName = 'All-Red Flashing';
        this.description = 'All approaches flash red - simulates emergency conditions';
        // Track whether signals are currently visible or not (for flashing effect)
        this.signalsVisible = true;
        // Flashing interval in seconds
        this.flashInterval = 1.0; // 1 second on, 1 second off
        this.timeInFlashState = 0;
        this.totalPhases = 1; // Only one phase (all red)
        this.configOptions = {
            flashInterval: this.flashInterval
        };
    }
    /**
     * Update the traffic signals with flashing behavior
     */
    update(delta, trafficStates) {
        // Update flash timing
        this.timeInFlashState += delta;
        if (this.timeInFlashState >= this.flashInterval) {
            this.timeInFlashState = 0;
            this.signalsVisible = !this.signalsVisible;
        }
        // Return the signal state
        return this.getSignalStates();
    }
    /**
     * Update configuration options
     */
    updateConfig(options) {
        super.updateConfig(options);
        if (options.flashInterval !== undefined) {
            this.flashInterval = options.flashInterval;
        }
    }
    /**
     * Get the current signal states - all red or all off depending on flash state
     */
    getSignalStates() {
        // If not visible in current flash state, return all off
        if (!this.signalsVisible) {
            return [
                [0, 0, 0],
                [0, 0, 0],
                [0, 0, 0],
                [0, 0, 0]
            ];
        }
        // Otherwise, all approaches are red (no movements allowed)
        return [
            [0, 0, 0],
            [0, 0, 0],
            [0, 0, 0],
            [0, 0, 0]
        ];
    }
    /**
     * Create from JSON (static method)
     */
    static fromJSON(data, intersection) {
        const strategy = new AllRedFlashingStrategy();
        // Restore state from saved data
        strategy.flashInterval = data.flashInterval || strategy.flashInterval;
        strategy.signalsVisible = data.signalsVisible !== undefined ? data.signalsVisible : true;
        strategy.timeInFlashState = data.timeInFlashState || 0;
        // Apply configuration options
        if (data.configOptions) {
            strategy.updateConfig(data.configOptions);
        }
        strategy.initialize(intersection);
        return strategy;
    }
    /**
     * Create from JSON (instance method)
     */
    fromJSON(data, intersection) {
        // Initialize with the intersection
        this.initialize(intersection);
        // Restore state from saved data
        if (data.flashInterval !== undefined) {
            this.flashInterval = data.flashInterval;
        }
        if (data.signalsVisible !== undefined) {
            this.signalsVisible = data.signalsVisible;
        }
        if (data.timeInFlashState !== undefined) {
            this.timeInFlashState = data.timeInFlashState;
        }
        // Restore common properties
        if (data.currentPhase !== undefined) {
            this.currentPhase = data.currentPhase;
        }
        if (data.timeInPhase !== undefined) {
            this.timeInPhase = data.timeInPhase;
        }
        // Apply configuration options
        if (data.configOptions) {
            this.configOptions = { ...this.configOptions, ...data.configOptions };
        }
        return this;
    }
    /**
     * Convert to JSON
     */
    toJSON() {
        return {
            ...super.toJSON(),
            flashInterval: this.flashInterval,
            signalsVisible: this.signalsVisible,
            timeInFlashState: this.timeInFlashState
        };
    }
}
exports.AllRedFlashingStrategy = AllRedFlashingStrategy;


/***/ }),

/***/ "./src/model/traffic-control/FixedTimingStrategy.ts":
/*!**********************************************************!*\
  !*** ./src/model/traffic-control/FixedTimingStrategy.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * FixedTimingStrategy
 *
 * A simple fixed-timing traffic control strategy that follows a predefined cycle.
 * This is equivalent to the original behavior in the simulation.
 *
 * Features:
 * - Fixed duration cycles for predictable traffic signal timing
 * - Configurable phase durations and variations
 * - Automatic adaptation to intersection type (4-way, 3-way, etc.)
 * - Detailed logging for timing verification and debugging
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FixedTimingStrategy = void 0;
const AbstractTrafficControlStrategy_1 = __webpack_require__(/*! ./AbstractTrafficControlStrategy */ "./src/model/traffic-control/AbstractTrafficControlStrategy.ts");
const settings = __webpack_require__(/*! ../../settings */ "./src/settings.ts");
/**
 * Fixed timing traffic control strategy
 * Cycles through predefined phases with fixed durations
 */
class FixedTimingStrategy extends AbstractTrafficControlStrategy_1.AbstractTrafficControlStrategy {
    constructor() {
        super();
        this.strategyType = 'fixed-timing';
        this.displayName = 'Fixed Timing';
        this.description = 'Cycles through traffic signal phases with fixed durations';
        // Traffic signal patterns for intersections
        // 'L' = Left turn, 'F' = Forward, 'R' = Right turn
        // Each array represents a phase of the traffic light cycle
        // Each element in the array represents a direction (N, E, S, W)
        this.states = [
            ['L', '', 'L', ''],
            ['FR', '', 'FR', ''],
            ['', 'L', '', 'L'],
            ['', 'FR', '', 'FR'] // Phase 4: East & West forward and right
        ];
        // Additional properties for timing verification
        this.phaseStartTimes = [];
        this.phaseDurations = [];
        this.phaseTargetDurations = [];
        this.enableLogging = false;
        this.flipMultiplier = Math.random();
        this.totalPhases = this.states.length;
        this.configOptions = {
            baseDuration: settings.lightsFlipInterval / 30,
            variationPercentage: 5,
            enableLogging: false,
            logToConsole: true // Output logs to console
        };
        // Initialize timing arrays
        this.resetTimingStats();
    }
    /**
     * Reset timing statistics
     */
    resetTimingStats() {
        this.phaseStartTimes = new Array(this.totalPhases).fill(0);
        this.phaseDurations = new Array(this.totalPhases).fill(0);
        this.phaseTargetDurations = new Array(this.totalPhases).fill(0);
    }
    /**
     * Initialize the strategy with an intersection
     */
    initialize(intersection) {
        super.initialize(intersection);
        // If it's a 2-way or T-intersection, use a simplified state cycle
        if (intersection.roads && intersection.roads.length <= 2) {
            this.states = [
                ['LFR', 'LFR', 'LFR', 'LFR'] // Single phase allowing all movements
            ];
            this.totalPhases = 1;
        }
        // Reset timing stats with the correct number of phases
        this.resetTimingStats();
        // Apply configuration
        this.enableLogging = this.configOptions.enableLogging || false;
        if (this.enableLogging) {
            this.log(`Initialized FixedTimingStrategy for intersection ${intersection.id}`);
            this.log(`Number of phases: ${this.totalPhases}`);
            this.log(`Base duration: ${this.configOptions.baseDuration} seconds`);
            this.log(`Variation: ${this.configOptions.variationPercentage}%`);
        }
    }
    /**
     * Get the duration for the current phase
     */
    getPhaseDuration() {
        // Apply random variation to create offsets between intersections
        const baseDuration = this.configOptions.baseDuration || 5; // seconds
        const variation = this.configOptions.variationPercentage || 5; // percentage
        // Calculate duration with variation
        return baseDuration * (1 + (this.flipMultiplier * variation / 100));
    }
    /**
     * Get the current signal states
     */
    getSignalStates() {
        const stringState = this.states[this.currentPhase % this.states.length];
        // For 2-way or T-intersections, always allow all movements
        if (this.intersection && this.intersection.roads && this.intersection.roads.length <= 2) {
            return [
                this._decode('LFR'),
                this._decode('LFR'),
                this._decode('LFR'),
                this._decode('LFR')
            ];
        }
        // Convert string patterns to numeric state arrays
        return stringState.map(x => this._decode(x));
    }
    /**
     * Convert string representation to numeric state array
     * e.g., "LFR" -> [1,1,1] (left, forward, right allowed)
     */
    _decode(str) {
        const state = [0, 0, 0];
        if (str.includes('L'))
            state[0] = 1;
        if (str.includes('F'))
            state[1] = 1;
        if (str.includes('R'))
            state[2] = 1;
        return state;
    }
    /**
     * Create from JSON
     */
    static fromJSON(data, intersection) {
        const strategy = new FixedTimingStrategy();
        // Restore state from saved data
        strategy.currentPhase = data.currentPhase || 0;
        strategy.timeInPhase = data.timeInPhase || 0;
        strategy.totalPhases = data.totalPhases || 4;
        strategy.phaseDuration = data.phaseDuration || 5;
        strategy.configOptions = data.configOptions || {};
        strategy.flipMultiplier = data.flipMultiplier || Math.random();
        strategy.enableLogging = data.enableLogging || false;
        // If states array was saved, restore it
        if (data.states) {
            strategy.states = data.states;
        }
        strategy.initialize(intersection);
        return strategy;
    }
    /**
     * Convert to JSON
     */
    toJSON() {
        return {
            ...super.toJSON(),
            flipMultiplier: this.flipMultiplier,
            states: this.states,
            enableLogging: this.enableLogging,
            timingStats: this.getTimingStatistics()
        };
    }
    /**
     * Log message if logging is enabled
     */
    log(message) {
        var _a;
        if (this.enableLogging && this.configOptions.logToConsole) {
            const intersectionId = ((_a = this.intersection) === null || _a === void 0 ? void 0 : _a.id) || 'unknown';
            console.log(`[FixedTimingStrategy:${intersectionId}] ${message}`);
        }
    }
    /**
     * Update the traffic signals based on elapsed time
     * Overrides the base implementation to add timing tracking
     */
    update(delta, trafficStates) {
        // Record start time for new phase
        if (this.timeInPhase === 0) {
            const now = new Date().getTime() / 1000; // Current time in seconds
            this.phaseStartTimes[this.currentPhase] = now;
            this.phaseTargetDurations[this.currentPhase] = this.getPhaseDuration();
            if (this.enableLogging) {
                this.log(`Starting phase ${this.currentPhase + 1}/${this.totalPhases} with target duration: ${this.phaseTargetDurations[this.currentPhase].toFixed(2)}s`);
            }
        }
        // Let the parent class handle the standard update logic
        const result = super.update(delta, trafficStates);
        // If a phase change just occurred (timeInPhase was reset to 0)
        if (this.timeInPhase < delta) {
            const previousPhase = (this.currentPhase + this.totalPhases - 1) % this.totalPhases;
            const now = new Date().getTime() / 1000;
            const actualDuration = now - this.phaseStartTimes[previousPhase];
            this.phaseDurations[previousPhase] = actualDuration;
            const targetDuration = this.phaseTargetDurations[previousPhase];
            const deviation = Math.abs(actualDuration - targetDuration);
            const deviationPercent = (deviation / targetDuration) * 100;
            if (this.enableLogging) {
                this.log(`Phase ${previousPhase + 1} completed: actual=${actualDuration.toFixed(2)}s, target=${targetDuration.toFixed(2)}s, deviation=${deviationPercent.toFixed(1)}%`);
            }
        }
        return result;
    }
    /**
     * Check if it's time to switch to the next phase
     * This implementation uses the fixed timing approach
     */
    shouldSwitchPhase(trafficStates) {
        const shouldSwitch = this.timeInPhase >= this.nextPhaseChangeTime;
        // Log when we're about to switch
        if (shouldSwitch && this.enableLogging) {
            this.log(`Time to switch phase: ${this.timeInPhase.toFixed(2)}s elapsed, threshold: ${this.nextPhaseChangeTime.toFixed(2)}s`);
        }
        return shouldSwitch;
    }
    /**
     * Advance to the next phase and reset timing
     */
    advanceToNextPhase() {
        const oldPhase = this.currentPhase;
        // Call the parent implementation
        super.advanceToNextPhase();
        if (this.enableLogging) {
            this.log(`Advanced from phase ${oldPhase + 1} to phase ${this.currentPhase + 1}`);
        }
    }
    /**
     * Get timing statistics for verification
     * @returns Timing statistics for all phases
     */
    getTimingStatistics() {
        // Calculate average and max deviation
        let totalDeviation = 0;
        let maxDeviation = 0;
        let validPhaseCount = 0;
        for (let i = 0; i < this.totalPhases; i++) {
            if (this.phaseDurations[i] > 0) {
                const deviation = Math.abs(this.phaseDurations[i] - this.phaseTargetDurations[i]);
                totalDeviation += deviation;
                maxDeviation = Math.max(maxDeviation, deviation);
                validPhaseCount++;
            }
        }
        const averageDeviation = validPhaseCount > 0 ? totalDeviation / validPhaseCount : 0;
        return {
            phaseStartTimes: [...this.phaseStartTimes],
            phaseDurations: [...this.phaseDurations],
            phaseTargetDurations: [...this.phaseTargetDurations],
            averageDeviation,
            maxDeviation
        };
    }
    /**
     * Reset all timing statistics
     */
    resetTimingStatistics() {
        this.resetTimingStats();
        if (this.enableLogging) {
            this.log('Timing statistics reset');
        }
    }
    /**
     * Set logging enabled/disabled
     * @param enabled Whether to enable detailed logging
     */
    setLogging(enabled) {
        this.enableLogging = enabled;
        this.configOptions.enableLogging = enabled;
        this.log(`Logging ${enabled ? 'enabled' : 'disabled'}`);
    }
    /**
     * Create from JSON data
     * @param data The serialized strategy data
     * @param intersection The intersection to control
     * @returns Initialized strategy instance
     */
    fromJSON(data, intersection) {
        // Initialize with the intersection
        this.initialize(intersection);
        // Restore state from data
        if (data.currentPhase !== undefined) {
            this.currentPhase = data.currentPhase;
        }
        if (data.timeInPhase !== undefined) {
            this.timeInPhase = data.timeInPhase;
        }
        if (data.totalPhases !== undefined) {
            this.totalPhases = data.totalPhases;
        }
        if (data.phaseDuration !== undefined) {
            this.phaseDuration = data.phaseDuration;
        }
        // Restore flipMultiplier if present
        if (data.flipMultiplier !== undefined) {
            this.flipMultiplier = data.flipMultiplier;
        }
        // Restore states array if present
        if (data.states) {
            this.states = data.states;
        }
        // Restore configuration
        if (data.configOptions) {
            this.configOptions = { ...this.configOptions, ...data.configOptions };
            // Apply specific config options
            if (this.configOptions.enableLogging !== undefined) {
                this.enableLogging = this.configOptions.enableLogging;
            }
        }
        // Reset timing stats with the correct number of phases
        this.resetTimingStats();
        if (this.enableLogging) {
            this.log(`Restored FixedTimingStrategy from saved data for intersection ${intersection.id}`);
        }
        return this;
    }
}
exports.FixedTimingStrategy = FixedTimingStrategy;


/***/ }),

/***/ "./src/model/traffic-control/TrafficControlStrategyManager.ts":
/*!********************************************************************!*\
  !*** ./src/model/traffic-control/TrafficControlStrategyManager.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * TrafficControlStrategyManager
 *
 * Manages traffic control strategies, allowing for registration, selection,
 * and applying strategies to intersections.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.trafficControlStrategyManager = exports.TrafficControlStrategyManager = void 0;
const FixedTimingStrategy_1 = __webpack_require__(/*! ./FixedTimingStrategy */ "./src/model/traffic-control/FixedTimingStrategy.ts");
const AdaptiveTimingStrategy_1 = __webpack_require__(/*! ./AdaptiveTimingStrategy */ "./src/model/traffic-control/AdaptiveTimingStrategy.ts");
const AllRedFlashingStrategy_1 = __webpack_require__(/*! ./AllRedFlashingStrategy */ "./src/model/traffic-control/AllRedFlashingStrategy.ts");
const TrafficEnforcerStrategy_1 = __webpack_require__(/*! ./TrafficEnforcerStrategy */ "./src/model/traffic-control/TrafficEnforcerStrategy.ts");
/**
 * Manages traffic control strategies in the simulation
 */
class TrafficControlStrategyManager {
    /**
     * Initialize the strategy manager with default strategies
     */
    constructor() {
        /** Available strategies indexed by type */
        this.strategies = new Map();
        /** Currently selected strategy type */
        this.selectedStrategyType = 'fixed-timing';
        /** Strategy settings cache for reproducibility */
        this.strategySettings = new Map();
        // Register all available strategies
        this.registerStrategy('fixed-timing', FixedTimingStrategy_1.FixedTimingStrategy);
        this.registerStrategy('adaptive-timing', AdaptiveTimingStrategy_1.AdaptiveTimingStrategy);
        this.registerStrategy('all-red-flashing', AllRedFlashingStrategy_1.AllRedFlashingStrategy);
        this.registerStrategy('traffic-enforcer', TrafficEnforcerStrategy_1.TrafficEnforcerStrategy);
        // Initialize default strategy settings
        this.initializeDefaultSettings();
    }
    /**
     * Initialize default settings for each strategy
     */
    initializeDefaultSettings() {
        this.strategySettings.set('fixed-timing', {
            cycleTime: 30,
            greenPhaseRatio: 0.45,
            yellowPhaseRatio: 0.1, // Default yellow phase ratio
        });
        this.strategySettings.set('adaptive-timing', {
            minGreenTime: 10,
            maxGreenTime: 60,
            yellowTime: 3,
            vehicleWeightFactor: 1.0,
            waitTimeWeightFactor: 0.5,
        });
        this.strategySettings.set('all-red-flashing', {
            flashInterval: 1.0, // Flash interval in seconds
        });
        this.strategySettings.set('traffic-enforcer', {
            decisionInterval: 5,
            queueThreshold: 5,
            minGreenTime: 10, // Minimum green time before switching
        });
    }
    /**
     * Register a new traffic control strategy
     * @param type Unique identifier for the strategy
     * @param strategyClass Constructor for the strategy class
     */
    registerStrategy(type, strategyClass) {
        this.strategies.set(type, strategyClass);
    }
    /**
     * Get a list of available strategy types
     */
    getAvailableStrategyTypes() {
        return Array.from(this.strategies.keys());
    }
    /**
     * Set the currently selected strategy
     * @param strategyType The type of strategy to select
     * @returns true if successful, false if the strategy type doesn't exist
     */
    selectStrategy(strategyType) {
        if (this.strategies.has(strategyType)) {
            this.selectedStrategyType = strategyType;
            return true;
        }
        return false;
    }
    /**
     * Get the currently selected strategy type
     */
    getSelectedStrategyType() {
        return this.selectedStrategyType;
    }
    /**
     * Get a concrete instance of a strategy by name
     * @param strategyType The type of strategy to get
     * @returns A new instance of the requested strategy
     */
    getStrategy(strategyType) {
        const StrategyClass = this.strategies.get(strategyType);
        if (!StrategyClass) {
            return null;
        }
        return new StrategyClass();
    }
    /**
     * Create a new instance of the currently selected strategy
     */
    createStrategy() {
        const StrategyClass = this.strategies.get(this.selectedStrategyType);
        if (!StrategyClass) {
            throw new Error(`Strategy type '${this.selectedStrategyType}' not registered`);
        }
        return new StrategyClass();
    }
    /**
     * Apply the currently selected strategy to an intersection
     * @param intersection The intersection to apply the strategy to
     */
    applyToIntersection(intersection) {
        const strategy = this.createStrategy();
        strategy.initialize(intersection);
        return strategy;
    }
    /**
     * Get the settings for a specific strategy
     * @param strategyType The type of strategy
     * @returns The settings for the strategy
     */
    getStrategySettings(strategyType) {
        return this.strategySettings.get(strategyType) || null;
    }
    /**
     * Apply strategy settings
     * @param strategyType The type of strategy
     * @param settings The settings to apply
     */
    applyStrategySettings(strategyType, settings) {
        if (!this.strategies.has(strategyType)) {
            console.warn(`Strategy type '${strategyType}' not found`);
            return;
        }
        // Store the settings
        this.strategySettings.set(strategyType, {
            ...this.getStrategySettings(strategyType),
            ...settings
        });
        // If this is the currently selected strategy, notify any listeners (future enhancement)
        if (strategyType === this.selectedStrategyType) {
            // Future: Emit event or notify subscribers
        }
    }
    /**
     * Create a strategy from saved data
     * @param data Serialized strategy data from toJSON
     * @param intersection The intersection to control
     */
    createFromJSON(data, intersection) {
        if (!data || !data.strategyType) {
            // Default to fixed timing if no valid data
            return this.applyToIntersection(intersection);
        }
        const StrategyClass = this.strategies.get(data.strategyType);
        if (!StrategyClass) {
            console.warn(`Strategy type '${data.strategyType}' not found, using default`);
            return this.applyToIntersection(intersection);
        }
        // Create an instance and initialize from data
        const strategy = new StrategyClass();
        return strategy.fromJSON ? strategy.fromJSON(data, intersection) : strategy;
    }
}
exports.TrafficControlStrategyManager = TrafficControlStrategyManager;
// Create a singleton instance
exports.trafficControlStrategyManager = new TrafficControlStrategyManager();


/***/ }),

/***/ "./src/model/traffic-control/TrafficEnforcerStrategy.ts":
/*!**************************************************************!*\
  !*** ./src/model/traffic-control/TrafficEnforcerStrategy.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * TrafficEnforcerStrategy
 *
 * Simulates a manual or AI-based traffic enforcer making decisions based on live conditions.
 * This strategy uses heuristics to prioritize lanes with high congestion or emergency situations.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TrafficEnforcerStrategy = void 0;
const AbstractTrafficControlStrategy_1 = __webpack_require__(/*! ./AbstractTrafficControlStrategy */ "./src/model/traffic-control/AbstractTrafficControlStrategy.ts");
/**
 * Traffic enforcer control strategy
 * Simulates a human or AI traffic enforcer making real-time decisions
 */
class TrafficEnforcerStrategy extends AbstractTrafficControlStrategy_1.AbstractTrafficControlStrategy {
    constructor() {
        super();
        this.strategyType = 'traffic-enforcer';
        this.displayName = 'Traffic Enforcer';
        this.description = 'Simulates a traffic enforcer (human or AI) making real-time decisions based on traffic conditions';
        // Track traffic metrics for each approach
        this.queueLengths = [0, 0, 0, 0]; // N, E, S, W
        this.waitTimes = [0, 0, 0, 0]; // N, E, S, W
        this.flowRates = [0, 0, 0, 0]; // N, E, S, W
        this.congestionScores = [0, 0, 0, 0]; // N, E, S, W
        // Current active signals (1 = green, 0 = red) for each approach and movement
        this.currentSignals = [
            [0, 0, 0],
            [0, 0, 0],
            [0, 0, 0],
            [0, 0, 0] // West
        ];
        // Decision-making parameters
        this.decisionInterval = 5; // seconds between major decisions
        this.timeSinceLastDecision = 0;
        this.minimumGreenTime = 10; // minimum green time for any movement
        this.greenTimers = {}; // track time for each green signal
        this.activeMovements = []; // currently active movements
        // Safety constraint: conflicting movements can't be green simultaneously
        this.conflictMatrix = {
            'N-L': ['E-L', 'E-F', 'S-F', 'S-R', 'W-L', 'W-F'],
            'N-F': ['E-L', 'E-F', 'E-R', 'S-L', 'W-L', 'W-F', 'W-R'],
            'N-R': ['E-F', 'E-R', 'S-L', 'W-L'],
            'E-L': ['N-L', 'N-F', 'S-L', 'S-F', 'W-F', 'W-R'],
            'E-F': ['N-L', 'N-F', 'N-R', 'S-L', 'S-F', 'S-R', 'W-L'],
            'E-R': ['N-F', 'N-R', 'S-L', 'W-L'],
            'S-L': ['N-F', 'N-R', 'E-L', 'E-F', 'W-L', 'W-F'],
            'S-F': ['N-L', 'E-L', 'E-F', 'E-R', 'W-L', 'W-F', 'W-R'],
            'S-R': ['N-L', 'E-F', 'E-R', 'W-L'],
            'W-L': ['N-L', 'N-F', 'N-R', 'E-L', 'E-R', 'S-L', 'S-R'],
            'W-F': ['N-L', 'N-F', 'E-L', 'E-F', 'S-L', 'S-F'],
            'W-R': ['N-F', 'N-R', 'E-L', 'S-F']
        };
        // Enforcer rules and priorities
        this.priorityThreshold = 7; // congestion score above which a movement gets priority
        this.emergencyThreshold = 9; // threshold for emergency intervention
        this.fairnessWindow = 60; // time window (seconds) to ensure fairness
        this.directionHistory = {}; // track time given to each direction
        // Extra priorities that can be set via configuration
        this.prioritizedDirections = []; // directions that get priority (0=N, 1=E, 2=S, 3=W)
        this.prioritizedMovements = []; // specific movements with priority
        this.configOptions = {
            decisionInterval: this.decisionInterval,
            minimumGreenTime: this.minimumGreenTime,
            priorityThreshold: this.priorityThreshold,
            emergencyThreshold: this.emergencyThreshold,
            fairnessWindow: this.fairnessWindow,
            prioritizedDirections: [],
            prioritizedMovements: []
        };
        // Initialize green timers and direction history
        for (let d = 0; d < 4; d++) {
            for (let m = 0; m < 3; m++) {
                this.greenTimers[`${d}-${m}`] = 0;
            }
            this.directionHistory[d.toString()] = 0;
        }
    }
    /**
     * Initialize the strategy with an intersection
     */
    initialize(intersection) {
        super.initialize(intersection);
        // Reset state
        this.resetSignals();
        this.activeMovements = [];
        this.timeSinceLastDecision = 0;
        // Apply configuration
        this.decisionInterval = this.configOptions.decisionInterval || 5;
        this.minimumGreenTime = this.configOptions.minimumGreenTime || 10;
        this.priorityThreshold = this.configOptions.priorityThreshold || 7;
        this.emergencyThreshold = this.configOptions.emergencyThreshold || 9;
        this.fairnessWindow = this.configOptions.fairnessWindow || 60;
        // Set priorities from config
        this.prioritizedDirections = this.configOptions.prioritizedDirections || [];
        this.prioritizedMovements = this.configOptions.prioritizedMovements || [];
        // For non-standard intersections (e.g., T-intersections), adjust the conflict matrix
        if (intersection.roads && intersection.roads.length < 4) {
            this.adjustConflictMatrixForNonStandardIntersection();
        }
    }
    /**
     * Update strategy based on elapsed time and traffic states
     */
    update(delta, trafficStates) {
        // Update internal time tracking
        this.timeSinceLastDecision += delta;
        // Update green timers
        this.updateGreenTimers(delta);
        // Update direction history for fairness tracking
        for (const movement of this.activeMovements) {
            this.directionHistory[movement.direction.toString()] += delta;
        }
        // Process traffic states
        if (trafficStates && trafficStates.length > 0) {
            this.updateTrafficMetrics(trafficStates);
            // Check for emergency conditions that require immediate response
            if (this.checkForEmergencyConditions()) {
                console.log("[Enforcer] Emergency conditions detected, making immediate decision");
                this.makeTrafficDecision();
                this.timeSinceLastDecision = 0;
            }
            // Make normal decisions at regular intervals
            else if (this.timeSinceLastDecision >= this.decisionInterval) {
                this.makeTrafficDecision();
                this.timeSinceLastDecision = 0;
            }
        }
        return this.getCurrentSignalStates();
    }
    /**
     * Get current signal states
     */
    getCurrentSignalStates() {
        return this.currentSignals.map(signals => [...signals]);
    }
    /**
     * Implementation of abstract method
     */
    getSignalStates() {
        return this.getCurrentSignalStates();
    }
    /**
     * Reset the strategy to initial state
     */
    reset() {
        super.reset();
        this.resetSignals();
        this.timeSinceLastDecision = 0;
        this.activeMovements = [];
        // Reset timers and history
        for (let d = 0; d < 4; d++) {
            for (let m = 0; m < 3; m++) {
                this.greenTimers[`${d}-${m}`] = 0;
            }
            this.directionHistory[d.toString()] = 0;
        }
    }
    /**
     * Reset all signals to red
     */
    resetSignals() {
        this.currentSignals = [
            [0, 0, 0],
            [0, 0, 0],
            [0, 0, 0],
            [0, 0, 0] // West
        ];
    }
    /**
     * Update traffic metrics based on current states
     */
    updateTrafficMetrics(trafficStates) {
        // Update current metrics
        for (let i = 0; i < trafficStates.length; i++) {
            if (i < this.queueLengths.length) {
                this.queueLengths[i] = trafficStates[i].queueLength;
                this.waitTimes[i] = trafficStates[i].averageWaitTime;
                this.flowRates[i] = trafficStates[i].flowRate;
            }
        }
        // Calculate congestion scores
        this.calculateCongestionScores();
    }
    /**
     * Calculate congestion scores for each approach and movement
     */
    calculateCongestionScores() {
        const directionNames = ['North', 'East', 'South', 'West'];
        for (let d = 0; d < 4; d++) {
            // Calculate based on queue length and wait time
            const queueScore = Math.min(10, this.queueLengths[d] / 2);
            const waitScore = Math.min(10, this.waitTimes[d] / 30);
            const flowScore = this.flowRates[d] > 0 ? 10 / Math.max(1, this.flowRates[d]) : 10;
            // Combined score (0-10)
            this.congestionScores[d] = (queueScore * 0.5 + waitScore * 0.3 + flowScore * 0.2);
            // Add priority bonus if this direction is prioritized
            if (this.prioritizedDirections.includes(d)) {
                this.congestionScores[d] += 2;
            }
            // Debug log
            if (this.congestionScores[d] > this.priorityThreshold) {
                console.log(`[Enforcer] ${directionNames[d]} approach has high congestion: ${this.congestionScores[d].toFixed(1)}`);
            }
        }
    }
    /**
     * Check if any green timer has exceeded minimum time
     */
    canSwitchSignals() {
        for (const movement of this.activeMovements) {
            const key = `${movement.direction}-${movement.movement}`;
            if (this.greenTimers[key] < this.minimumGreenTime) {
                return false; // Can't switch yet, minimum green time not met
            }
        }
        return true;
    }
    /**
     * Update timers for green signals
     */
    updateGreenTimers(delta) {
        // Increment timer for each active movement
        for (const movement of this.activeMovements) {
            const key = `${movement.direction}-${movement.movement}`;
            this.greenTimers[key] += delta;
        }
    }
    /**
     * Reset timer for a movement that just turned green
     */
    resetGreenTimer(direction, movement) {
        const key = `${direction}-${movement}`;
        this.greenTimers[key] = 0;
    }
    /**
     * Check if a movement has a priority configuration
     */
    hasConfiguredPriority(direction, movement) {
        return this.prioritizedMovements.some(m => m.direction === direction && m.movement === movement);
    }
    /**
     * Check if activating a movement would create conflicts with current active movements
     */
    wouldCreateConflict(direction, movement) {
        var _a, _b;
        // Get movement key (e.g., "N-L" for North Left)
        const directionCodes = ['N', 'E', 'S', 'W'];
        const movementCodes = ['L', 'F', 'R'];
        const movementKey = `${directionCodes[direction]}-${movementCodes[movement]}`;
        // Check against each active movement
        for (const active of this.activeMovements) {
            const activeKey = `${directionCodes[active.direction]}-${movementCodes[active.movement]}`;
            // If the active movement conflicts with proposed movement, it would create a conflict
            if (((_a = this.conflictMatrix[activeKey]) === null || _a === void 0 ? void 0 : _a.includes(movementKey)) ||
                ((_b = this.conflictMatrix[movementKey]) === null || _b === void 0 ? void 0 : _b.includes(activeKey))) {
                return true;
            }
        }
        return false;
    }
    /**
     * Calculate fairness score based on historical allocation
     * Returns 0-1 value where 0 is completely unfair and 1 is perfectly fair
     */
    calculateFairnessScore() {
        const times = Object.values(this.directionHistory);
        const maxTime = Math.max(...times);
        const minTime = Math.min(...times);
        if (maxTime === 0)
            return 1; // No history yet
        return minTime / maxTime; // Closer to 1 is more fair
    }
    /**
     * Check for emergency conditions that require immediate attention
     */
    checkForEmergencyConditions() {
        // Check for extremely high congestion in any direction
        for (let d = 0; d < 4; d++) {
            if (this.congestionScores[d] >= this.emergencyThreshold) {
                console.log(`[Enforcer] Emergency: Direction ${d} has critical congestion (${this.congestionScores[d].toFixed(1)})`);
                return true;
            }
        }
        // Check for extremely unfair allocation
        const fairnessScore = this.calculateFairnessScore();
        if (fairnessScore < 0.3 && Object.values(this.directionHistory).some(t => t > this.fairnessWindow)) {
            console.log(`[Enforcer] Emergency: Fairness is critically low (${fairnessScore.toFixed(2)})`);
            return true;
        }
        return false;
    }
    /**
     * Make traffic control decision based on current conditions
     * This is where the "enforcer intelligence" logic lives
     */
    makeTrafficDecision() {
        console.log("[Enforcer] Making traffic decision");
        // If we can't switch signals yet due to minimum green time, do nothing
        if (this.activeMovements.length > 0 && !this.canSwitchSignals()) {
            console.log("[Enforcer] Can't switch yet - minimum green time not met");
            return;
        }
        // Step 1: Score each possible movement
        const scores = [];
        const directionNames = ['North', 'East', 'South', 'West'];
        const movementNames = ['Left', 'Forward', 'Right'];
        for (let d = 0; d < 4; d++) {
            // Skip directions that don't exist in this intersection
            if (this.intersection && this.intersection.roads &&
                d >= this.intersection.roads.length) {
                continue;
            }
            for (let m = 0; m < 3; m++) {
                // Base score is the congestion score for this direction
                let score = this.congestionScores[d];
                // Adjust based on wait time for fairness
                const fairnessAdjustment = (1 - (this.directionHistory[d.toString()] /
                    Math.max(...Object.values(this.directionHistory)))) * 3;
                score += fairnessAdjustment;
                // Preference for letting traffic flow forward over turns
                if (m === 1)
                    score += 1; // Small bonus for forward movement
                // Add bonus for configured priorities
                if (this.hasConfiguredPriority(d, m)) {
                    score += 3;
                }
                scores.push({ direction: d, movement: m, score });
            }
        }
        // Sort by score (highest first)
        scores.sort((a, b) => b.score - a.score);
        // Step 2: Select movements to enable based on scores and conflicts
        const newActiveMovements = [];
        const activatedMovements = [];
        for (const candidate of scores) {
            // Skip low-priority movements
            if (candidate.score < this.priorityThreshold / 2)
                continue;
            // Check if this would conflict with any already selected movement
            let hasConflict = false;
            for (const active of newActiveMovements) {
                if (this.wouldCreateConflict(candidate.direction, candidate.movement)) {
                    hasConflict = true;
                    break;
                }
            }
            if (!hasConflict) {
                newActiveMovements.push({
                    direction: candidate.direction,
                    movement: candidate.movement
                });
                activatedMovements.push(candidate);
                console.log(`[Enforcer] Activating ${directionNames[candidate.direction]} ${movementNames[candidate.movement]} (score: ${candidate.score.toFixed(1)})`);
            }
        }
        // If nothing was selected, enable the highest scoring movement regardless
        if (newActiveMovements.length === 0 && scores.length > 0) {
            const best = scores[0];
            newActiveMovements.push({
                direction: best.direction,
                movement: best.movement
            });
            activatedMovements.push(best);
            console.log(`[Enforcer] Forced activation of ${directionNames[best.direction]} ${movementNames[best.movement]} (score: ${best.score.toFixed(1)})`);
        }
        // Step 3: Apply the new signal configuration
        this.resetSignals(); // All red first
        for (const movement of newActiveMovements) {
            // Set signal to green
            this.currentSignals[movement.direction][movement.movement] = 1;
            // Reset the green timer for this movement
            this.resetGreenTimer(movement.direction, movement.movement);
        }
        // Update active movements list
        this.activeMovements = [...newActiveMovements];
        // Log the decision
        console.log(`[Enforcer] New signal state: ${this.activeMovements.length} green signals`);
    }
    /**
     * Adjust conflict matrix for non-standard intersections (e.g., T-junctions)
     */
    adjustConflictMatrixForNonStandardIntersection() {
        // For simplicity, we'll implement a T-intersection case (3 roads)
        // Assuming road 3 (West) is missing
        if (this.intersection && this.intersection.roads && this.intersection.roads.length === 3) {
            // Remove all conflicts related to the missing road
            Object.keys(this.conflictMatrix).forEach(key => {
                if (key.startsWith('W-')) {
                    delete this.conflictMatrix[key];
                }
                else {
                    // Remove the missing road from conflict lists
                    this.conflictMatrix[key] = this.conflictMatrix[key].filter(conflict => !conflict.startsWith('W-'));
                }
            });
            console.log("[Enforcer] Adjusted conflict matrix for T-intersection");
        }
    }
    /**
     * Override updateConfig to handle complex configuration options
     */
    updateConfig(options) {
        super.updateConfig(options);
        // Update specific options
        if (options.decisionInterval !== undefined)
            this.decisionInterval = options.decisionInterval;
        if (options.minimumGreenTime !== undefined)
            this.minimumGreenTime = options.minimumGreenTime;
        if (options.priorityThreshold !== undefined)
            this.priorityThreshold = options.priorityThreshold;
        if (options.emergencyThreshold !== undefined)
            this.emergencyThreshold = options.emergencyThreshold;
        if (options.fairnessWindow !== undefined)
            this.fairnessWindow = options.fairnessWindow;
        // Handle direction priorities (array of numbers)
        if (options.prioritizedDirections !== undefined) {
            this.prioritizedDirections = Array.isArray(options.prioritizedDirections) ?
                options.prioritizedDirections : [];
        }
        // Handle movement priorities (array of objects)
        if (options.prioritizedMovements !== undefined) {
            this.prioritizedMovements = Array.isArray(options.prioritizedMovements) ?
                options.prioritizedMovements : [];
        }
    }
    /**
     * Create this strategy from JSON data
     */
    static fromJSON(data, intersection) {
        const strategy = new TrafficEnforcerStrategy();
        // Restore state from saved data
        strategy.configOptions = data.configOptions || {};
        // Restore enforcer-specific properties
        strategy.decisionInterval = data.decisionInterval || strategy.configOptions.decisionInterval || 5;
        strategy.minimumGreenTime = data.minimumGreenTime || strategy.configOptions.minimumGreenTime || 10;
        strategy.priorityThreshold = data.priorityThreshold || strategy.configOptions.priorityThreshold || 7;
        strategy.emergencyThreshold = data.emergencyThreshold || strategy.configOptions.emergencyThreshold || 9;
        strategy.fairnessWindow = data.fairnessWindow || strategy.configOptions.fairnessWindow || 60;
        strategy.prioritizedDirections = data.prioritizedDirections || strategy.configOptions.prioritizedDirections || [];
        strategy.prioritizedMovements = data.prioritizedMovements || strategy.configOptions.prioritizedMovements || [];
        // Restore signal state if available
        if (data.currentSignals) {
            strategy.currentSignals = data.currentSignals;
        }
        // Restore active movements
        if (data.activeMovements) {
            strategy.activeMovements = data.activeMovements;
        }
        // Restore timers and history
        if (data.greenTimers)
            strategy.greenTimers = data.greenTimers;
        if (data.directionHistory)
            strategy.directionHistory = data.directionHistory;
        if (data.timeSinceLastDecision !== undefined)
            strategy.timeSinceLastDecision = data.timeSinceLastDecision;
        strategy.initialize(intersection);
        return strategy;
    }
    /**
     * Create from JSON (instance method)
     */
    fromJSON(data, intersection) {
        // Initialize with the intersection
        this.initialize(intersection);
        // Restore state from data
        if (data.currentPhase !== undefined) {
            this.currentPhase = data.currentPhase;
        }
        if (data.timeInPhase !== undefined) {
            this.timeInPhase = data.timeInPhase;
        }
        if (data.phaseDuration !== undefined) {
            this.phaseDuration = data.phaseDuration;
        }
        // Restore traffic enforcer specific properties
        if (data.decisionInterval !== undefined) {
            this.decisionInterval = data.decisionInterval;
        }
        if (data.timeSinceLastDecision !== undefined) {
            this.timeSinceLastDecision = data.timeSinceLastDecision;
        }
        if (data.minimumGreenTime !== undefined) {
            this.minimumGreenTime = data.minimumGreenTime;
        }
        if (data.currentSignals) {
            this.currentSignals = data.currentSignals;
        }
        if (data.queueLengths) {
            this.queueLengths = data.queueLengths;
        }
        if (data.waitTimes) {
            this.waitTimes = data.waitTimes;
        }
        if (data.flowRates) {
            this.flowRates = data.flowRates;
        }
        if (data.congestionScores) {
            this.congestionScores = data.congestionScores;
        }
        if (data.greenTimers) {
            this.greenTimers = data.greenTimers;
        }
        if (data.activeMovements) {
            this.activeMovements = data.activeMovements;
        }
        // Restore configuration
        if (data.configOptions) {
            this.configOptions = { ...this.configOptions, ...data.configOptions };
        }
        return this;
    }
    /**
     * Convert to JSON for serialization
     */
    toJSON() {
        return {
            ...super.toJSON(),
            strategyType: this.strategyType,
            decisionInterval: this.decisionInterval,
            minimumGreenTime: this.minimumGreenTime,
            priorityThreshold: this.priorityThreshold,
            emergencyThreshold: this.emergencyThreshold,
            fairnessWindow: this.fairnessWindow,
            prioritizedDirections: this.prioritizedDirections,
            prioritizedMovements: this.prioritizedMovements,
            currentSignals: this.currentSignals,
            activeMovements: this.activeMovements,
            greenTimers: this.greenTimers,
            directionHistory: this.directionHistory,
            timeSinceLastDecision: this.timeSinceLastDecision,
            // Current traffic metrics
            queueLengths: this.queueLengths,
            waitTimes: this.waitTimes,
            flowRates: this.flowRates,
            congestionScores: this.congestionScores
        };
    }
}
exports.TrafficEnforcerStrategy = TrafficEnforcerStrategy;


/***/ }),

/***/ "./src/model/traffic-control/TrafficLightController.ts":
/*!*************************************************************!*\
  !*** ./src/model/traffic-control/TrafficLightController.ts ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/**
 * TrafficLightController
 *
 * Manages traffic light control for intersections using pluggable strategies.
 * This class replaces the old ControlSignals class with a more modular approach.
 */
const TrafficControlStrategyManager_1 = __webpack_require__(/*! ./TrafficControlStrategyManager */ "./src/model/traffic-control/TrafficControlStrategyManager.ts");
const kpi_collector_1 = __webpack_require__(/*! ../kpi-collector */ "./src/model/kpi-collector.ts");
class TrafficLightController {
    /**
     * Create a new traffic light controller for an intersection
     */
    constructor(intersection) {
        /** Current simulation time */
        this.time = 0;
        /** Traffic state metrics for each approach */
        this.trafficStates = [];
        /**
         * Update the traffic signals based on elapsed time
         * This is called every tick of the simulation
         */
        this.onTick = (delta) => {
            // Update time
            this.time += delta;
            // Update traffic states with real data from KPI collector
            this.updateTrafficStates();
            // Explicitly update the strategy with the latest traffic states
            // This ensures the strategy has the latest data even if state isn't accessed
            this.strategy.update(delta, this.trafficStates);
        };
        this.intersection = intersection;
        this.strategy = TrafficControlStrategyManager_1.trafficControlStrategyManager.applyToIntersection(intersection);
        this.initializeTrafficStates();
    }
    /**
     * Initialize traffic state tracking for each approach
     */
    initializeTrafficStates() {
        // Create a traffic state for each approach (N, E, S, W)
        this.trafficStates = [0, 1, 2, 3].map(() => ({
            queueLength: 0,
            averageWaitTime: 0,
            maxWaitTime: 0,
            flowRate: 0,
            signalState: [0, 0, 0] // [left, forward, right]
        }));
    }
    /**
     * Create a copy of a traffic light controller
     * Used when deserializing world state
     */
    static copy(controller, intersection) {
        if (!controller) {
            return new TrafficLightController(intersection);
        }
        // Create a proper instance with the correct prototype
        const result = new TrafficLightController(intersection);
        // Copy over basic properties
        result.time = controller.time || 0;
        // Load the strategy from saved data if available
        if (controller.strategy) {
            result.strategy = TrafficControlStrategyManager_1.trafficControlStrategyManager.createFromJSON(controller.strategy, intersection);
        }
        return result;
    }
    /**
     * Convert to a serializable object for storage
     */
    toJSON() {
        return {
            time: this.time,
            strategy: this.strategy.toJSON()
        };
    }
    /**
     * Change the active traffic control strategy
     */
    setStrategy(strategyType) {
        if (TrafficControlStrategyManager_1.trafficControlStrategyManager.selectStrategy(strategyType)) {
            this.strategy = TrafficControlStrategyManager_1.trafficControlStrategyManager.applyToIntersection(this.intersection);
            return true;
        }
        return false;
    }
    /**
     * Get the current active strategy
     */
    getStrategy() {
        return this.strategy;
    }
    /**
     * Get the current traffic light state for all approaches
     * Returns a 2D array: [approach][movement] where:
     * - approach is 0-3 (N, E, S, W)
     * - movement is 0-2 (left, forward, right)
     * - value is 0 (RED) or 1 (GREEN)
     */
    get state() {
        // Return the current state without updating the strategy again
        // The strategy is already updated in onTick
        return this.strategy.getCurrentSignalStates ?
            this.strategy.getCurrentSignalStates() :
            this.strategy.update(0, this.trafficStates);
    }
    /**
     * Update traffic states based on KPI metrics
     * This fetches real-time data from the KPI collector to inform adaptive strategies
     */
    updateTrafficStates() {
        // Get intersection ID for KPI lookups
        const intersectionId = this.intersection.id;
        // Get data from KPI collector
        const metrics = kpi_collector_1.kpiCollector.getMetrics();
        const intersectionMetric = metrics.intersectionMetrics[intersectionId];
        // Get lane metrics for all connected roads
        const connectedLanes = {
            0: [],
            1: [],
            2: [],
            3: [] // West
        };
        // Get road directions from intersection
        // Map lanes to their cardinal directions
        if (this.intersection.roads) {
            this.intersection.roads.forEach((road, index) => {
                // Use index % 4 to map to N, E, S, W (0, 1, 2, 3)
                const direction = index % 4;
                if (road.lanes) {
                    road.lanes.forEach(lane => {
                        if (lane.id && metrics.laneMetrics[lane.id]) {
                            connectedLanes[direction].push(metrics.laneMetrics[lane.id]);
                        }
                    });
                }
            });
        }
        // Update traffic states with real data
        for (let i = 0; i < this.trafficStates.length; i++) {
            // Get combined metrics for this approach
            const lanesToCheck = connectedLanes[i] || [];
            // Aggregate metrics from all lanes for this approach
            let queueLength = 0;
            let totalWaitTime = 0;
            let maxWaitTime = 0;
            let flowRate = 0;
            let count = 0;
            lanesToCheck.forEach(laneMetric => {
                queueLength += laneMetric.queueLength || 0;
                totalWaitTime += laneMetric.averageWaitTime || 0;
                maxWaitTime = Math.max(maxWaitTime, laneMetric.averageWaitTime || 0);
                flowRate += laneMetric.throughput || 0;
                count++;
            });
            // Update traffic state with real data
            this.trafficStates[i].queueLength = queueLength;
            this.trafficStates[i].averageWaitTime = count > 0 ? totalWaitTime / count : 0;
            this.trafficStates[i].maxWaitTime = maxWaitTime;
            this.trafficStates[i].flowRate = flowRate;
            // Copy current signal state
            if (this.state && this.state[i]) {
                this.trafficStates[i].signalState = [...this.state[i]];
            }
            // If intersection metrics exist, use them to enhance our data
            if (intersectionMetric) {
                this.trafficStates[i].queueLength = Math.max(this.trafficStates[i].queueLength, intersectionMetric.averageQueueLength / 4);
            }
        }
    }
    /**
     * Reset the controller to its initial state
     */
    reset() {
        this.time = 0;
        if (this.strategy && typeof this.strategy.reset === 'function') {
            this.strategy.reset();
        }
        // Reset traffic states
        this.initializeTrafficStates();
    }
}
module.exports = TrafficLightController;


/***/ }),

/***/ "./src/model/traffic-control/tests/AdaptiveTimingStrategyTest.ts":
/*!***********************************************************************!*\
  !*** ./src/model/traffic-control/tests/AdaptiveTimingStrategyTest.ts ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * AdaptiveTimingStrategyTest
 *
 * Test suite for the AdaptiveTimingStrategy implementation
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AdaptiveTimingStrategyTest = void 0;
const Intersection = __webpack_require__(/*! ../../intersection */ "./src/model/intersection.ts");
const Rect = __webpack_require__(/*! ../../../geom/rect */ "./src/geom/rect.ts");
const AdaptiveTimingStrategy_1 = __webpack_require__(/*! ../AdaptiveTimingStrategy */ "./src/model/traffic-control/AdaptiveTimingStrategy.ts");
class AdaptiveTimingStrategyTest {
    constructor() {
        // Create a mock intersection
        this.intersection = new Intersection(new Rect(0, 0, 100, 100));
        this.intersection.id = 'test-intersection';
        // Create the strategy
        this.strategy = new AdaptiveTimingStrategy_1.AdaptiveTimingStrategy();
        // Enable logging for tests
        this.strategy.updateConfig({ enableLogging: true });
    }
    /**
     * Run all tests
     */
    runTests() {
        console.log('=== Running AdaptiveTimingStrategy Tests ===');
        let allPassed = true;
        const tests = [
            this.testInitialization,
            this.testNoTrafficDefaultBehavior,
            this.testLightTrafficBehavior,
            this.testHeavyTrafficBehavior,
            this.testImbalancedTrafficBehavior,
            this.testRushHourTrafficBehavior,
            this.testConfigOptions,
            this.testSerialization
        ];
        for (const test of tests) {
            try {
                console.log(`\nRunning: ${test.name}`);
                const passed = test.call(this);
                console.log(`${test.name}: ${passed ? 'PASSED' : 'FAILED'}`);
                allPassed = allPassed && passed;
            }
            catch (e) {
                console.error(`Test ${test.name} FAILED with error:`, e);
                allPassed = false;
            }
        }
        console.log(`\nFinal result: ${allPassed ? 'ALL TESTS PASSED' : 'SOME TESTS FAILED'}`);
        return allPassed;
    }
    /**
     * Test basic initialization
     */
    testInitialization() {
        this.setup();
        // Check that strategy initialized properly
        return this.strategy.strategyType === 'adaptive-timing' &&
            this.strategy.getCurrentPhase() === 0;
    }
    /**
     * Test behavior with no traffic
     */
    testNoTrafficDefaultBehavior() {
        this.setup();
        // Simulate 30 seconds with no traffic
        const states = this.createTrafficStates([0, 0, 0, 0], [0, 0, 0, 0]);
        // Should behave like fixed timing
        let phaseChanged = false;
        let totalTime = 0;
        const timeStep = 1.0; // 1 second steps
        // Run for up to 120 seconds
        for (let i = 0; i < 120 && !phaseChanged; i++) {
            this.strategy.update(timeStep, states);
            totalTime += timeStep;
            // Check if phase changed
            if (this.strategy.getCurrentPhase() !== 0) {
                phaseChanged = true;
            }
        }
        console.log(`Phase changed after ${totalTime}s with no traffic`);
        // Should change at around the base duration (default is 30s)
        const baseTime = this.strategy.getConfigOptions().baseDuration;
        // Allow 20% tolerance
        return phaseChanged && Math.abs(totalTime - baseTime) < (baseTime * 0.2);
    }
    /**
     * Test behavior with light traffic
     */
    testLightTrafficBehavior() {
        this.setup();
        // Light traffic on all approaches
        const queueLengths = [1, 1, 1, 1];
        const waitTimes = [5, 5, 5, 5];
        const states = this.createTrafficStates(queueLengths, waitTimes);
        // Should adjust slightly from base timing
        let phaseChanged = false;
        let totalTime = 0;
        const timeStep = 1.0;
        // Run for up to 120 seconds
        for (let i = 0; i < 120 && !phaseChanged; i++) {
            this.strategy.update(timeStep, states);
            totalTime += timeStep;
            if (this.strategy.getCurrentPhase() !== 0) {
                phaseChanged = true;
            }
        }
        console.log(`Phase changed after ${totalTime}s with light traffic`);
        // Should be slightly longer than base
        const baseTime = this.strategy.getConfigOptions().baseDuration;
        return phaseChanged && totalTime > baseTime && totalTime < baseTime * 1.5;
    }
    /**
     * Test behavior with heavy traffic
     */
    testHeavyTrafficBehavior() {
        this.setup();
        // Heavy traffic on all approaches
        const queueLengths = [5, 5, 5, 5];
        const waitTimes = [20, 20, 20, 20];
        const states = this.createTrafficStates(queueLengths, waitTimes);
        // Should extend phase to closer to max duration
        let phaseChanged = false;
        let totalTime = 0;
        const timeStep = 1.0;
        // Run for up to 120 seconds
        for (let i = 0; i < 120 && !phaseChanged; i++) {
            this.strategy.update(timeStep, states);
            totalTime += timeStep;
            if (this.strategy.getCurrentPhase() !== 0) {
                phaseChanged = true;
            }
        }
        console.log(`Phase changed after ${totalTime}s with heavy traffic`);
        // Should be longer, close to max
        const baseTime = this.strategy.getConfigOptions().baseDuration;
        const maxTime = this.strategy.getConfigOptions().maxPhaseDuration;
        // Should be at least 50% of the way from base to max
        const expectedMinTime = baseTime + (maxTime - baseTime) * 0.5;
        return phaseChanged && totalTime >= expectedMinTime;
    }
    /**
     * Test behavior with imbalanced traffic
     */
    testImbalancedTrafficBehavior() {
        this.setup();
        // Start with balanced light traffic
        let queueLengths = [1, 1, 1, 1];
        let waitTimes = [5, 5, 5, 5];
        let states = this.createTrafficStates(queueLengths, waitTimes);
        // Run for a while to establish baseline
        for (let i = 0; i < 10; i++) {
            this.strategy.update(1.0, states);
        }
        // Now create imbalance - heavy traffic on next phase (E-W)
        queueLengths = [1, 5, 1, 5]; // Higher on East-West (indices 1 & 3)
        waitTimes = [5, 25, 5, 25]; // Higher on East-West
        states = this.createTrafficStates(queueLengths, waitTimes);
        // Should switch earlier than normal
        let phaseChanged = false;
        let totalTime = 0;
        const timeStep = 1.0;
        // Run for up to 120 seconds
        for (let i = 0; i < 120 && !phaseChanged; i++) {
            this.strategy.update(timeStep, states);
            totalTime += timeStep;
            if (this.strategy.getCurrentPhase() !== 0) {
                phaseChanged = true;
            }
        }
        console.log(`Phase changed after ${totalTime}s with imbalanced traffic`);
        // Should switch earlier than base time due to high demand in next phase
        const baseTime = this.strategy.getConfigOptions().baseDuration;
        return phaseChanged && totalTime < baseTime * 0.9;
    }
    /**
     * Test behavior with rush hour traffic pattern
     */
    testRushHourTrafficBehavior() {
        this.setup();
        // First test: consistent high demand on North-South (current phase)
        let queueLengths = [5, 1, 5, 1]; // High on N-S (indices 0 & 2)
        let waitTimes = [20, 5, 20, 5]; // High on N-S
        let states = this.createTrafficStates(queueLengths, waitTimes);
        // Should extend the phase
        let phaseChanged = false;
        let totalTime = 0;
        const timeStep = 1.0;
        // Run for up to 120 seconds
        for (let i = 0; i < 120 && !phaseChanged; i++) {
            this.strategy.update(timeStep, states);
            totalTime += timeStep;
            if (this.strategy.getCurrentPhase() !== 0) {
                phaseChanged = true;
            }
        }
        console.log(`Phase 1 changed after ${totalTime}s with rush hour traffic (N-S)`);
        // Now advance to E-W phase (phase 3)
        this.strategy.update(timeStep, states); // Phase 1
        this.strategy.update(timeStep, states); // Phase 2
        // Reset metrics
        phaseChanged = false;
        totalTime = 0;
        // Run with low traffic on E-W (current phase)
        queueLengths = [5, 1, 5, 1]; // Still high on N-S, low on E-W
        waitTimes = [20, 5, 20, 5];
        states = this.createTrafficStates(queueLengths, waitTimes);
        // Should shorten the phase for E-W since demand is low
        for (let i = 0; i < 120 && !phaseChanged; i++) {
            this.strategy.update(timeStep, states);
            totalTime += timeStep;
            if (this.strategy.getCurrentPhase() !== 2) { // Check phase 3 changed
                phaseChanged = true;
            }
        }
        console.log(`Phase 3 changed after ${totalTime}s with rush hour traffic (low E-W)`);
        // Should change quickly since there's low traffic on current phase but high on next
        const minTime = this.strategy.getConfigOptions().minPhaseDuration;
        const baseTime = this.strategy.getConfigOptions().baseDuration;
        // Should be closer to minimum than base
        return phaseChanged && totalTime < (minTime + baseTime) / 2;
    }
    /**
     * Test configuration options
     */
    testConfigOptions() {
        this.setup();
        // Update configuration
        const testConfig = {
            minPhaseDuration: 8,
            maxPhaseDuration: 45,
            baseDuration: 25,
            trafficSensitivity: 0.8,
            queueWeight: 1.5,
            waitTimeWeight: 0.7
        };
        this.strategy.updateConfig(testConfig);
        // Check that config was applied
        const config = this.strategy.getConfigOptions();
        return config.minPhaseDuration === 8 &&
            config.maxPhaseDuration === 45 &&
            config.baseDuration === 25 &&
            config.trafficSensitivity === 0.8 &&
            config.queueWeight === 1.5 &&
            config.waitTimeWeight === 0.7;
    }
    /**
     * Test serialization and deserialization
     */
    testSerialization() {
        this.setup();
        // Update configuration with non-default values
        this.strategy.updateConfig({
            minPhaseDuration: 8,
            maxPhaseDuration: 45,
            trafficSensitivity: 0.8,
            enableLogging: true
        });
        // Run for a bit to accumulate some history
        const states = this.createTrafficStates([3, 1, 3, 1], [15, 5, 15, 5]);
        for (let i = 0; i < 15; i++) {
            this.strategy.update(1.0, states);
        }
        // Serialize
        const json = this.strategy.toJSON();
        // Deserialize
        const newStrategy = AdaptiveTimingStrategy_1.AdaptiveTimingStrategy.fromJSON(json, this.intersection);
        // Check that key properties match
        return newStrategy.strategyType === this.strategy.strategyType &&
            newStrategy.getConfigOptions().minPhaseDuration === 8 &&
            newStrategy.getConfigOptions().maxPhaseDuration === 45 &&
            newStrategy.getConfigOptions().trafficSensitivity === 0.8 &&
            newStrategy.getConfigOptions().enableLogging === true;
    }
    /**
     * Helper to create traffic states for testing
     */
    createTrafficStates(queueLengths, waitTimes) {
        const states = [];
        for (let i = 0; i < 4; i++) {
            states.push({
                queueLength: queueLengths[i] || 0,
                averageWaitTime: waitTimes[i] || 0,
                maxWaitTime: waitTimes[i] * 1.5 || 0,
                flowRate: queueLengths[i] > 0 ? queueLengths[i] / 2 : 0,
                signalState: [0, 0, 0] // Placeholder, updated by strategy
            });
        }
        return states;
    }
    /**
     * Reset for a new test
     */
    setup() {
        this.strategy = new AdaptiveTimingStrategy_1.AdaptiveTimingStrategy();
        this.strategy.initialize(this.intersection);
        this.strategy.updateConfig({ enableLogging: true });
    }
}
exports.AdaptiveTimingStrategyTest = AdaptiveTimingStrategyTest;
// Export the test class
exports["default"] = AdaptiveTimingStrategyTest;


/***/ }),

/***/ "./src/model/traffic-control/tests/FixedTimingStrategyTest.ts":
/*!********************************************************************!*\
  !*** ./src/model/traffic-control/tests/FixedTimingStrategyTest.ts ***!
  \********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/* module decorator */ module = __webpack_require__.nmd(module);

/**
 * FixedTimingStrategy Tests
 *
 * This file contains tests for the FixedTimingStrategy to verify its behavior
 * and timing accuracy.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.runFixedTimingStrategyTests = exports.FixedTimingStrategyTest = void 0;
const Intersection = __webpack_require__(/*! ../../intersection */ "./src/model/intersection.ts");
const Rect = __webpack_require__(/*! ../../../geom/rect */ "./src/geom/rect.ts");
const FixedTimingStrategy_1 = __webpack_require__(/*! ../FixedTimingStrategy */ "./src/model/traffic-control/FixedTimingStrategy.ts");
/**
 * Simple test utility to verify FixedTimingStrategy behavior
 */
class FixedTimingStrategyTest {
    constructor() {
        this.testResults = [];
        // Create a test intersection
        this.intersection = new Intersection(new Rect(0, 0, 100, 100));
        // Create the strategy
        this.strategy = new FixedTimingStrategy_1.FixedTimingStrategy();
        this.strategy.initialize(this.intersection);
        // Enable logging for the strategy
        this.strategy.setLogging(true);
    }
    /**
     * Run all tests
     */
    runAllTests() {
        console.log('=== Running FixedTimingStrategy Tests ===');
        this.testInitialization();
        this.testPhaseTransitions();
        this.testTimingAccuracy();
        this.testConfigChanges();
        this.testSerializationDeserialization();
        // Report results
        this.reportResults();
    }
    /**
     * Test basic initialization
     */
    testInitialization() {
        try {
            // Check strategy has correct number of phases
            const totalPhases = this.strategy.getTotalPhases();
            this.assert(totalPhases > 0, 'Initialization', `Strategy should have phases defined (found ${totalPhases})`);
            // Check current phase is 0
            const currentPhase = this.strategy.getCurrentPhase();
            this.assert(currentPhase === 0, 'Initialization', `Initial phase should be 0 (found ${currentPhase})`);
            // Check config options
            const config = this.strategy.getConfigOptions();
            this.assert(config.baseDuration > 0, 'Initialization', `Base duration should be positive (found ${config.baseDuration})`);
        }
        catch (error) {
            this.fail('Initialization', `Unexpected error: ${error}`);
        }
    }
    /**
     * Test phase transitions
     */
    testPhaseTransitions() {
        try {
            // Reset the strategy
            this.strategy.reset();
            // Check initial phase
            const initialPhase = this.strategy.getCurrentPhase();
            this.assert(initialPhase === 0, 'PhaseTransitions', `Initial phase should be 0 (found ${initialPhase})`);
            // Get config and set base duration to 1 second for quicker tests
            const config = this.strategy.getConfigOptions();
            config.baseDuration = 1;
            config.variationPercentage = 0; // No variation for predictable tests
            this.strategy.updateConfig(config);
            // Get initial signal states
            const initialStates = this.strategy.update(0);
            // Advance time by just under 1 second
            this.strategy.update(0.9);
            const samePhaseStates = this.strategy.update(0);
            // Check we're still in the same phase
            this.assert(this.strategy.getCurrentPhase() === initialPhase, 'PhaseTransitions', `Should remain in phase ${initialPhase} after 0.9s`);
            // Signal states should be the same
            this.assert(JSON.stringify(initialStates) === JSON.stringify(samePhaseStates), 'PhaseTransitions', 'Signal states should be unchanged within the same phase');
            // Advance time beyond the phase duration
            this.strategy.update(0.2);
            // Check we've moved to the next phase
            const totalPhases = this.strategy.getTotalPhases();
            const expectedPhase = totalPhases > 1 ? 1 : 0;
            this.assert(this.strategy.getCurrentPhase() === expectedPhase, 'PhaseTransitions', `Should advance to phase ${expectedPhase} after exceeding duration`);
            // Signal states should be different if we have multiple phases
            if (totalPhases > 1) {
                const newStates = this.strategy.update(0);
                this.assert(JSON.stringify(initialStates) !== JSON.stringify(newStates), 'PhaseTransitions', 'Signal states should change between phases');
            }
        }
        catch (error) {
            this.fail('PhaseTransitions', `Unexpected error: ${error}`);
        }
    }
    /**
     * Test timing accuracy
     */
    testTimingAccuracy() {
        try {
            // Reset the strategy
            this.strategy.reset();
            this.strategy.resetTimingStatistics();
            // Get config and set base duration to 1 second for quicker tests
            const config = this.strategy.getConfigOptions();
            config.baseDuration = 1;
            config.variationPercentage = 0; // No variation for predictable tests
            this.strategy.updateConfig(config);
            // Run for multiple phases
            const phasesToTest = 3;
            const totalPhases = this.strategy.getTotalPhases();
            const actualPhases = Math.min(phasesToTest, totalPhases);
            console.log(`Testing timing accuracy over ${actualPhases} phases...`);
            for (let i = 0; i < actualPhases; i++) {
                // Small increments to simulate real-time updates
                for (let time = 0; time < 1.1; time += 0.1) {
                    this.strategy.update(0.1);
                }
            }
            // Get timing statistics
            const stats = this.strategy.getTimingStatistics();
            // Check average deviation is within 10%
            this.assert(stats.averageDeviation < 0.1, 'TimingAccuracy', `Average timing deviation should be less than 0.1s (found ${stats.averageDeviation.toFixed(3)}s)`);
            // Check max deviation is within 20%
            this.assert(stats.maxDeviation < 0.2, 'TimingAccuracy', `Max timing deviation should be less than 0.2s (found ${stats.maxDeviation.toFixed(3)}s)`);
        }
        catch (error) {
            this.fail('TimingAccuracy', `Unexpected error: ${error}`);
        }
    }
    /**
     * Test configuration changes
     */
    testConfigChanges() {
        try {
            // Reset the strategy
            this.strategy.reset();
            // Get initial config
            const initialConfig = this.strategy.getConfigOptions();
            // Update config
            const newConfig = {
                ...initialConfig,
                baseDuration: 2,
                variationPercentage: 0
            };
            this.strategy.updateConfig(newConfig);
            // Check config was updated
            const updatedConfig = this.strategy.getConfigOptions();
            this.assert(updatedConfig.baseDuration === 2, 'ConfigChanges', `Base duration should be updated to 2 (found ${updatedConfig.baseDuration})`);
            // Check timing is affected by config change
            // Run for one phase
            let phaseChanged = false;
            let initialPhase = this.strategy.getCurrentPhase();
            // Should NOT change phase after 1 second (new duration is 2 seconds)
            for (let time = 0; time < 1.1; time += 0.1) {
                this.strategy.update(0.1);
                if (this.strategy.getCurrentPhase() !== initialPhase) {
                    phaseChanged = true;
                }
            }
            this.assert(!phaseChanged, 'ConfigChanges', 'Phase should not change before the new duration');
            // Should change phase after another second
            phaseChanged = false;
            for (let time = 0; time < 1.1; time += 0.1) {
                this.strategy.update(0.1);
                if (this.strategy.getCurrentPhase() !== initialPhase) {
                    phaseChanged = true;
                }
            }
            // Only assert if we have more than one phase
            if (this.strategy.getTotalPhases() > 1) {
                this.assert(phaseChanged, 'ConfigChanges', 'Phase should change after the new duration');
            }
        }
        catch (error) {
            this.fail('ConfigChanges', `Unexpected error: ${error}`);
        }
    }
    /**
     * Test serialization and deserialization
     */
    testSerializationDeserialization() {
        try {
            // Reset the strategy
            this.strategy.reset();
            // Update config for a unique test value
            const testConfig = {
                baseDuration: 3.5,
                variationPercentage: 2.5,
                testValue: 'test123'
            };
            this.strategy.updateConfig(testConfig);
            // Set a specific phase
            while (this.strategy.getCurrentPhase() !== 1 % this.strategy.getTotalPhases()) {
                this.strategy.update(10); // Force phase change
            }
            // Serialize
            const serialized = this.strategy.toJSON();
            // Create a new strategy from the serialized data
            const newStrategy = FixedTimingStrategy_1.FixedTimingStrategy.fromJSON(serialized, this.intersection);
            // Check deserialized properties
            this.assert(newStrategy.getCurrentPhase() === this.strategy.getCurrentPhase(), 'Serialization', `Current phase should be preserved (expected ${this.strategy.getCurrentPhase()}, got ${newStrategy.getCurrentPhase()})`);
            // Check config was preserved
            const deserializedConfig = newStrategy.getConfigOptions();
            this.assert(deserializedConfig.baseDuration === testConfig.baseDuration, 'Serialization', `Base duration should be preserved (expected ${testConfig.baseDuration}, got ${deserializedConfig.baseDuration})`);
            this.assert(deserializedConfig.testValue === testConfig.testValue, 'Serialization', `Custom config values should be preserved (expected ${testConfig.testValue}, got ${deserializedConfig.testValue})`);
        }
        catch (error) {
            this.fail('Serialization', `Unexpected error: ${error}`);
        }
    }
    /**
     * Assert a condition and record the result
     */
    assert(condition, testName, message) {
        this.testResults.push({
            name: testName,
            passed: condition,
            message: message
        });
        if (!condition) {
            console.error(`❌ FAILED: ${testName} - ${message}`);
        }
    }
    /**
     * Record a failed test
     */
    fail(testName, message) {
        this.testResults.push({
            name: testName,
            passed: false,
            message: message
        });
        console.error(`❌ FAILED: ${testName} - ${message}`);
    }
    /**
     * Report test results
     */
    reportResults() {
        const total = this.testResults.length;
        const passed = this.testResults.filter(r => r.passed).length;
        console.log('=== FixedTimingStrategy Test Results ===');
        console.log(`Total Tests: ${total}`);
        console.log(`Passed: ${passed}`);
        console.log(`Failed: ${total - passed}`);
        const uniqueTests = [...new Set(this.testResults.map(r => r.name))];
        uniqueTests.forEach(testName => {
            const testsForName = this.testResults.filter(r => r.name === testName);
            const passedForName = testsForName.filter(r => r.passed).length;
            console.log(`\n${testName}: ${passedForName}/${testsForName.length} passed`);
            testsForName.filter(r => !r.passed).forEach(failed => {
                console.error(`  ❌ ${failed.message}`);
            });
        });
        console.log('\n=== End of Test Results ===');
    }
}
exports.FixedTimingStrategyTest = FixedTimingStrategyTest;
/**
 * Run the tests if this file is executed directly
 */
function runFixedTimingStrategyTests() {
    const tester = new FixedTimingStrategyTest();
    tester.runAllTests();
}
exports.runFixedTimingStrategyTests = runFixedTimingStrategyTests;
// If running directly from Node.js
if (typeof window === 'undefined' && __webpack_require__.c[__webpack_require__.s] === module) {
    runFixedTimingStrategyTests();
}


/***/ }),

/***/ "./src/model/traffic-control/tests/KPICollectorTest.ts":
/*!*************************************************************!*\
  !*** ./src/model/traffic-control/tests/KPICollectorTest.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KPICollectorTest = void 0;
const TestCase_1 = __webpack_require__(/*! ../../../tests/TestCase */ "./src/tests/TestCase.ts");
const kpi_collector_1 = __webpack_require__(/*! ../../kpi-collector */ "./src/model/kpi-collector.ts");
/**
 * Tests for the KPI Collector system
 */
class KPICollectorTest extends TestCase_1.TestCase {
    constructor() {
        super(...arguments);
        this.time = 0;
    }
    setUp() {
        this.kpiCollector = new kpi_collector_1.KPICollector();
        // Create mock objects
        this.mockCar = this.createMockCar();
        this.mockLane = this.createMockLane('lane-1');
        this.mockIntersection = this.createMockIntersection('intersection-1', [this.mockLane]);
        // Reset metrics
        this.kpiCollector.reset();
        // Start recording metrics
        this.time = 0;
        this.kpiCollector.startRecording(this.time);
    }
    tearDown() {
        this.kpiCollector.stopRecording();
    }
    /**
     * Test initialization of KPI Collector
     */
    testInitialization() {
        // First reset to ensure clean state
        this.kpiCollector.reset();
        const metrics = this.kpiCollector.getMetrics(this.time);
        this.assertEqual(metrics.totalVehicles, 0, 'Initial total vehicles should be 0');
        this.assertEqual(metrics.activeVehicles, 0, 'Initial active vehicles should be 0');
        this.assertEqual(metrics.completedTrips, 0, 'Initial completed trips should be 0');
        this.assertEqual(metrics.averageSpeed, 0, 'Initial average speed should be 0');
        this.assertEqual(metrics.globalThroughput, 0, 'Initial throughput should be 0');
        this.assertEqual(metrics.averageWaitTime, 0, 'Initial average wait time should be 0');
        this.assertEqual(metrics.maxWaitTime, 0, 'Initial max wait time should be 0');
        this.assertEqual(metrics.totalStops, 0, 'Initial total stops should be 0');
        this.assertEqual(metrics.stoppedVehicles, 0, 'Initial stopped vehicles should be 0');
        this.assertEqual(metrics.congestionIndex, 0, 'Initial congestion index should be 0');
    }
    /**
     * Test recording vehicle enter and exit
     */
    testRecordVehicleEnterExit() {
        // Set up mock car with speed
        this.mockCar.id = 'car-1';
        this.mockCar.speed = 10; // m/s
        // Record vehicle enter
        this.kpiCollector.recordVehicleEnter(this.mockCar, this.time);
        // Check metrics
        const metrics = this.kpiCollector.getMetrics(this.time);
        this.assertEqual(metrics.activeVehicles, 1, 'Active vehicles should be 1');
        // Record another car entering
        const mockCar2 = this.createMockCar();
        mockCar2.id = 'car-2';
        mockCar2.speed = 5; // m/s
        this.kpiCollector.recordVehicleEnter(mockCar2, this.time);
        // Check updated metrics
        const updatedMetrics = this.kpiCollector.getMetrics(this.time);
        this.assertEqual(updatedMetrics.activeVehicles, 2, 'Active vehicles should be 2');
        // Record first car exiting
        this.kpiCollector.recordVehicleExit(this.mockCar, this.time + 10);
        // Check metrics after exit
        const exitMetrics = this.kpiCollector.getMetrics(this.time + 10);
        this.assertEqual(exitMetrics.activeVehicles, 1, 'Active vehicles should be 1 after exit');
        this.assertEqual(exitMetrics.completedTrips, 1, 'Completed trips should be 1');
    }
    /**
     * Test recording vehicle stops and starts
     */
    testRecordVehicleStopStart() {
        // Set up mock car
        this.mockCar.id = 'car-1';
        this.mockCar.speed = 0;
        // Record vehicle enter
        this.kpiCollector.recordVehicleEnter(this.mockCar, this.time);
        // Record vehicle stop
        this.kpiCollector.recordVehicleStop(this.mockCar, this.time + 5);
        // Check metrics
        const metrics = this.kpiCollector.getMetrics(this.time + 5);
        this.assertEqual(metrics.stoppedVehicles, 1, 'Stopped vehicles should be 1');
        // Record vehicle start
        this.time += 10; // 10 seconds stopped
        this.mockCar.speed = 5; // Moving again
        this.kpiCollector.recordVehicleStart(this.mockCar, this.time);
        // Check updated metrics
        const updatedMetrics = this.kpiCollector.getMetrics(this.time);
        this.assertEqual(updatedMetrics.stoppedVehicles, 0, 'Stopped vehicles should be 0');
        // Wait times should be recorded
        this.assertTrue(updatedMetrics.averageWaitTime > 0, 'Should have recorded wait time');
    }
    /**
     * Test lane metrics tracking
     */
    testLaneMetricsTracking() {
        // Setup lane and car
        this.mockCar.id = 'car-1';
        this.mockCar.speed = 10;
        // Record vehicle entering a lane
        this.kpiCollector.recordLaneEnter(this.mockCar, this.mockLane, this.time);
        // Check metrics - lane metrics are accessible via getMetrics().laneMetrics
        const metrics = this.kpiCollector.getMetrics(this.time);
        const laneMetrics = metrics.laneMetrics[this.mockLane.id];
        this.assertNotNull(laneMetrics, 'Lane metrics should exist');
        this.assertEqual(laneMetrics.laneId, 'lane-1', 'Lane ID should match');
        this.assertTrue(laneMetrics.vehicleCount > 0, 'Vehicle count should be greater than 0');
        // Record another vehicle
        const mockCar2 = this.createMockCar();
        mockCar2.id = 'car-2';
        mockCar2.speed = 5;
        this.kpiCollector.recordLaneEnter(mockCar2, this.mockLane, this.time);
        // Record vehicles exiting the lane
        this.time += 10; // 10 seconds later
        this.kpiCollector.recordLaneExit(this.mockCar, this.mockLane, this.time);
        this.kpiCollector.recordLaneExit(mockCar2, this.mockLane, this.time);
        // Get final metrics
        const updatedMetrics = this.kpiCollector.getMetrics(this.time);
        this.assertTrue(updatedMetrics.laneMetrics[this.mockLane.id].totalVehiclesPassed > 0, 'Total vehicles passed should be greater than 0');
    }
    /**
     * Test intersection metrics tracking
     */
    testIntersectionMetricsTracking() {
        // Setup intersection and car
        this.mockCar.id = 'car-1';
        // Record vehicle entering intersection
        this.kpiCollector.recordIntersectionEnter(this.mockCar, this.mockIntersection, this.time);
        // Check metrics
        const metrics = this.kpiCollector.getMetrics(this.time);
        this.assertTrue(metrics.intersectionMetrics.hasOwnProperty(this.mockIntersection.id), 'Intersection metrics should exist');
        // Record vehicle exiting intersection
        this.time += 5; // 5 seconds later
        this.kpiCollector.recordIntersectionExit(this.mockCar, this.mockIntersection, this.time);
        // Check updated metrics
        const updatedMetrics = this.kpiCollector.getMetrics(this.time);
        const intersectionMetrics = updatedMetrics.intersectionMetrics[this.mockIntersection.id];
        this.assertNotNull(intersectionMetrics, 'Intersection metrics should exist');
        this.assertEqual(intersectionMetrics.intersectionId, this.mockIntersection.id, 'Intersection ID should match');
        this.assertTrue(intersectionMetrics.totalVehiclesPassed > 0, 'Vehicles passed should be greater than 0');
        this.assertTrue(intersectionMetrics.averageWaitTime > 0, 'Average wait time should be greater than 0');
    }
    /**
     * Test congestion index calculation
     */
    testCongestionIndexCalculation() {
        // Add multiple vehicles and make some stopped
        for (let i = 0; i < 10; i++) {
            const car = this.createMockCar();
            car.id = `car-${i}`;
            car.speed = i < 5 ? 0 : 10; // Half are stopped
            // Enter simulation
            this.kpiCollector.recordVehicleEnter(car, this.time);
            // Stop half the cars
            if (i < 5) {
                this.kpiCollector.recordVehicleStop(car, this.time);
            }
        }
        // Check metrics
        const metrics = this.kpiCollector.getMetrics(this.time);
        this.assertEqual(metrics.activeVehicles, 10, 'Active vehicles should be 10');
        this.assertEqual(metrics.stoppedVehicles, 5, 'Stopped vehicles should be 5');
        this.assertTrue(metrics.congestionIndex > 0, 'Congestion index should be greater than 0');
    }
    /**
     * Test overall metrics calculations
     */
    testOverallMetricsCalculation() {
        // Simulate a scenario with multiple vehicles and events
        // Time 0: Start with 3 vehicles
        for (let i = 0; i < 3; i++) {
            const car = this.createMockCar();
            car.id = `car-${i}`;
            car.speed = 10;
            this.kpiCollector.recordVehicleEnter(car, this.time);
        }
        // Time 10: One vehicle stops
        this.time = 10;
        const stoppedCar = this.createMockCar();
        stoppedCar.id = 'stopped-car';
        stoppedCar.speed = 0;
        this.kpiCollector.recordVehicleEnter(stoppedCar, this.time);
        this.kpiCollector.recordVehicleStop(stoppedCar, this.time);
        // Time 20: One vehicle enters and exits an intersection
        this.time = 20;
        const intersectionCar = this.createMockCar();
        intersectionCar.id = 'intersection-car';
        intersectionCar.speed = 8;
        this.kpiCollector.recordVehicleEnter(intersectionCar, this.time);
        this.kpiCollector.recordIntersectionEnter(intersectionCar, this.mockIntersection, this.time);
        this.time = 25;
        this.kpiCollector.recordIntersectionExit(intersectionCar, this.mockIntersection, this.time);
        // Time 30: Stopped vehicle starts moving again
        this.time = 30;
        stoppedCar.speed = 5;
        this.kpiCollector.recordVehicleStart(stoppedCar, this.time);
        // Time 40: One vehicle exits the simulation
        this.time = 40;
        this.kpiCollector.recordVehicleExit(intersectionCar, this.time);
        // Check final metrics
        const metrics = this.kpiCollector.getMetrics(this.time);
        // Verify core metrics
        this.assertTrue(metrics.totalVehicles >= 5, 'Total vehicles should be at least 5');
        this.assertTrue(metrics.completedTrips >= 1, 'Should have at least 1 completed trip');
        this.assertTrue(metrics.averageSpeed > 0, 'Average speed should be greater than 0');
        this.assertTrue(metrics.averageWaitTime > 0, 'Average wait time should be greater than 0');
        this.assertTrue(metrics.simulationTime === 40, 'Simulation time should be 40');
    }
    /**
     * Test CSV export
     */
    testExportCSV() {
        // Setup some data
        this.mockCar.id = 'car-1';
        this.mockCar.speed = 10;
        // Record events
        this.kpiCollector.recordVehicleEnter(this.mockCar, this.time);
        // Record vehicle entering a lane
        this.kpiCollector.recordLaneEnter(this.mockCar, this.mockLane, this.time);
        // Record vehicle entering intersection
        this.kpiCollector.recordIntersectionEnter(this.mockCar, this.mockIntersection, this.time);
        this.time += 5;
        this.kpiCollector.recordIntersectionExit(this.mockCar, this.mockIntersection, this.time);
        // Export to CSV
        const csv = this.kpiCollector.exportMetricsCSV();
        // Check CSV content
        this.assertTrue(csv.includes('Global Metrics'), 'CSV should have global metrics');
        this.assertTrue(csv.includes('Lane Metrics'), 'CSV should have lane section');
        this.assertTrue(csv.includes('Intersection Metrics'), 'CSV should have intersection section');
    }
    /**
     * Test JSON export
     */
    testExportJSON() {
        // Setup some data
        this.mockCar.id = 'car-1';
        this.mockCar.speed = 10;
        // Record events
        this.kpiCollector.recordVehicleEnter(this.mockCar, this.time);
        // Record vehicle entering a lane
        this.kpiCollector.recordLaneEnter(this.mockCar, this.mockLane, this.time);
        // Record vehicle entering intersection
        this.kpiCollector.recordIntersectionEnter(this.mockCar, this.mockIntersection, this.time);
        this.time += 5;
        this.kpiCollector.recordIntersectionExit(this.mockCar, this.mockIntersection, this.time);
        // Export to JSON
        const jsonString = this.kpiCollector.exportMetricsJSON();
        // Parse JSON
        const json = JSON.parse(jsonString);
        // Check JSON content
        this.assertTrue(json.hasOwnProperty('simulationTime'), 'JSON should have simulation time');
        this.assertTrue(json.hasOwnProperty('totalVehicles'), 'JSON should have total vehicles');
        this.assertTrue(json.hasOwnProperty('intersectionMetrics'), 'JSON should have intersection metrics');
        this.assertTrue(json.hasOwnProperty('laneMetrics'), 'JSON should have lane metrics');
    }
    /**
     * Test export validation
     */
    testExportValidation() {
        // Setup some data
        this.mockCar.id = 'car-1';
        this.mockCar.speed = 10;
        this.kpiCollector.recordVehicleEnter(this.mockCar, this.time);
        // Validate exports
        const validationResult = this.kpiCollector.validateExportData();
        // Check validation result
        this.assertTrue(validationResult.isValid, 'Validation should pass');
        this.assertTrue(validationResult.discrepancies.length >= 0, 'Should have discrepancies list');
        this.assertTrue(validationResult.summary.length > 0, 'Should have summary text');
    }
    /**
     * Helper to create a mock car
     */
    createMockCar() {
        // @ts-ignore - Create a simplified mock car for testing
        return {
            id: '',
            speed: 0
        };
    }
    /**
     * Helper to create a mock lane
     */
    createMockLane(id) {
        return {
            id: id,
            length: 100,
            width: 3,
            cars: []
        };
    }
    /**
     * Helper to create a mock intersection
     */
    createMockIntersection(id, lanes) {
        return {
            id: id,
            incomingLanes: lanes,
            outgoingLanes: []
        };
    }
}
exports.KPICollectorTest = KPICollectorTest;


/***/ }),

/***/ "./src/model/traffic-control/tests/TestRunner.ts":
/*!*******************************************************!*\
  !*** ./src/model/traffic-control/tests/TestRunner.ts ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * Test Runner
 *
 * This file exports a test runner that can be used to run tests from the browser console.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.testRunner = exports.TrafficControlTestRunner = void 0;
const FixedTimingStrategyTest_1 = __webpack_require__(/*! ./FixedTimingStrategyTest */ "./src/model/traffic-control/tests/FixedTimingStrategyTest.ts");
const AdaptiveTimingStrategyTest_1 = __importDefault(__webpack_require__(/*! ./AdaptiveTimingStrategyTest */ "./src/model/traffic-control/tests/AdaptiveTimingStrategyTest.ts"));
const TrafficEnforcerStrategyTest_1 = __importDefault(__webpack_require__(/*! ./TrafficEnforcerStrategyTest */ "./src/model/traffic-control/tests/TrafficEnforcerStrategyTest.ts"));
const TrafficLightControllerTest_1 = __importDefault(__webpack_require__(/*! ./TrafficLightControllerTest */ "./src/model/traffic-control/tests/TrafficLightControllerTest.ts"));
const KPICollectorTest_1 = __webpack_require__(/*! ./KPICollectorTest */ "./src/model/traffic-control/tests/KPICollectorTest.ts");
/**
 * Test runner for traffic control strategies
 */
class TrafficControlTestRunner {
    /**
     * Run all tests
     */
    runAllTests() {
        console.log('=== Running Traffic Control Tests ===');
        this.runKPICollectorTests(); // Run KPI collector tests first
        this.runTrafficLightControllerTests();
        this.runFixedTimingTests();
        this.runAdaptiveTimingTests();
        this.runTrafficEnforcerTests();
        console.log('=== All Tests Completed ===');
    }
    /**
     * Run KPI collector tests
     */
    runKPICollectorTests() {
        console.log('\n=== KPI Collector Tests ===');
        const tester = new KPICollectorTest_1.KPICollectorTest();
        this.runTestSuite(tester);
    }
    /**
     * Run traffic light controller tests
     */
    runTrafficLightControllerTests() {
        console.log('\n=== Traffic Light Controller Tests ===');
        const tester = new TrafficLightControllerTest_1.default();
        tester.runTests();
    }
    /**
     * Run fixed timing strategy tests
     */
    runFixedTimingTests() {
        console.log('\n=== Fixed Timing Strategy Tests ===');
        (0, FixedTimingStrategyTest_1.runFixedTimingStrategyTests)();
    }
    /**
     * Run adaptive timing strategy tests
     */
    runAdaptiveTimingTests() {
        console.log('\n=== Adaptive Timing Strategy Tests ===');
        const tester = new AdaptiveTimingStrategyTest_1.default();
        tester.runTests();
    }
    /**
     * Run traffic enforcer strategy tests
     */
    runTrafficEnforcerTests() {
        console.log('\n=== Traffic Enforcer Strategy Tests ===');
        const tester = new TrafficEnforcerStrategyTest_1.default();
        tester.runTests();
    }
    /**
     * Run a test suite using reflection to find test methods
     */
    runTestSuite(testCase) {
        // Find all test methods (those starting with "test")
        const testMethods = Object.getOwnPropertyNames(Object.getPrototypeOf(testCase))
            .filter(method => method.startsWith('test') && typeof testCase[method] === 'function');
        console.log(`Found ${testMethods.length} tests to run`);
        let passed = 0;
        let failed = 0;
        // Run each test method
        for (const method of testMethods) {
            try {
                console.log(`Running test: ${method}`);
                testCase.setUp();
                testCase[method]();
                testCase.tearDown();
                console.log(`✅ Test passed: ${method}`);
                passed++;
            }
            catch (error) {
                console.error(`❌ Test failed: ${method}`);
                console.error(error);
                failed++;
            }
        }
        // Report results
        console.log(`\nTest summary: ${passed} passed, ${failed} failed, ${testMethods.length} total`);
    }
}
exports.TrafficControlTestRunner = TrafficControlTestRunner;
// Export a singleton instance
exports.testRunner = new TrafficControlTestRunner();


/***/ }),

/***/ "./src/model/traffic-control/tests/TrafficEnforcerStrategyTest.ts":
/*!************************************************************************!*\
  !*** ./src/model/traffic-control/tests/TrafficEnforcerStrategyTest.ts ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * TrafficEnforcerStrategyTest
 *
 * Test suite for the TrafficEnforcerStrategy implementation
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TrafficEnforcerStrategyTest = void 0;
const Intersection = __webpack_require__(/*! ../../intersection */ "./src/model/intersection.ts");
const Rect = __webpack_require__(/*! ../../../geom/rect */ "./src/geom/rect.ts");
const TrafficEnforcerStrategy_1 = __webpack_require__(/*! ../TrafficEnforcerStrategy */ "./src/model/traffic-control/TrafficEnforcerStrategy.ts");
class TrafficEnforcerStrategyTest {
    constructor() {
        // Create a mock intersection
        this.intersection = new Intersection(new Rect(0, 0, 100, 100));
        this.intersection.id = 'test-intersection';
        // Create the strategy
        this.strategy = new TrafficEnforcerStrategy_1.TrafficEnforcerStrategy();
        // Configure for testing
        this.strategy.updateConfig({
            decisionInterval: 2,
            minimumGreenTime: 3 // Shorter minimum green time for testing
        });
        this.strategy.initialize(this.intersection);
    }
    /**
     * Run all tests
     */
    runTests() {
        console.log('=== Running TrafficEnforcerStrategy Tests ===');
        let allPassed = true;
        const tests = [
            this.testInitialization,
            this.testBasicDecisionMaking,
            this.testConflictAvoidance,
            this.testPriorityHandling,
            this.testEmergencyConditions,
            this.testFairnessHandling,
            this.testSerialization
        ];
        for (const test of tests) {
            try {
                console.log(`\nRunning: ${test.name}`);
                const passed = test.call(this);
                console.log(`${test.name}: ${passed ? 'PASSED' : 'FAILED'}`);
                allPassed = allPassed && passed;
            }
            catch (e) {
                console.error(`Test ${test.name} FAILED with error:`, e);
                allPassed = false;
            }
        }
        console.log(`\nFinal result: ${allPassed ? 'ALL TESTS PASSED' : 'SOME TESTS FAILED'}`);
        return allPassed;
    }
    /**
     * Test basic initialization
     */
    testInitialization() {
        this.setup();
        // Check that strategy initialized properly
        const initialState = this.strategy.getCurrentSignalStates();
        // All signals should start as red
        const allRed = initialState.every(direction => direction.every(signal => signal === 0));
        return this.strategy.strategyType === 'traffic-enforcer' && allRed;
    }
    /**
     * Test basic decision-making
     */
    testBasicDecisionMaking() {
        this.setup();
        // Simulate traffic in North direction
        const states = this.createTrafficStates([5, 0, 0, 0], [20, 0, 0, 0]);
        // Run for a few seconds to trigger decision making
        for (let i = 0; i < 10; i++) {
            this.strategy.update(1.0, states);
        }
        // Check that at least one signal in the North direction is green
        const currentState = this.strategy.getCurrentSignalStates();
        const northSignal = currentState[0]; // North direction
        const northHasGreen = northSignal.some(signal => signal === 1);
        if (!northHasGreen) {
            console.log("Expected North direction to have at least one green signal");
            console.log("Current state:", currentState);
            return false;
        }
        return true;
    }
    /**
     * Test that conflicting movements aren't allowed simultaneously
     */
    testConflictAvoidance() {
        this.setup();
        // Heavy congestion in all directions
        const states = this.createTrafficStates([10, 10, 10, 10], [30, 30, 30, 30]);
        // Run for enough time to make several decisions
        for (let i = 0; i < 20; i++) {
            this.strategy.update(1.0, states);
        }
        // Check current state
        const currentState = this.strategy.getCurrentSignalStates();
        // Define conflicting pairs to check
        // We'll check a few key conflicts: 
        // 1. North-South vs East-West through movements
        // 2. Left turns vs opposing through movements
        const conflicts = [
            { dir1: 0, mov1: 1, dir2: 1, mov2: 1 },
            { dir1: 0, mov1: 0, dir2: 2, mov2: 1 },
            { dir1: 1, mov1: 0, dir2: 3, mov2: 1 }, // E-left vs W-straight
        ];
        // Check each conflict pair
        for (const conflict of conflicts) {
            const signal1 = currentState[conflict.dir1][conflict.mov1];
            const signal2 = currentState[conflict.dir2][conflict.mov2];
            if (signal1 === 1 && signal2 === 1) {
                console.log(`Conflict detected: Direction ${conflict.dir1} movement ${conflict.mov1} and Direction ${conflict.dir2} movement ${conflict.mov2} are both green`);
                console.log("Current state:", currentState);
                return false;
            }
        }
        return true;
    }
    /**
     * Test priority handling
     */
    testPriorityHandling() {
        this.setup();
        // Configure priorities
        this.strategy.updateConfig({
            prioritizedDirections: [1],
            prioritizedMovements: [{ direction: 1, movement: 1 }] // East straight movement
        });
        // Equal congestion in all directions
        const states = this.createTrafficStates([5, 5, 5, 5], [15, 15, 15, 15]);
        // Run for enough time to make a decision
        for (let i = 0; i < 10; i++) {
            this.strategy.update(1.0, states);
        }
        // Check that East direction has been prioritized
        const currentState = this.strategy.getCurrentSignalStates();
        const eastSignal = currentState[1]; // East direction
        const eastStraightIsGreen = eastSignal[1] === 1; // Check if straight movement is green
        if (!eastStraightIsGreen) {
            console.log("Expected East straight movement to be prioritized");
            console.log("Current state:", currentState);
            return false;
        }
        return true;
    }
    /**
     * Test emergency conditions
     */
    testEmergencyConditions() {
        this.setup();
        // Configure emergency threshold
        this.strategy.updateConfig({
            emergencyThreshold: 8 // Lower threshold for testing
        });
        // First, establish some baseline with moderate congestion
        let states = this.createTrafficStates([3, 3, 3, 3], [10, 10, 10, 10]);
        for (let i = 0; i < 5; i++) {
            this.strategy.update(1.0, states);
        }
        // Record initial state
        const initialState = this.strategy.getCurrentSignalStates();
        // Now create emergency in North direction
        states = this.createTrafficStates([15, 3, 3, 3], [45, 10, 10, 10]);
        // Should trigger immediate decision
        this.strategy.update(1.0, states);
        // Check that North direction has green signal after emergency
        const currentState = this.strategy.getCurrentSignalStates();
        const northSignal = currentState[0]; // North direction
        const northHasGreen = northSignal.some(signal => signal === 1);
        if (!northHasGreen) {
            console.log("Expected North direction to have green signal after emergency");
            console.log("Current state:", currentState);
            return false;
        }
        return true;
    }
    /**
     * Test fairness handling
     */
    testFairnessHandling() {
        this.setup();
        // First give a lot of green time to North direction
        let states = this.createTrafficStates([10, 1, 1, 1], [30, 5, 5, 5]);
        for (let i = 0; i < 30; i++) {
            this.strategy.update(1.0, states);
        }
        // Now equalize congestion but South has been neglected
        states = this.createTrafficStates([5, 5, 5, 5], [15, 15, 15, 15]);
        // Run for enough time to make several decisions
        for (let i = 0; i < 20; i++) {
            this.strategy.update(1.0, states);
        }
        // Check that South direction gets green time due to fairness
        const currentState = this.strategy.getCurrentSignalStates();
        let southGreenObserved = false;
        // We'd need to run the simulation longer to guarantee South gets green,
        // but for test purposes, we'll just check if South has green now
        if (currentState[2].some(signal => signal === 1)) {
            southGreenObserved = true;
        }
        return southGreenObserved;
    }
    /**
     * Test serialization and deserialization
     */
    testSerialization() {
        this.setup();
        // Configure with non-default values
        this.strategy.updateConfig({
            decisionInterval: 7,
            prioritizedDirections: [2],
            priorityThreshold: 6
        });
        // Establish some state
        const states = this.createTrafficStates([5, 3, 8, 2], [15, 10, 25, 8]);
        for (let i = 0; i < 10; i++) {
            this.strategy.update(1.0, states);
        }
        // Serialize
        const json = this.strategy.toJSON();
        // Deserialize
        const newStrategy = TrafficEnforcerStrategy_1.TrafficEnforcerStrategy.fromJSON(json, this.intersection);
        // Check that key properties match
        const matchesType = newStrategy.strategyType === 'traffic-enforcer';
        const matchesInterval = newStrategy.getConfigOptions().decisionInterval === 7;
        const matchesPriorities = Array.isArray(newStrategy.getConfigOptions().prioritizedDirections) &&
            newStrategy.getConfigOptions().prioritizedDirections.includes(2);
        const matchesThreshold = newStrategy.getConfigOptions().priorityThreshold === 6;
        // Also check that signal states were preserved
        const originalState = this.strategy.getCurrentSignalStates();
        const newState = newStrategy.getCurrentSignalStates();
        const signalsMatch = JSON.stringify(originalState) === JSON.stringify(newState);
        return matchesType && matchesInterval && matchesPriorities &&
            matchesThreshold && signalsMatch;
    }
    /**
     * Helper to create traffic states for testing
     */
    createTrafficStates(queueLengths, waitTimes) {
        const states = [];
        for (let i = 0; i < 4; i++) {
            states.push({
                queueLength: queueLengths[i] || 0,
                averageWaitTime: waitTimes[i] || 0,
                maxWaitTime: waitTimes[i] * 1.5 || 0,
                flowRate: queueLengths[i] > 0 ? queueLengths[i] / 2 : 0,
                signalState: [0, 0, 0] // Placeholder, updated by strategy
            });
        }
        return states;
    }
    /**
     * Reset for a new test
     */
    setup() {
        this.strategy = new TrafficEnforcerStrategy_1.TrafficEnforcerStrategy();
        this.strategy.updateConfig({
            decisionInterval: 2,
            minimumGreenTime: 3 // Shorter minimum green time for testing
        });
        this.strategy.initialize(this.intersection);
    }
}
exports.TrafficEnforcerStrategyTest = TrafficEnforcerStrategyTest;
// Export the test class
exports["default"] = TrafficEnforcerStrategyTest;


/***/ }),

/***/ "./src/model/traffic-control/tests/TrafficLightControllerTest.ts":
/*!***********************************************************************!*\
  !*** ./src/model/traffic-control/tests/TrafficLightControllerTest.ts ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * TrafficLightControllerTest
 *
 * Test suite for the TrafficLightController class and its integration with strategies.
 * Tests that switching strategies changes control behavior and that the system
 * remains stable and efficient.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TrafficLightControllerTest = void 0;
const Intersection = __webpack_require__(/*! ../../intersection */ "./src/model/intersection.ts");
const Rect = __webpack_require__(/*! ../../../geom/rect */ "./src/geom/rect.ts");
const TrafficLightController = __webpack_require__(/*! ../TrafficLightController */ "./src/model/traffic-control/TrafficLightController.ts");
const TrafficControlStrategyManager_1 = __webpack_require__(/*! ../TrafficControlStrategyManager */ "./src/model/traffic-control/TrafficControlStrategyManager.ts");
class TrafficLightControllerTest {
    constructor() {
        // Create a mock intersection
        this.intersection = new Intersection(new Rect(0, 0, 100, 100));
        this.intersection.id = 'test-intersection';
        // Create the controller
        this.controller = new TrafficLightController(this.intersection);
    }
    /**
     * Run all tests
     */
    runTests() {
        console.log('=== Running TrafficLightController Tests ===');
        let allPassed = true;
        const tests = [
            this.testInitialization,
            this.testStrategySwitch,
            this.testDefaultStrategy,
            this.testStateAccess,
            this.testStrategyIntegration,
            this.testSerialization,
            this.testDifferentBehaviors
        ];
        for (const test of tests) {
            try {
                console.log(`\nRunning: ${test.name}`);
                const passed = test.call(this);
                console.log(`${test.name}: ${passed ? 'PASSED' : 'FAILED'}`);
                allPassed = allPassed && passed;
            }
            catch (e) {
                console.error(`Test ${test.name} FAILED with error:`, e);
                allPassed = false;
            }
        }
        console.log(`\nFinal result: ${allPassed ? 'ALL TESTS PASSED' : 'SOME TESTS FAILED'}`);
        return allPassed;
    }
    /**
     * Test basic initialization
     */
    testInitialization() {
        // Check that controller initializes properly with default strategy
        const initialState = this.controller.state;
        // State should be a 4x3 array (4 approaches, 3 movements per approach)
        const isValidState = initialState.length === 4 &&
            initialState.every(approach => approach.length === 3);
        // Check that traffic states were initialized
        const hasTrafficStates = Array.isArray(this.controller['trafficStates']) &&
            this.controller['trafficStates'].length === 4;
        return isValidState && hasTrafficStates;
    }
    /**
     * Test strategy switching
     */
    testStrategySwitch() {
        // Get current strategy type
        const initialStrategyType = this.controller.getStrategy().strategyType;
        // Find a different strategy to switch to
        const availableTypes = TrafficControlStrategyManager_1.trafficControlStrategyManager.getAvailableStrategyTypes();
        const differentType = availableTypes.find(type => type !== initialStrategyType);
        if (!differentType) {
            console.error("Couldn't find a different strategy to switch to");
            return false;
        }
        // Switch to different strategy
        const switchSuccess = this.controller.setStrategy(differentType);
        if (!switchSuccess) {
            console.error(`Failed to switch to strategy ${differentType}`);
            return false;
        }
        // Verify that strategy changed
        const newStrategyType = this.controller.getStrategy().strategyType;
        return newStrategyType === differentType && newStrategyType !== initialStrategyType;
    }
    /**
     * Test that a default strategy is always active
     */
    testDefaultStrategy() {
        // Create a new controller
        const controller = new TrafficLightController(this.intersection);
        // Strategy should exist and have a valid type
        const strategy = controller.getStrategy();
        return !!strategy &&
            typeof strategy.strategyType === 'string' &&
            strategy.strategyType.length > 0;
    }
    /**
     * Test state access
     */
    testStateAccess() {
        // Get state
        const state = this.controller.state;
        // State should be a 4x3 array with valid values (0 or 1)
        const isValidState = state.length === 4 &&
            state.every(approach => approach.length === 3 &&
                approach.every(signal => signal === 0 || signal === 1));
        return isValidState;
    }
    /**
     * Test that controller correctly integrates with strategies
     */
    testStrategyIntegration() {
        // Set fixed timing strategy
        this.controller.setStrategy('fixed-timing');
        // Update a few times
        for (let i = 0; i < 5; i++) {
            this.controller.onTick(1.0);
        }
        // Get state after updates
        const state1 = this.controller.state;
        // Save phase info
        const phase1 = this.controller.getStrategy().getCurrentPhase();
        // Update a lot more to trigger phase change
        for (let i = 0; i < 30; i++) {
            this.controller.onTick(1.0);
        }
        // Get state after more updates
        const state2 = this.controller.state;
        // Phase should have changed
        const phase2 = this.controller.getStrategy().getCurrentPhase();
        // Either phase or state should be different
        const phaseDifferent = phase1 !== phase2;
        const stateDifferent = JSON.stringify(state1) !== JSON.stringify(state2);
        return phaseDifferent || stateDifferent;
    }
    /**
     * Test serialization and deserialization
     */
    testSerialization() {
        // Configure with non-default strategy
        this.controller.setStrategy('adaptive-timing');
        // Update a bit to establish state
        for (let i = 0; i < 5; i++) {
            this.controller.onTick(1.0);
        }
        // Serialize
        const json = this.controller.toJSON();
        // Deserialize
        const newController = TrafficLightController.copy(json, this.intersection);
        // Check that the strategy type matches
        const originalType = this.controller.getStrategy().strategyType;
        const newType = newController.getStrategy().strategyType;
        return originalType === newType;
    }
    /**
     * Test that different strategies produce different behaviors
     */
    testDifferentBehaviors() {
        const trafficStates = this.createHighTrafficStates();
        // Test with fixed timing strategy
        this.controller.setStrategy('fixed-timing');
        const fixedStates = [];
        for (let i = 0; i < 50; i++) {
            this.controller.onTick(1.0);
            // Only record every 10th state to reduce noise
            if (i % 10 === 0) {
                fixedStates.push(JSON.parse(JSON.stringify(this.controller.state)));
            }
        }
        // Test with adaptive timing strategy
        this.controller.setStrategy('adaptive-timing');
        const adaptiveStates = [];
        for (let i = 0; i < 50; i++) {
            // Update traffic states
            this.updateControllerTrafficStates(trafficStates);
            this.controller.onTick(1.0);
            // Only record every 10th state to reduce noise
            if (i % 10 === 0) {
                adaptiveStates.push(JSON.parse(JSON.stringify(this.controller.state)));
            }
        }
        // Test with enforcer strategy
        this.controller.setStrategy('traffic-enforcer');
        const enforcerStates = [];
        for (let i = 0; i < 50; i++) {
            // Update traffic states
            this.updateControllerTrafficStates(trafficStates);
            this.controller.onTick(1.0);
            // Only record every 10th state to reduce noise
            if (i % 10 === 0) {
                enforcerStates.push(JSON.parse(JSON.stringify(this.controller.state)));
            }
        }
        // Compare states between strategies
        // We expect at least some differences between the strategies
        let fixedVsAdaptiveDifferent = false;
        let fixedVsEnforcerDifferent = false;
        let adaptiveVsEnforcerDifferent = false;
        for (let i = 0; i < Math.min(fixedStates.length, adaptiveStates.length, enforcerStates.length); i++) {
            if (JSON.stringify(fixedStates[i]) !== JSON.stringify(adaptiveStates[i])) {
                fixedVsAdaptiveDifferent = true;
            }
            if (JSON.stringify(fixedStates[i]) !== JSON.stringify(enforcerStates[i])) {
                fixedVsEnforcerDifferent = true;
            }
            if (JSON.stringify(adaptiveStates[i]) !== JSON.stringify(enforcerStates[i])) {
                adaptiveVsEnforcerDifferent = true;
            }
        }
        // All strategy pairs should have at least one difference
        return fixedVsAdaptiveDifferent && fixedVsEnforcerDifferent && adaptiveVsEnforcerDifferent;
    }
    /**
     * Helper method to create traffic states with high traffic volume
     */
    createHighTrafficStates() {
        // Create traffic states with high volume in North direction
        return [
            { queueLength: 10, averageWaitTime: 30, maxWaitTime: 50, flowRate: 5, signalState: [0, 0, 0] },
            { queueLength: 2, averageWaitTime: 5, maxWaitTime: 10, flowRate: 8, signalState: [0, 0, 0] },
            { queueLength: 3, averageWaitTime: 10, maxWaitTime: 15, flowRate: 7, signalState: [0, 0, 0] },
            { queueLength: 1, averageWaitTime: 3, maxWaitTime: 5, flowRate: 10, signalState: [0, 0, 0] }
        ];
    }
    /**
     * Helper method to update controller traffic states
     */
    updateControllerTrafficStates(states) {
        // Update controller's traffic states directly
        // This is a bit of a hack, but it's the easiest way to test strategies
        if (this.controller['trafficStates']) {
            for (let i = 0; i < states.length; i++) {
                if (i < this.controller['trafficStates'].length) {
                    this.controller['trafficStates'][i].queueLength = states[i].queueLength;
                    this.controller['trafficStates'][i].averageWaitTime = states[i].averageWaitTime;
                    this.controller['trafficStates'][i].maxWaitTime = states[i].maxWaitTime;
                    this.controller['trafficStates'][i].flowRate = states[i].flowRate;
                }
            }
        }
    }
}
exports.TrafficLightControllerTest = TrafficLightControllerTest;
// Export the test class
exports["default"] = TrafficLightControllerTest;


/***/ }),

/***/ "./src/model/traffic-control/tests/index.ts":
/*!**************************************************!*\
  !*** ./src/model/traffic-control/tests/index.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Traffic Control Tests Integration
 *
 * This file registers the test runner with the global window object
 * so it can be called from the browser console.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const TestRunner_1 = __webpack_require__(/*! ./TestRunner */ "./src/model/traffic-control/tests/TestRunner.ts");
// Register the test runner with the global window object
window.trafficControlTests = TestRunner_1.testRunner;
// Log a message to the console indicating how to run tests
console.log(`
To run traffic control tests, open the browser console and type:
  trafficControlTests.runAllTests()
  
Or run specific test categories:
  trafficControlTests.runKPICollectorTests()
  trafficControlTests.runTrafficLightControllerTests()
  trafficControlTests.runFixedTimingTests()
  trafficControlTests.runAdaptiveTimingTests()
  trafficControlTests.runTrafficEnforcerTests()
`);


/***/ }),

/***/ "./src/model/trajectory.ts":
/*!*********************************!*\
  !*** ./src/model/trajectory.ts ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! ../helpers */ "./src/helpers.ts");
const LanePosition = __webpack_require__(/*! ./lane-position */ "./src/model/lane-position.ts");
const Curve = __webpack_require__(/*! ../geom/curve */ "./src/geom/curve.ts");
const kpi_collector_1 = __webpack_require__(/*! ./kpi-collector */ "./src/model/kpi-collector.ts");
const Car_Class = __webpack_require__(/*! ./car */ "./src/model/car.ts"); // Import the actual Car class to access worldTime
const { min, max } = Math;
class Trajectory {
    constructor(car, lane, position) {
        this.car = car;
        position = position || 0;
        this.current = new LanePosition(car, lane, position);
        this.current.acquire();
        this.next = new LanePosition(car);
        this.temp = new LanePosition(car);
        this.isChangingLanes = false;
    }
    get lane() {
        return this.temp.lane || this.current.lane;
    }
    get absolutePosition() {
        return this.temp.lane ? this.temp.position : this.current.position;
    }
    get relativePosition() {
        return this.absolutePosition / this.lane.length;
    }
    get direction() {
        return this.lane.getDirection(this.relativePosition);
    }
    get coords() {
        return this.lane.getPoint(this.relativePosition);
    }
    get nextCarDistance() {
        const a = this.current.nextCarDistance;
        const b = this.next.nextCarDistance;
        return a.distance < b.distance ? a : b;
    }
    get distanceToStopLine() {
        if (!this.canEnterIntersection()) {
            return this.getDistanceToIntersection();
        }
        return Infinity;
    }
    get nextIntersection() {
        return this.current.lane.road.target;
    }
    get previousIntersection() {
        return this.current.lane.road.source;
    }
    // Check if turn is valid based on lane positioning (simplified from reference)
    isValidTurn() {
        try {
            // Get next lane and current lane
            const nextLane = this.car.nextLane;
            const sourceLane = this.current.lane;
            // Must have a next lane to make a turn
            if (!nextLane) {
                throw Error('no road to enter');
            }
            // Get the turn direction
            const turnNumber = sourceLane.getTurnDirection(nextLane);
            // No U-turns allowed
            if (turnNumber === 3) {
                throw Error('no U-turns are allowed');
            }
            // Left turns must be from the leftmost lane
            if (turnNumber === 0 && !sourceLane.isLeftmost) {
                throw Error('no left turns from this lane');
            }
            // Right turns must be from the rightmost lane
            if (turnNumber === 2 && !sourceLane.isRightmost) {
                throw Error('no right turns from this lane');
            }
            return true;
        }
        catch (error) {
            // Any error means the turn is invalid
            return false;
        }
    }
    // Check if traffic signals allow entry into intersection (simplified from reference)
    canEnterIntersection() {
        try {
            // Get the next lane for the car
            const nextLane = this.car.nextLane;
            const sourceLane = this.current.lane;
            // If no next lane, we're not planning to enter the intersection
            if (!nextLane) {
                return true;
            }
            // Get the intersection and its traffic signals
            const intersection = this.nextIntersection;
            // Get the turn direction and side ID
            const turnNumber = sourceLane.getTurnDirection(nextLane);
            const sideId = sourceLane.road.targetSideId;
            // Check if the signal state allows entry
            return intersection.controlSignals.state[sideId][turnNumber] === 1;
        }
        catch (error) {
            // On error, prevent entry for safety
            return false;
        }
    }
    // Calculate distance to the next intersection
    getDistanceToIntersection() {
        const distance = this.current.lane.length - this.car.length / 2 - this.current.position;
        return !this.isChangingLanes ? max(distance, 0) : Infinity;
    }
    // Check if we need to make a turn at the upcoming intersection
    timeToMakeTurn(plannedStep = 0) {
        return this.getDistanceToIntersection() <= plannedStep;
    }
    // Move the car forward along its trajectory (simplified to match reference)
    moveForward(distance) {
        var _a, _b;
        try {
            // Ensure distance is valid (directly from reference)
            distance = max(distance, 0);
            // Update positions (directly from reference)
            this.current.position += distance;
            this.next.position += distance;
            this.temp.position += distance;
            // === INTERSECTION LOGIC (simplified from reference) ===
            // If at intersection and can enter it, make turn if we have a next lane
            if (this.timeToMakeTurn() && this.canEnterIntersection() && this.isValidTurn()) {
                try {
                    // Check if we're entering an intersection, and record it
                    if (this.nextIntersection) {
                        kpi_collector_1.kpiCollector.recordIntersectionEnter(this.car, this.nextIntersection, Car_Class.worldTime);
                    }
                    // Get previous intersection before changing lanes
                    const previousIntersection = this.nextIntersection;
                    const nextLane = this.car.popNextLane();
                    if (nextLane) {
                        this._startChangingLanes(nextLane, 0);
                        // Record exit from intersection if we moved to a new lane
                        if (previousIntersection && previousIntersection !== this.nextIntersection) {
                            kpi_collector_1.kpiCollector.recordIntersectionExit(this.car, previousIntersection, Car_Class.worldTime);
                        }
                    }
                }
                catch (error) {
                    // If turn fails, car will be removed in the car's move method
                    this.car.alive = false;
                    return;
                }
            }
            // === LANE CHANGING MANAGEMENT (directly from reference) ===
            const tempRelativePosition = this.temp.position / (((_a = this.temp.lane) === null || _a === void 0 ? void 0 : _a.length) || 1);
            const gap = 2 * this.car.length;
            // Phase 1: Release current lane after moving enough into new lane
            if (this.isChangingLanes && this.temp.position > gap && !this.current.free) {
                this.current.release();
            }
            // Phase 2: Acquire next lane as we approach it
            if (this.isChangingLanes && this.next.free &&
                this.temp.position + gap > (((_b = this.temp.lane) === null || _b === void 0 ? void 0 : _b.length) || 0)) {
                this.next.acquire();
            }
            // Phase 3: Complete the lane change when we reach the end of the curve
            if (this.isChangingLanes && tempRelativePosition >= 1) {
                this._finishChangingLanes();
            }
            // Plan ahead - if we're not changing lanes and don't have a next lane, pick one
            if (this.current.lane && !this.isChangingLanes && !this.car.nextLane) {
                try {
                    this.car.pickNextLane();
                }
                catch (error) {
                    // Sometimes there's no valid next lane, which is fine
                    // The car will be despawned when it reaches the intersection
                }
            }
        }
        catch (error) {
            console.error('🚗 [TRAJ ERROR] Error in moveForward:', error);
        }
    }
    changeLane(nextLane) {
        if (this.isChangingLanes) {
            throw new Error('already changing lane');
        }
        if (!nextLane) {
            throw new Error('no next lane');
        }
        if (nextLane === this.lane) {
            throw new Error('next lane == current lane');
        }
        if (this.lane.road !== nextLane.road) {
            throw new Error('not neighbouring lanes');
        }
        const nextPosition = this.current.position + 3 * this.car.length;
        if (nextPosition >= this.lane.length) {
            throw new Error('too late to change lane');
        }
        this._startChangingLanes(nextLane, nextPosition);
    }
    // Create a curve for turning at an intersection
    _getIntersectionLaneChangeCurve() {
        try {
            // When turning at an intersection, we need to create a curve that simulates
            // the car's path through the intersection from one road to another
            // Get the end point of current lane and start point of next lane
            const p1 = this.current.lane.getPoint(1.0); // End of current lane
            const p2 = this.next.lane.getPoint(0.0); // Start of next lane
            if (!p1 || !p2) {
                throw new Error('Invalid points for intersection curve creation');
            }
            // Get the intersection center for better curve calculation
            const intersection = this.nextIntersection;
            const center = intersection.rect.center();
            // Calculate control points based on the turn type
            const sourceLane = this.current.lane;
            const targetLane = this.next.lane;
            const turnNumber = sourceLane.getTurnDirection(targetLane);
            // Calculate control points based on the turn type
            let control1, control2;
            switch (turnNumber) {
                case 0: // Left turn
                    // For left turns, we want a wider curve
                    control1 = center.add(p1.subtract(center).rotate(-Math.PI / 4).mult(0.5));
                    control2 = center.add(p2.subtract(center).rotate(Math.PI / 4).mult(0.5));
                    break;
                case 2: // Right turn
                    // For right turns, we want a tighter curve
                    control1 = p1.add(p2.subtract(p1).mult(0.25));
                    control2 = p1.add(p2.subtract(p1).mult(0.75));
                    break;
                case 1: // Straight
                default:
                    // For going straight, use simpler control points
                    control1 = p1.add(center.subtract(p1).mult(0.5));
                    control2 = p2.add(center.subtract(p2).mult(0.5));
                    break;
            }
            return new Curve(p1, p2, control1, control2);
        }
        catch (error) {
            console.error('🚗 [TRAJ ERROR] Error creating intersection curve:', error);
            // Fallback to using adjacent lane change curve if this fails
            return this._getAdjacentLaneChangeCurve();
        }
    }
    // Create a curve for changing to an adjacent lane
    _getAdjacentLaneChangeCurve() {
        try {
            // Get points for current and next positions
            const p1 = this.current.lane.getPoint(this.current.relativePosition);
            const p2 = this.next.lane.getPoint(this.next.relativePosition);
            if (!p1 || !p2) {
                throw new Error('Invalid points for curve creation');
            }
            const distance = p2.subtract(p1).length;
            // Create a smoother curve for lane change by adjusting control points
            let controlPointFactor = 0.3; // Default control point factor
            // If high speed, make the curve more gradual
            if (this.car.speed > 15) {
                controlPointFactor = 0.4; // More gradual curve at higher speeds
            }
            // Create control points for smooth Bezier curve
            const direction1 = this.current.lane.middleLine.vector.normalized.mult(distance * controlPointFactor);
            const control1 = p1.add(direction1);
            const direction2 = this.next.lane.middleLine.vector.normalized.mult(distance * controlPointFactor);
            const control2 = p2.subtract(direction2);
            return new Curve(p1, p2, control1, control2);
        }
        catch (error) {
            console.error('🚗 [TRAJ ERROR] Error creating adjacent lane curve:', error);
            // Emergency fallback - straight line between points
            const p1 = this.current.lane.getPoint(this.current.relativePosition);
            const p2 = this.next.lane.getPoint(this.next.relativePosition);
            // Simple linear control points if proper curve fails
            return new Curve(p1, p2, p1, p2);
        }
    }
    // Get the appropriate curve based on the lane change type
    _getCurve() {
        return this.current.lane.road === this.next.lane.road
            ? this._getAdjacentLaneChangeCurve()
            : this._getIntersectionLaneChangeCurve();
    }
    // Start the lane changing process
    _startChangingLanes(nextLane, nextPosition) {
        if (this.isChangingLanes) {
            throw new Error('already changing lane');
        }
        if (!nextLane) {
            throw new Error('no next lane');
        }
        this.isChangingLanes = true;
        this.next.lane = nextLane;
        this.next.position = nextPosition;
        const curve = this._getCurve();
        this.temp.lane = curve;
        this.temp.position = 0; // this.current.lane.length - this.current.position
        this.next.position -= this.temp.lane.length;
    }
    // Complete the lane changing process
    _finishChangingLanes() {
        if (!this.isChangingLanes) {
            throw new Error('no lane changing is going on');
        }
        this.isChangingLanes = false;
        this.current.lane = this.next.lane;
        this.current.position = this.next.position || 0;
        this.current.acquire();
        this.next.lane = null;
        this.next.position = NaN;
        this.temp.lane = null;
        this.temp.position = NaN;
        return this.current.lane;
    }
    // Release all lane positions
    release() {
        if (this.current) {
            this.current.release();
        }
        if (this.next) {
            this.next.release();
        }
        if (this.temp) {
            this.temp.release();
        }
    }
}
// Set up properties using the CoffeeScript-style property decorator
Trajectory.property('lane', {
    get: function () {
        return this.temp.lane || this.current.lane;
    }
});
Trajectory.property('absolutePosition', {
    get: function () {
        return this.temp.lane ? this.temp.position : this.current.position;
    }
});
Trajectory.property('relativePosition', {
    get: function () {
        return this.absolutePosition / this.lane.length;
    }
});
Trajectory.property('direction', {
    get: function () {
        return this.lane.getDirection(this.relativePosition);
    }
});
Trajectory.property('coords', {
    get: function () {
        return this.lane.getPoint(this.relativePosition);
    }
});
Trajectory.property('nextCarDistance', {
    get: function () {
        const a = this.current.nextCarDistance;
        const b = this.next.nextCarDistance;
        return a.distance < b.distance ? a : b;
    }
});
Trajectory.property('distanceToStopLine', {
    get: function () {
        if (!this.canEnterIntersection()) {
            return this.getDistanceToIntersection();
        }
        return Infinity;
    }
});
Trajectory.property('nextIntersection', {
    get: function () {
        return this.current.lane.road.target;
    }
});
Trajectory.property('previousIntersection', {
    get: function () {
        return this.current.lane.road.source;
    }
});
module.exports = Trajectory;


/***/ }),

/***/ "./src/model/world.ts":
/*!****************************!*\
  !*** ./src/model/world.ts ***!
  \****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! ../helpers */ "./src/helpers.ts");
const _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/modules/index-all.js");
const Car = __webpack_require__(/*! ./car */ "./src/model/car.ts");
const Intersection = __webpack_require__(/*! ./intersection */ "./src/model/intersection.ts");
const Road = __webpack_require__(/*! ./road */ "./src/model/road.ts");
const Pool = __webpack_require__(/*! ./pool */ "./src/model/pool.ts");
const Rect = __webpack_require__(/*! ../geom/rect */ "./src/geom/rect.ts");
const settings = __webpack_require__(/*! ../settings */ "./src/settings.ts");
const kpi_collector_1 = __webpack_require__(/*! ./kpi-collector */ "./src/model/kpi-collector.ts");
const TrafficControlStrategyManager_1 = __webpack_require__(/*! ./traffic-control/TrafficControlStrategyManager */ "./src/model/traffic-control/TrafficControlStrategyManager.ts");
const { random } = Math;
/**
 * Represents a complete traffic simulation world
 */
class World {
    constructor() {
        // Main update function called every frame (directly from reference)
        // Main simulation tick method - exactly from reference implementation
        this.onTick = (delta) => {
            // Safety check - cap delta to 1.0 to prevent simulation issues (directly from reference)
            if (delta > 1) {
                throw new Error('delta > 1');
            }
            // Update simulation time
            this.time += delta;
            // Update static world time in Car class for KPI reporting
            Car.updateWorldTime(this.time);
            // Refresh cars to match the target count (exactly one addition/removal per tick)
            this.refreshCars();
            // Update all intersection traffic signals
            for (const id in this.intersections.all()) {
                const intersection = this.intersections.all()[id];
                if (intersection) {
                    // Use the new method to handle both new and legacy traffic control
                    intersection.onTick(delta);
                }
            }
            // Update all cars (movement, decision making) and remove dead cars
            for (const id in this.cars.all()) {
                const car = this.cars.all()[id];
                if (car) {
                    car.move(delta);
                    // Remove car if it's no longer alive
                    if (!car.alive) {
                        this.removeCar(car);
                    }
                }
            }
            // Sample car speeds for KPI collection
            kpi_collector_1.kpiCollector.sampleSpeeds(this.cars.all(), this.time);
            // Periodically sample lane states for KPI collection (every ~1 simulation second)
            if (Math.floor(this.time) > Math.floor(this.time - delta)) {
                this.sampleLaneStates();
            }
        };
        this.customSettings = {};
        this.set({});
    }
    // Calculate the average speed of all cars
    get instantSpeed() {
        if (!this.cars)
            return 0;
        const carsArray = Object.values(this.cars.all() || {});
        const speeds = _.map(carsArray, (car) => car.speed);
        if (speeds.length === 0) {
            return 0;
        }
        return _.reduce(speeds, (a, b) => a + b, 0) / speeds.length;
    }
    // Initialize the world with provided data or as empty
    set(obj) {
        obj = obj || {};
        this.intersections = new Pool(Intersection, obj.intersections);
        this.roads = new Pool(Road, obj.roads);
        this.cars = new Pool(Car, obj.cars);
        this.carsNumber = 0;
        this.time = 0;
        this.activeTrafficControlStrategy = obj.activeTrafficControlStrategy || 'fixed-timing';
        this.customSettings = obj.customSettings || {};
    }
    // Save current world state to localStorage (excluding cars)
    save() {
        const data = _.extend({}, this);
        delete data.cars;
        localStorage.world = JSON.stringify(data);
    }
    // Load world from provided data or localStorage
    load(data) {
        data = data || localStorage.world;
        const parsedData = data && JSON.parse(data);
        if (!parsedData) {
            return;
        }
        this.clear();
        this.carsNumber = parsedData.carsNumber || 0;
        this.activeTrafficControlStrategy = parsedData.activeTrafficControlStrategy || 'fixed-timing';
        this.customSettings = parsedData.customSettings || {};
        // Load intersections
        for (const id in parsedData.intersections) {
            const intersection = parsedData.intersections[id];
            this.addIntersection(Intersection.copy(intersection));
        }
        // Load roads and connect them to intersections
        for (const id in parsedData.roads) {
            const road = parsedData.roads[id];
            const roadCopy = Road.copy(road);
            roadCopy.source = this.getIntersection(road.source);
            roadCopy.target = this.getIntersection(road.target);
            this.addRoad(roadCopy);
        }
        // Apply traffic control strategy if specified
        if (this.activeTrafficControlStrategy) {
            this.applyTrafficControlStrategy(this.activeTrafficControlStrategy);
        }
    }
    // Save as a complete scenario for reproducible benchmarks
    saveAsScenario() {
        const scenarioData = {
            // Base world state (without cars)
            worldState: {
                intersections: this.intersections,
                roads: this.roads,
                carsNumber: this.carsNumber,
                activeTrafficControlStrategy: this.activeTrafficControlStrategy,
                customSettings: this.customSettings
            },
            // Additional simulation parameters
            simulationParams: {
                timeFactor: settings.defaultTimeFactor
            },
            // Traffic control configuration
            trafficControlParams: TrafficControlStrategyManager_1.trafficControlStrategyManager.getStrategySettings(this.activeTrafficControlStrategy),
            // Random seed for reproducibility (not implemented yet, but placeholder)
            randomSeed: null,
            // Metadata
            timestamp: new Date().toISOString(),
            version: '1.0.0'
        };
        return scenarioData;
    }
    // Load a complete scenario
    loadScenario(scenarioData) {
        console.log('World.loadScenario called with data:', scenarioData);
        // Check if we have valid scenario data
        if (!scenarioData) {
            console.error('Scenario data is null or undefined');
            throw new Error('Invalid scenario data: null or undefined');
        }
        // Handle different data formats - direct world state vs. wrapped scenario data
        let worldState;
        if (scenarioData.worldState) {
            console.log('Using wrapped scenario data format');
            worldState = scenarioData.worldState;
            // Update simulation parameters if available
            if (scenarioData.simulationParams) {
                console.log('Applying simulation parameters:', scenarioData.simulationParams);
                settings.defaultTimeFactor = scenarioData.simulationParams.timeFactor || settings.defaultTimeFactor;
            }
            // Apply traffic control parameters if available
            if (scenarioData.trafficControlParams) {
                console.log('Traffic control parameters will be applied after world setup');
            }
        }
        else {
            console.log('Using direct world state format - legacy or simplified scenario');
            worldState = scenarioData;
        }
        // Validate world state
        if (!worldState.intersections || !worldState.roads) {
            console.error('Invalid world state data - missing required properties', worldState);
            throw new Error('Invalid scenario data: missing required properties');
        }
        // Clear current state
        console.log('Clearing current world state');
        this.clear();
        // Load world state
        console.log('Loading world state:', worldState);
        this.carsNumber = worldState.carsNumber || 0;
        this.activeTrafficControlStrategy = worldState.activeTrafficControlStrategy || 'fixed-timing';
        this.customSettings = worldState.customSettings || {};
        // Load intersections
        console.log('Loading intersections...');
        for (const id in worldState.intersections) {
            console.log(`Loading intersection: ${id}`);
            const intersection = worldState.intersections[id];
            try {
                this.addIntersection(Intersection.copy(intersection));
            }
            catch (error) {
                console.error(`Failed to load intersection ${id}:`, error);
                throw new Error(`Failed to load intersection ${id}: ${error.message}`);
            }
        }
        console.log('All intersections loaded successfully');
        // Load roads and connect them to intersections
        console.log('Loading roads...');
        for (const id in worldState.roads) {
            console.log(`Loading road: ${id}`);
            try {
                const road = worldState.roads[id];
                const roadCopy = Road.copy(road);
                // Get source and target intersections
                const sourceIntersection = this.getIntersection(road.source);
                const targetIntersection = this.getIntersection(road.target);
                if (!sourceIntersection) {
                    throw new Error(`Source intersection ${road.source} not found`);
                }
                if (!targetIntersection) {
                    throw new Error(`Target intersection ${road.target} not found`);
                }
                roadCopy.source = sourceIntersection;
                roadCopy.target = targetIntersection;
                this.addRoad(roadCopy);
            }
            catch (error) {
                console.error(`Failed to load road ${id}:`, error);
                throw new Error(`Failed to load road ${id}: ${error.message}`);
            }
        }
        console.log('All roads loaded successfully');
        // Apply traffic control configuration
        console.log('Applying traffic control settings...');
        try {
            // Apply traffic control strategy
            console.log(`Applying traffic control strategy: ${this.activeTrafficControlStrategy}`);
            this.applyTrafficControlStrategy(this.activeTrafficControlStrategy);
            // Apply traffic control parameters if available (only for wrapped scenario format)
            if (scenarioData.trafficControlParams) {
                console.log('Applying traffic control parameters:', scenarioData.trafficControlParams);
                TrafficControlStrategyManager_1.trafficControlStrategyManager.applyStrategySettings(this.activeTrafficControlStrategy, scenarioData.trafficControlParams);
            }
            console.log('Traffic control strategy applied successfully');
        }
        catch (error) {
            console.error('Error applying traffic control strategy:', error);
            // Continue anyway - don't throw, this is not critical
        }
    }
    // Apply a traffic control strategy to all intersections
    applyTrafficControlStrategy(strategyName) {
        var _a;
        if (!strategyName)
            return;
        // Store the active strategy
        this.activeTrafficControlStrategy = strategyName;
        // Update all intersections
        for (const id in this.intersections.all()) {
            const intersection = this.intersections.all()[id];
            if (intersection && intersection.setTrafficControlStrategy) {
                // We need to pass the strategy name as a string
                if (strategyName === null || strategyName === undefined) {
                    // Handle null or undefined case
                    intersection.setTrafficControlStrategy('DefaultStrategy');
                }
                else if (typeof strategyName === 'object') {
                    console.error('Expected strategy name string but received an object', strategyName);
                    // Try to get the strategy name if possible, using non-null assertion since we know it's an object here
                    const strategyNameStr = ((_a = strategyName.constructor) === null || _a === void 0 ? void 0 : _a.name) || 'UnknownStrategy';
                    intersection.setTrafficControlStrategy(strategyNameStr);
                }
                else {
                    // Pass the strategy name as is (should be string at this point)
                    intersection.setTrafficControlStrategy(strategyName);
                }
            }
        }
    }
    // Clear all entities from the world
    clear() {
        // First explicitly clear each pool to ensure complete cleanup
        if (this.intersections && typeof this.intersections.clear === 'function') {
            this.intersections.clear();
        }
        if (this.roads && typeof this.roads.clear === 'function') {
            this.roads.clear();
        }
        if (this.cars && typeof this.cars.clear === 'function') {
            this.cars.clear();
        }
        // Reset car count
        this.carsNumber = 0;
        // Then do a full reset with set({})
        this.set({});
    }
    // Sample all lane states for KPI collection
    sampleLaneStates() {
        // Sample each lane's state
        for (const roadId in this.roads.all()) {
            const road = this.roads.all()[roadId];
            if (road && road.lanes) {
                for (const lane of road.lanes) {
                    kpi_collector_1.kpiCollector.sampleLaneState(lane, this.time);
                }
            }
        }
    }
    // Add or remove ONE car per tick to match target count (exactly from reference)
    refreshCars() {
        if (Object.keys(this.cars.all()).length < this.carsNumber) {
            this.addRandomCar();
        }
        if (Object.keys(this.cars.all()).length > this.carsNumber) {
            this.removeRandomCar();
        }
    }
    // Add a road to the world and update its connections
    addRoad(road) {
        this.roads.put(road);
        road.source.roads.push(road);
        road.target.inRoads.push(road);
        road.update();
    }
    // Get a road by ID
    getRoad(id) {
        return this.roads.get(id);
    }
    // Add a car to the world
    addCar(car) {
        this.cars.put(car);
    }
    // Get a car by ID
    getCar(id) {
        return this.cars.get(id);
    }
    // Remove a car from the world
    removeCar(car) {
        car.release();
        this.cars.pop(car);
    }
    // Add an intersection to the world
    addIntersection(intersection) {
        this.intersections.put(intersection);
    }
    // Get an intersection by ID
    getIntersection(id) {
        return this.intersections.get(id);
    }
    // Add a car at a random position on a random road (exactly from reference)
    addRandomCar() {
        const road = _.sample(Object.values(this.roads.all() || {}));
        if (road && road.lanes && road.lanes.length > 0) {
            const lane = _.sample(road.lanes);
            if (lane) {
                this.addCar(new Car(lane, 0));
            }
        }
    }
    // Remove a random car from the world (exactly from reference)
    removeRandomCar() {
        const car = _.sample(Object.values(this.cars.all() || {}));
        if (car) {
            this.removeCar(car);
        }
    }
    // Generate a new map with grid-based intersections and connecting roads (exactly from reference)
    generateMap(minX = -2, maxX = 2, minY = -2, maxY = 2) {
        this.clear();
        const intersectionsNumber = Math.floor(0.8 * (maxX - minX + 1) * (maxY - minY + 1));
        const map = {};
        const gridSize = settings.gridSize;
        const step = 5 * gridSize;
        this.carsNumber = 100;
        // Create intersections
        let remaining = intersectionsNumber;
        while (remaining > 0) {
            const x = _.random(minX, maxX);
            const y = _.random(minY, maxY);
            if (!map[`${x},${y}`]) {
                const rect = new Rect(step * x, step * y, gridSize, gridSize);
                const intersection = new Intersection(rect);
                this.addIntersection(intersection);
                map[`${x},${y}`] = intersection;
                remaining--;
            }
        }
        // Connect intersections horizontally
        for (let x = minX; x <= maxX; x++) {
            let previous = null;
            for (let y = minY; y <= maxY; y++) {
                const intersection = map[`${x},${y}`];
                if (intersection) {
                    if (previous && random() < 0.9) {
                        this.addRoad(new Road(intersection, previous));
                        this.addRoad(new Road(previous, intersection));
                    }
                    previous = intersection;
                }
            }
        }
        // Connect intersections vertically
        for (let y = minY; y <= maxY; y++) {
            let previous = null;
            for (let x = minX; x <= maxX; x++) {
                const intersection = map[`${x},${y}`];
                if (intersection) {
                    if (previous && random() < 0.9) {
                        this.addRoad(new Road(intersection, previous));
                        this.addRoad(new Road(previous, intersection));
                    }
                    previous = intersection;
                }
            }
        }
    }
    // Get KPI metrics for the current simulation state
    getKPIMetrics() {
        return kpi_collector_1.kpiCollector.getMetrics(this.time);
    }
    // Export KPI metrics as CSV
    exportKPIMetricsCSV() {
        return kpi_collector_1.kpiCollector.exportMetricsCSV();
    }
    // Validate KPI metrics and return HTML report
    validateKPIMetrics() {
        return kpi_collector_1.kpiCollector.validateMetrics();
    }
}
module.exports = World;


/***/ }),

/***/ "./src/pages/BuilderPageComponent.ts":
/*!*******************************************!*\
  !*** ./src/pages/BuilderPageComponent.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BuilderPageComponent = void 0;
const AppState_1 = __webpack_require__(/*! ../core/AppState */ "./src/core/AppState.ts");
const World = __webpack_require__(/*! ../model/world */ "./src/model/world.ts");
const Visualizer = __webpack_require__(/*! ../visualizer/visualizer */ "./src/visualizer/visualizer.ts");
/**
 * Builder page for creating and editing road networks
 */
class BuilderPageComponent {
    constructor(container) {
        this.layouts = [];
        this.container = container;
        this.init();
    }
    async init() {
        await this.loadLayouts();
        this.render();
        // Add event listeners with longer delay and better error handling
        setTimeout(() => {
            console.log('🔗 Builder: Setting up event listeners...');
            this.addEventListeners();
        }, 500);
        await this.initializeWorld();
        // Check if there's a selected layout to load (from home page)
        if (AppState_1.appState.selectedLayoutId) {
            const layoutId = AppState_1.appState.selectedLayoutId;
            // Clear the selected layout so it doesn't reload on next navigation
            AppState_1.appState.selectedLayoutId = null;
            // Load the selected layout
            await this.loadLayoutById(layoutId);
        }
    }
    async loadLayouts() {
        try {
            this.layouts = await AppState_1.appState.storage.loadAllLayouts();
        }
        catch (error) {
            console.error('Failed to load layouts:', error);
            this.layouts = [];
        }
    }
    render() {
        this.container.innerHTML = `
      <div class="builder-page">
        <div class="page-header">
          <h2>Road Network Builder</h2>
          <p>Create and edit road networks. Use Shift+Click to create intersections and Shift+Drag to create roads.</p>
        </div>
        
        <div class="builder-content">
          <div class="sidebar">
            <div class="panel">
              <h3>Controls</h3>
              <button id="save-layout" class="btn btn-success btn-block">💾 Save Layout</button>
              <button id="load-layout" class="btn btn-secondary btn-block">📁 Load Layout</button>
              <button id="clear-world" class="btn btn-danger btn-block">🗑️ Clear</button>

            </div>
            
            <div class="panel">
              <h3>Instructions</h3>
              <ul class="instructions">
                <li><strong>Shift + Click:</strong> Create intersection</li>
                <li><strong>Shift + Drag:</strong> Create road between intersections</li>
                <li><strong>Mouse Wheel:</strong> Zoom in/out</li>
                <li><strong>Drag:</strong> Pan around the map</li>
                <li><strong>Save Layout:</strong> Store your design</li>
              </ul>
            </div>
          </div>
          
          <div class="visualizer-area">
            <canvas id="builder-canvas"></canvas>
          </div>
        </div>
      </div>
    `;
        // Add event listeners after render
        this.addStyles();
    }
    addEventListeners() {
        console.log('🔗 Builder: addEventListeners called');
        // Check if buttons exist
        const saveBtn = document.getElementById('save-layout');
        const clearBtn = document.getElementById('clear-world');
        const loadBtn = document.getElementById('load-layout');
        console.log('🔗 Builder: Button elements found:', {
            saveBtn: !!saveBtn,
            clearBtn: !!clearBtn,
            loadBtn: !!loadBtn
        });
        // Control buttons with logging
        saveBtn === null || saveBtn === void 0 ? void 0 : saveBtn.addEventListener('click', () => {
            console.log('🔗 Builder: Save layout clicked');
            this.showSaveDialog();
        });
        loadBtn === null || loadBtn === void 0 ? void 0 : loadBtn.addEventListener('click', () => {
            console.log('🔗 Builder: Load layout clicked');
            this.showLoadDialog();
        });
        clearBtn === null || clearBtn === void 0 ? void 0 : clearBtn.addEventListener('click', () => {
            console.log('🔗 Builder: Clear world clicked');
            this.clearWorld();
        });
    }
    async initializeWorld() {
        var _a, _b;
        console.log('🌍 Initializing world for builder...');
        try {
            this.world = new World();
            // Start with completely empty world for builder
            this.world.clear();
            this.world.carsNumber = 0;
            console.log('🌍 World initialized with:', {
                intersections: Object.keys(((_a = this.world.intersections) === null || _a === void 0 ? void 0 : _a.all()) || {}).length,
                roads: Object.keys(((_b = this.world.roads) === null || _b === void 0 ? void 0 : _b.all()) || {}).length,
                cars: this.world.carsNumber
            });
            // Initialize visualizer with delay to ensure DOM is ready
            setTimeout(() => this.initializeVisualizer(), 300);
            console.log('✅ World initialized successfully');
        }
        catch (error) {
            console.error('🚨 Failed to initialize world:', error);
        }
    }
    destroyVisualizer() {
        console.log('🎨 [DEBUG] Destroying visualizer...');
        try {
            if (this.visualizer) {
                // Stop any running animation
                if (this.visualizer.running) {
                    this.visualizer.running = false;
                }
                // Call the visualizer's destroy method to clean up resources
                if (typeof this.visualizer.destroy === 'function') {
                    this.visualizer.destroy();
                }
                // Clear visualizer reference
                this.visualizer = null;
                console.log('🎨 [DEBUG] Visualizer destroyed successfully');
            }
            else {
                console.log('🎨 [DEBUG] No visualizer to destroy');
            }
        }
        catch (error) {
            console.error('🎨 [ERROR] Error destroying visualizer:', error);
        }
    }
    initializeVisualizer() {
        if (!this.world) {
            console.error('🎨 [ERROR] Cannot initialize visualizer without world');
            return;
        }
        console.log('🎨 [DEBUG] Initializing new visualizer...');
        try {
            // Create new visualizer with the world
            this.visualizer = new Visualizer(this.world, 'builder-canvas');
            // Set builder mode
            this.visualizer.isBuilderMode = true;
            // Ensure zooming is at a reasonable level
            if (this.visualizer.zoomer) {
                this.visualizer.zoomer.defaultZoom = 4;
            }
            console.log('🎨 [DEBUG] Visualizer initialized successfully');
            // Do a single draw to show the initial state
            this.visualizer.forceRefresh();
        }
        catch (error) {
            console.error('🎨 [ERROR] Failed to initialize visualizer:', error);
        }
    }
    addResizeHandler() {
        const resizeCanvas = () => {
            const canvas = document.getElementById('canvas');
            const visualizerArea = canvas === null || canvas === void 0 ? void 0 : canvas.parentElement;
            if (canvas && visualizerArea) {
                const rect = visualizerArea.getBoundingClientRect();
                const targetWidth = Math.max(rect.width || 800, 400);
                const targetHeight = Math.max(rect.height || 600, 300);
                canvas.width = targetWidth;
                canvas.height = targetHeight;
                console.log('🎨 Builder: Canvas resized to:', targetWidth, 'x', targetHeight);
                // Redraw after resize
                if (this.visualizer) {
                    setTimeout(() => {
                        if (this.visualizer.drawSingleFrame) {
                            this.visualizer.drawSingleFrame();
                        }
                    }, 100);
                }
            }
        };
        // Debounced resize handler
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(resizeCanvas, 150);
        });
    }
    async saveLayout(layoutName) {
        var _a, _b;
        if (!this.world)
            return;
        try {
            const worldData = {
                intersections: ((_a = this.world.intersections) === null || _a === void 0 ? void 0 : _a.all()) || {},
                roads: ((_b = this.world.roads) === null || _b === void 0 ? void 0 : _b.all()) || {},
                carsNumber: this.world.carsNumber || 0,
                time: this.world.time || 0
            };
            console.log('💾 Saving world data:', worldData);
            // Pass the world data and layout name
            await AppState_1.appState.storage.saveLayout(worldData, layoutName);
            this.showNotification('Layout saved successfully!');
            await this.loadLayouts();
            this.render(); // Re-render to update layout list
            this.initializeVisualizer(); // Re-initialize after render
        }
        catch (error) {
            console.error('Failed to save layout:', error);
            this.showNotification('Failed to save layout!', 'error');
        }
    }
    async loadLayout() {
        if (!this.world)
            return;
        try {
            const data = await AppState_1.appState.storage.loadLayout();
            if (data) {
                this.world.load(JSON.stringify(data));
                this.showNotification('Layout loaded successfully!');
            }
        }
        catch (error) {
            console.error('Failed to load layout:', error);
            this.showNotification('Failed to load layout!', 'error');
        }
    }
    async loadSelectedLayout() {
        const select = document.getElementById('layout-select');
        const layoutId = select === null || select === void 0 ? void 0 : select.value;
        if (layoutId) {
            await this.loadLayoutById(layoutId);
        }
    }
    async loadLayoutById(layoutId) {
        var _a, _b, _c, _d;
        console.log('🔄 [DEBUG] Starting loadLayoutById for ID:', layoutId);
        const layout = this.layouts.find(l => l.id === layoutId);
        if (layout && this.world) {
            try {
                console.log('🔄 [DEBUG] Layout found:', layout.name);
                console.log('🔄 [DEBUG] Layout data:', layout.data);
                console.log('🔄 [DEBUG] World exists:', !!this.world);
                console.log('🔄 [DEBUG] Visualizer exists:', !!this.visualizer);
                // Validate layout data structure
                if (!layout.data || typeof layout.data !== 'object') {
                    throw new Error('Invalid layout data structure');
                }
                // Check what the world looks like before loading
                console.log('🔄 [DEBUG] World before loading:', {
                    intersections: Object.keys(((_a = this.world.intersections) === null || _a === void 0 ? void 0 : _a.all()) || {}).length,
                    roads: Object.keys(((_b = this.world.roads) === null || _b === void 0 ? void 0 : _b.all()) || {}).length
                });
                // Load the layout data
                console.log('🔄 [DEBUG] Calling world.load()...');
                this.world.load(JSON.stringify(layout.data));
                console.log('🔄 [DEBUG] World.load() completed');
                // Check what the world looks like after loading
                console.log('🔄 [DEBUG] World after loading:', {
                    intersections: Object.keys(((_c = this.world.intersections) === null || _c === void 0 ? void 0 : _c.all()) || {}).length,
                    roads: Object.keys(((_d = this.world.roads) === null || _d === void 0 ? void 0 : _d.all()) || {}).length
                });
                // Ensure builder mode - no cars
                console.log('🔄 [DEBUG] Setting builder mode - clearing cars...');
                this.world.carsNumber = 0;
                if (this.world.cars && this.world.cars.clear) {
                    this.world.cars.clear();
                }
                console.log('🔄 [DEBUG] Cars cleared');
                // Complete visualizer reset: destroy and recreate
                console.log('🔄 [DEBUG] Performing complete visualizer reset...');
                // First destroy any existing visualizer
                this.destroyVisualizer();
                // Then create a fresh visualizer instance
                console.log('🔄 [DEBUG] Initializing new visualizer after layout load...');
                this.initializeVisualizer();
                console.log('🔄 [DEBUG] Visualizer reset completed successfully');
                console.log('🔄 [DEBUG] loadLayoutById completed successfully');
                this.showNotification(`Layout "${layout.name}" loaded successfully!`);
            }
            catch (error) {
                console.error('🔄 [ERROR] Failed to load layout:', error);
                console.error('🔄 [ERROR] Stack trace:', error.stack);
                this.showNotification('Failed to load layout: ' + error.message, 'error');
            }
        }
        else {
            console.error('🔄 [ERROR] Layout not found or world not initialized');
            console.error('🔄 [ERROR] Layout exists:', !!layout);
            console.error('🔄 [ERROR] World exists:', !!this.world);
            this.showNotification('Layout not found!', 'error');
        }
    }
    async deleteSelectedLayout() {
        const select = document.getElementById('layout-select');
        const layoutId = select === null || select === void 0 ? void 0 : select.value;
        if (layoutId) {
            await this.deleteLayoutById(layoutId);
        }
    }
    async deleteLayoutById(layoutId) {
        if (confirm('Are you sure you want to delete this layout?')) {
            try {
                const remainingLayouts = this.layouts.filter(l => l.id !== layoutId);
                localStorage.setItem('traffic_simulator_layouts', JSON.stringify(remainingLayouts));
                await this.loadLayouts();
                this.render();
                this.initializeVisualizer();
                this.showNotification('Layout deleted successfully!');
            }
            catch (error) {
                console.error('Failed to delete layout:', error);
                this.showNotification('Failed to delete layout!', 'error');
            }
        }
    }
    clearWorld() {
        var _a;
        if (!this.world)
            return;
        console.log('🧹 [DEBUG] Starting clearWorld operation...');
        console.log('🧹 [DEBUG] World exists:', !!this.world);
        console.log('🧹 [DEBUG] Visualizer exists:', !!this.visualizer);
        console.log('🧹 [DEBUG] Visualizer running:', (_a = this.visualizer) === null || _a === void 0 ? void 0 : _a.running);
        try {
            // Stop visualizer first to prevent animation issues
            if (this.visualizer && this.visualizer.running) {
                console.log('🧹 [DEBUG] Stopping visualizer...');
                this.visualizer.running = false;
            }
            // Use clear method instead of set({}) to properly reset
            console.log('🧹 [DEBUG] Calling world.clear()...');
            this.world.clear();
            this.world.carsNumber = 0;
            console.log('🧹 [DEBUG] World cleared successfully');
            // Re-initialize visualizer
            if (this.visualizer) {
                console.log('🧹 [DEBUG] Reinitializing visualizer...');
                // Ensure we're in builder mode
                this.visualizer.isBuilderMode = true;
                // Clean approach: recreate the visualizer for a fresh state
                this.destroyVisualizer();
                this.initializeVisualizer();
                console.log('🧹 [DEBUG] Visualizer reinitialized successfully');
            }
            else {
                console.log('🧹 [DEBUG] No visualizer to manage');
                // Create a new visualizer if needed
                this.initializeVisualizer();
            }
            console.log('🧹 [DEBUG] clearWorld operation completed');
            this.showNotification('World cleared successfully!');
        }
        catch (error) {
            console.error('🧹 [ERROR] Failed to clear world:', error);
            console.error('🧹 [ERROR] Stack trace:', error.stack);
            this.showNotification('Failed to clear world!', 'error');
            // Recovery attempt
            console.log('🧹 [DEBUG] Attempting recovery...');
            this.destroyVisualizer();
            this.initializeVisualizer();
        }
    }
    showNotification(message, type = 'success') {
        const notification = document.createElement('div');
        notification.textContent = message;
        notification.className = `notification ${type}`;
        notification.style.cssText = `
      position: fixed;
      top: 80px;
      right: 20px;
      background: ${type === 'success' ? '#d4edda' : '#f8d7da'};
      color: ${type === 'success' ? '#155724' : '#721c24'};
      padding: 12px 20px;
      border-radius: 4px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      z-index: 1001;
      border: 1px solid ${type === 'success' ? '#c3e6cb' : '#f5c6cb'};
    `;
        document.body.appendChild(notification);
        setTimeout(() => notification.remove(), 3000);
    }
    addStyles() {
        if (!document.getElementById('builder-styles')) {
            const style = document.createElement('style');
            style.id = 'builder-styles';
            style.textContent = `
        .builder-page {
          display: flex;
          flex-direction: column;
          height: 100%;
          width: 100%;
          background: #1a1a1a;
          color: #ffffff;
          overflow: hidden;
          position: relative;
        }
        
        .page-header {
          background: #2d2d2d;
          color: #ffffff;
          padding: 20px;
          border-bottom: 1px solid #404040;
          box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }
        
        .page-header h2 {
          margin: 0 0 8px 0;
          color: #ffffff;
          font-weight: 600;
        }
        
        .page-header p {
          margin: 0;
          color: #b0b0b0;
          font-size: 0.95rem;
        }
        
        .builder-content {
          display: flex;
          flex: 1;
          overflow: hidden;
        }
        
        .sidebar {
          width: 300px;
          background: #2d2d2d;
          border-right: 1px solid #404040;
          overflow-y: auto;
          padding: 20px;
        }
        
        .visualizer-area {
          flex: 1;
          position: relative;
          background: #1a1a1a;
          display: flex;
          align-items: stretch;
          justify-content: stretch;
          min-height: 0;
          border: 1px solid #404040;
          overflow: hidden;
        }
        
        .visualizer-area canvas {
          width: 100% !important;
          height: 100% !important;
          background: #1a1a1a !important;
          border: 2px solid #404040 !important;
          display: block !important;
          position: relative !important;
          z-index: 10 !important;
        }
        
        .panel {
          margin-bottom: 20px;
          padding: 16px;
          border: 1px solid #404040;
          border-radius: 8px;
          background: #333333;
        }
        
        .panel h3 {
          margin: 0 0 12px 0;
          font-size: 1.1rem;
          font-weight: 600;
          color: #ffffff;
        }
        
        .btn {
          padding: 8px 16px;
          border: none;
          border-radius: 4px;
          cursor: pointer;
          font-size: 14px;
          font-weight: 500;
          transition: all 0.2s;
          text-align: center;
          display: inline-block;
          text-decoration: none;
        }
        
        .btn-block {
          width: 100%;
          margin-bottom: 8px;
        }
        
        .btn-primary { background-color: #375a7f; color: white; border: 1px solid #375a7f; }
        .btn-primary:hover { background-color: #2e4c6d; }
        .btn-secondary { background-color: #444444; color: white; border: 1px solid #666666; }
        .btn-secondary:hover { background-color: #555555; }
        .btn-success { background-color: #00bc8c; color: white; border: 1px solid #00bc8c; }
        .btn-success:hover { background-color: #00a085; }
        .btn-warning { background-color: #f39c12; color: #212529; border: 1px solid #f39c12; }
        .btn-warning:hover { background-color: #e67e22; }
        .btn-info { background-color: #3498db; color: white; border: 1px solid #3498db; }
        .btn-info:hover { background-color: #2980b9; }
        .btn-danger { background-color: #e74c3c; color: white; border: 1px solid #e74c3c; }
        .btn-danger:hover { background-color: #c0392b; }
        
        .btn-sm { padding: 4px 8px; font-size: 12px; }
        .btn-outline { background: #404040; border: 1px solid #666666; color: #ffffff; }
        .btn-outline:hover { background: #555555; }
        .btn-danger-outline { background: #404040; border: 1px solid #dc3545; color: #dc3545; }
        .btn-danger-outline:hover { background: #dc3545; color: white; }
        
        .form-control {
          width: 100%;
          padding: 8px 12px;
          border: 1px solid #404040;
          border-radius: 4px;
          font-size: 14px;
          margin-bottom: 8px;
          background: #404040;
          color: #ffffff;
        }
        
        .form-control:focus {
          outline: none;
          border-color: #007bff;
          box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
        }
        
        .layout-actions {
          display: flex;
          gap: 8px;
        }
        
        .layout-item {
          display: flex;
          justify-content: space-between;
          align-items: center;
          padding: 8px 12px;
          margin-bottom: 4px;
          background: #404040;
          border: 1px solid #666666;
          border-radius: 4px;
        }
        
        .layout-info strong {
          display: block;
          color: #ffffff;
          font-size: 14px;
        }
        
        .layout-info small {
          color: #b0b0b0;
          font-size: 12px;
        }
        
        .layout-item-actions {
          display: flex;
          gap: 4px;
        }
        
        .no-layouts {
          text-align: center;
          color: #b0b0b0;
          font-style: italic;
          padding: 20px;
        }
        
        .instructions {
          margin: 0;
          padding-left: 16px;
        }
        
        .instructions li {
          margin-bottom: 8px;
          color: #b0b0b0;
          font-size: 14px;
        }
        
        .instructions strong {
          color: #ffffff;
        }
        
        /* Modal Dialogs */
        .modal-overlay {
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(0, 0, 0, 0.7);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 1000;
        }
        
        .modal-dialog {
          background: #2d2d2d;
          border-radius: 8px;
          border: 1px solid #404040;
          max-width: 500px;
          width: 90%;
          max-height: 90vh;
          overflow-y: auto;
          box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }
        
        .modal-large {
          max-width: 800px;
        }
        
        .modal-header {
          padding: 20px;
          border-bottom: 1px solid #404040;
          display: flex;
          justify-content: space-between;
          align-items: center;
        }
        
        .modal-header h3 {
          margin: 0;
          color: #ffffff;
        }
        
        .close-btn {
          background: none;
          border: none;
          color: #ffffff;
          font-size: 24px;
          cursor: pointer;
          padding: 0;
          width: 30px;
          height: 30px;
          display: flex;
          align-items: center;
          justify-content: center;
          border-radius: 4px;
        }
        
        .close-btn:hover {
          background: rgba(255, 255, 255, 0.1);
        }
        
        .modal-body {
          padding: 20px;
        }
        
        .modal-body label {
          display: block;
          margin-bottom: 8px;
          color: #ffffff;
          font-weight: 500;
        }
        
        .modal-body input {
          width: 100%;
          padding: 10px;
          border: 1px solid #404040;
          border-radius: 4px;
          background: #404040;
          color: #ffffff;
          font-size: 14px;
          margin-bottom: 10px;
        }
        
        .modal-body input:focus {
          outline: none;
          border-color: #007bff;
        }
        
        .modal-body small {
          color: #cccccc;
          font-size: 12px;
        }
        
        .modal-footer {
          padding: 20px;
          border-top: 1px solid #404040;
          display: flex;
          justify-content: flex-end;
          gap: 10px;
        }
        
        .layout-grid {
          display: grid;
          grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
          gap: 15px;
          margin-top: 15px;
        }
        
        .layout-card {
          background: rgba(255, 255, 255, 0.05);
          border: 1px solid #404040;
          border-radius: 8px;
          padding: 15px;
          transition: all 0.3s ease;
        }
        
        .layout-card:hover {
          background: rgba(255, 255, 255, 0.1);
          border-color: #007bff;
        }
        
        .layout-card h4 {
          margin: 0 0 8px 0;
          color: #ffffff;
          font-size: 16px;
        }
        
        .layout-card small {
          color: #cccccc;
          font-size: 12px;
        }
        
        .layout-actions {
          margin-top: 15px;
          display: flex;
          gap: 10px;
        }
        
        .layout-actions .btn {
          flex: 1;
          padding: 8px 16px;
          font-size: 14px;
        }
        
        .notification {
          position: fixed;
          top: 80px;
          right: 20px;
          background: #00bc8c;
          color: white;
          padding: 12px 20px;
          border-radius: 4px;
          box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
          z-index: 1001;
          border: 1px solid #009473;
        }
        
        .notification.error {
          background: #e74c3c;
          color: white;
          border: 1px solid #c0392b;
        }
        
        .notification.success {
          background: #00bc8c;
          color: white;
          border: 1px solid #009473;
        }
      `;
            document.head.appendChild(style);
        }
    }
    showSaveDialog() {
        // Create save dialog
        const dialog = document.createElement('div');
        dialog.className = 'modal-overlay';
        dialog.innerHTML = `
      <div class="modal-dialog">
        <div class="modal-header">
          <h3>Save Layout</h3>
          <button class="close-btn" id="close-save-dialog">×</button>
        </div>
        <div class="modal-body">
          <label for="layout-name">Layout Name:</label>
          <input type="text" id="layout-name" placeholder="Enter layout name..." maxlength="50">
          <small>Choose a descriptive name for your road network layout</small>
        </div>
        <div class="modal-footer">
          <button class="btn btn-secondary" id="cancel-save">Cancel</button>
          <button class="btn btn-success" id="confirm-save">Save</button>
        </div>
      </div>
    `;
        document.body.appendChild(dialog);
        // Focus on input
        const nameInput = document.getElementById('layout-name');
        nameInput.focus();
        // Event listeners
        const confirmSave = document.getElementById('confirm-save');
        const cancelSave = document.getElementById('cancel-save');
        const closeSave = document.getElementById('close-save-dialog');
        const closeDialog = () => {
            if (dialog && dialog.parentNode) {
                document.body.removeChild(dialog);
            }
        };
        confirmSave === null || confirmSave === void 0 ? void 0 : confirmSave.addEventListener('click', () => {
            const layoutName = nameInput.value.trim();
            if (!layoutName) {
                alert('Please enter a layout name');
                return;
            }
            this.saveLayout(layoutName);
            closeDialog();
        });
        cancelSave === null || cancelSave === void 0 ? void 0 : cancelSave.addEventListener('click', closeDialog);
        closeSave === null || closeSave === void 0 ? void 0 : closeSave.addEventListener('click', closeDialog);
        // Close on escape
        const escapeHandler = (e) => {
            if (e.key === 'Escape') {
                closeDialog();
                document.removeEventListener('keydown', escapeHandler);
            }
        };
        document.addEventListener('keydown', escapeHandler);
        // Close on backdrop click
        dialog.addEventListener('click', (e) => {
            if (e.target === dialog) {
                closeDialog();
            }
        });
    }
    async showLoadDialog() {
        try {
            // Load all layouts
            const layouts = await AppState_1.appState.storage.loadAllLayouts();
            if (layouts.length === 0) {
                alert('No saved layouts found. Create and save a layout first!');
                return;
            }
            // Create load dialog
            const dialog = document.createElement('div');
            dialog.className = 'modal-overlay';
            dialog.innerHTML = `
        <div class="modal-dialog modal-large">
          <div class="modal-header">
            <h3>Load Layout</h3>
            <button class="close-btn" id="close-load-dialog">×</button>
          </div>
          <div class="modal-body">
            <p>Select a layout to load:</p>
            <div class="layout-grid">
              ${layouts.map(layout => `
                <div class="layout-card" data-layout-id="${layout.id}">
                  <div class="layout-info">
                    <h4>${layout.name}</h4>
                    <small>Created: ${new Date(layout.createdAt).toLocaleString()}</small>
                  </div>
                  <div class="layout-actions">
                    <button class="btn btn-primary load-layout-btn" data-layout-id="${layout.id}">Load</button>
                    <button class="btn btn-danger delete-layout-btn" data-layout-id="${layout.id}">Delete</button>
                  </div>
                </div>
              `).join('')}
            </div>
          </div>
          <div class="modal-footer">
            <button class="btn btn-secondary" id="cancel-load">Cancel</button>
          </div>
        </div>
      `;
            document.body.appendChild(dialog);
            // Event listeners
            const cancelLoad = document.getElementById('cancel-load');
            const closeLoad = document.getElementById('close-load-dialog');
            const closeDialog = () => {
                if (dialog && dialog.parentNode) {
                    document.body.removeChild(dialog);
                }
            };
            // Load layout buttons
            dialog.querySelectorAll('.load-layout-btn').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    const layoutId = e.target.getAttribute('data-layout-id');
                    if (layoutId) {
                        await this.loadLayoutById(layoutId);
                        closeDialog();
                    }
                });
            });
            // Delete layout buttons
            dialog.querySelectorAll('.delete-layout-btn').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    const layoutId = e.target.getAttribute('data-layout-id');
                    if (layoutId && confirm('Are you sure you want to delete this layout?')) {
                        await this.deleteLayoutById(layoutId);
                        // Refresh the dialog
                        closeDialog();
                        this.showLoadDialog();
                    }
                });
            });
            cancelLoad === null || cancelLoad === void 0 ? void 0 : cancelLoad.addEventListener('click', closeDialog);
            closeLoad === null || closeLoad === void 0 ? void 0 : closeLoad.addEventListener('click', closeDialog);
            // Close on escape
            const escapeHandler = (e) => {
                if (e.key === 'Escape') {
                    closeDialog();
                    document.removeEventListener('keydown', escapeHandler);
                }
            };
            document.addEventListener('keydown', escapeHandler);
            // Close on backdrop click
            dialog.addEventListener('click', (e) => {
                if (e.target === dialog) {
                    closeDialog();
                }
            });
        }
        catch (error) {
            console.error('Failed to load layouts:', error);
            alert('Failed to load layouts');
        }
    }
    destroy() {
        console.log('🧹 Builder: Destroying page and cleaning up canvas...');
        if (this.visualizer) {
            if (this.visualizer.destroy) {
                this.visualizer.destroy();
            }
            else {
                this.visualizer.stop();
            }
            this.visualizer = null;
        }
        if (this.world) {
            this.world = null;
        }
        // Remove the canvas element to prevent duplicates
        const canvas = document.getElementById('canvas');
        if (canvas) {
            console.log('🗑️ Builder: Removing canvas element');
            canvas.remove();
        }
        // Clear the container
        if (this.container) {
            this.container.innerHTML = '';
        }
        console.log('✅ Builder: Page destroyed and cleaned up');
    }
    // Public interface methods for app integration
    getContainer() {
        return this.container;
    }
    show() {
        if (this.container) {
            this.container.style.display = 'block';
            // Re-initialize visualizer if needed
            if (this.world && !this.visualizer) {
                this.initializeVisualizer();
            }
        }
    }
    hide() {
        if (this.container) {
            this.container.style.display = 'none';
        }
    }
}
exports.BuilderPageComponent = BuilderPageComponent;


/***/ }),

/***/ "./src/pages/HomePage.ts":
/*!*******************************!*\
  !*** ./src/pages/HomePage.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HomePage = void 0;
const AppState_1 = __webpack_require__(/*! ../core/AppState */ "./src/core/AppState.ts");
/**
 * Home page - landing page for the traffic simulator
 */
class HomePage {
    constructor(container, router) {
        this.recentLayouts = [];
        this.container = container;
        this.router = router;
        this.init();
    }
    async init() {
        console.log('🏠 [HOME] Initializing home page');
        // Ensure container is empty
        if (this.container) {
            this.container.innerHTML = '';
        }
        // Load recent layouts to display on homepage
        try {
            this.recentLayouts = await AppState_1.appState.storage.loadAllLayouts();
            // Sort by last modified date
            this.recentLayouts.sort((a, b) => {
                const dateA = new Date(a.updatedAt || a.createdAt).getTime();
                const dateB = new Date(b.updatedAt || b.createdAt).getTime();
                return dateB - dateA; // Sort descending (newest first)
            });
            // Take only the most recent 3
            this.recentLayouts = this.recentLayouts.slice(0, 3);
            console.log(`🏠 [HOME] Loaded ${this.recentLayouts.length} recent layouts`);
        }
        catch (error) {
            console.error('Failed to load recent layouts:', error);
            this.recentLayouts = [];
        }
        console.log('🏠 [HOME] Rendering home page content');
        this.render();
        // Use setTimeout to ensure DOM is fully rendered before attaching events
        setTimeout(() => {
            console.log('🏠 [HOME] Setting up event listeners');
            this.addEventListeners();
        }, 100);
    }
    addEventListeners() {
        console.log('Adding event listeners to home page buttons');
        // Navigation buttons
        const builderBtn = document.getElementById('go-to-builder');
        if (builderBtn) {
            console.log('Found builder button, attaching click event');
            builderBtn.addEventListener('click', () => {
                console.log('Builder button clicked, navigating...');
                this.router.navigate('/builder');
            });
        }
        else {
            console.warn('Builder button not found in the DOM');
        }
        const simulationBtn = document.getElementById('go-to-simulation');
        if (simulationBtn) {
            console.log('Found simulation button, attaching click event');
            simulationBtn.addEventListener('click', () => {
                console.log('Simulation button clicked, navigating...');
                this.router.navigate('/simulation');
            });
        }
        else {
            console.warn('Simulation button not found in the DOM');
        }
        // Recent layout buttons
        const layoutButtons = document.querySelectorAll('[data-action="load-layout"]');
        console.log(`Found ${layoutButtons.length} layout buttons`);
        layoutButtons.forEach(btn => {
            const layoutId = btn.getAttribute('data-layout-id');
            const target = btn.getAttribute('data-target');
            console.log(`Adding event listener to button for layout ${layoutId} with target ${target}`);
            btn.addEventListener('click', (e) => {
                e.preventDefault(); // Prevent any default behavior
                const clickedBtn = e.currentTarget;
                const layoutId = clickedBtn.getAttribute('data-layout-id');
                const target = clickedBtn.getAttribute('data-target');
                if (layoutId && target) {
                    console.log(`Layout button clicked! Loading layout ${layoutId} and navigating to ${target}`);
                    // Store the layout ID to be loaded
                    AppState_1.appState.selectedLayoutId = layoutId;
                    // Navigate to the appropriate page after a brief delay to allow console log to appear
                    setTimeout(() => {
                        this.router.navigate(`/${target}`);
                    }, 100);
                }
                else {
                    console.error('Missing layout ID or target in clicked button:', clickedBtn);
                }
            });
        });
    }
    render() {
        this.container.innerHTML = `
      <div class="home-page" id="home-page-content">
        <div class="hero-section">
          <div class="hero-content">
            <h1>Road Traffic Simulator</h1>
            <p class="hero-subtitle">Design, build, and simulate traffic flow through custom road networks</p>
            
            <div class="feature-cards">
              <div class="feature-card">
                <div class="feature-icon">🏗️</div>
                <h3>Network Builder</h3>
                <p>Create custom road networks with intersections, lanes, and traffic signals</p>
                <button class="btn btn-primary" id="go-to-builder">
                  Start Building
                </button>
              </div>
              
              <div class="feature-card">
                <div class="feature-icon">🚗</div>
                <h3>Traffic Simulation</h3>
                <p>Run realistic traffic simulations on your custom road networks</p>
                <button class="btn btn-secondary" id="go-to-simulation">
                  View Simulation
                </button>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Recent Layouts Section -->
        <div class="recent-section">
          <div class="section-content">
            <h2>Recent Layouts</h2>
            
            <div class="recent-layouts">
              ${this.recentLayouts.length > 0 ?
            this.recentLayouts.map(layout => `
                  <div class="layout-card">
                    <div class="layout-info">
                      <h4>${layout.name || 'Unnamed Layout'}</h4>
                      <p>Last modified: ${new Date(layout.updatedAt || layout.createdAt).toLocaleString()}</p>
                    </div>
                    <div class="layout-actions">
                      <button class="btn btn-primary btn-sm" data-action="load-layout" data-layout-id="${layout.id}" data-target="builder">
                        🏗️ Edit
                      </button>
                      <button class="btn btn-secondary btn-sm" data-action="load-layout" data-layout-id="${layout.id}" data-target="simulation">
                        🚗 Simulate
                      </button>
                    </div>
                  </div>
                `).join('')
            :
                `<div class="empty-state">
                  <div class="empty-icon">📄</div>
                  <p>No layouts found</p>
                  <small>Head to the Builder to create your first layout!</small>
                </div>`}
            </div>
          </div>
        </div>
        
        <div class="info-section">
          <div class="section-content">
            <h2>How to Use</h2>
            <div class="steps">
              <div class="step">
                <div class="step-number">1</div>
                <div class="step-content">
                  <h4>Design Your Network</h4>
                  <p>Use the Builder to create intersections (Shift+Click) and connect them with roads (Shift+Drag)</p>
                </div>
              </div>
              
              <div class="step">
                <div class="step-number">2</div>
                <div class="step-content">
                  <h4>Save Your Layout</h4>
                  <p>Save your road network designs to load them later or share with others</p>
                </div>
              </div>
              
              <div class="step">
                <div class="step-number">3</div>
                <div class="step-content">
                  <h4>Run Simulations</h4>
                  <p>Switch to Simulation mode to see how traffic flows through your network</p>
                </div>
              </div>
            </div>
          </div>
        </div>
        
        <div class="features-section">
          <div class="section-content">
            <h2>Key Features</h2>
            <div class="features-grid">
              <div class="feature">
                <div class="feature-icon">🔄</div>
                <h4>Real-time Simulation</h4>
                <p>Watch vehicles navigate through your road network in real-time</p>
              </div>
              
              <div class="feature">
                <div class="feature-icon">📊</div>
                <h4>Traffic Analytics</h4>
                <p>Track vehicle counts, speeds, and other traffic metrics</p>
              </div>
              
              <div class="feature">
                <div class="feature-icon">💾</div>
                <h4>Save & Load</h4>
                <p>Store your designs and continue working on them later</p>
              </div>
              
              <div class="feature">
                <div class="feature-icon">🔍</div>
                <h4>Detailed View</h4>
                <p>Zoom and pan to examine any part of your network</p>
              </div>
            </div>
          </div>
        </div>
      </div>
      
      <style>
        .home-page {
          min-height: 100vh;
          background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
          color: #ffffff;
          overflow-y: auto;
          position: relative;
          z-index: 5;
        }
        
        .hero-section {
          padding: 60px 40px;
          text-align: center;
          background: rgba(0, 0, 0, 0.3);
        }
        
        .hero-content h1 {
          font-size: 3.5rem;
          margin-bottom: 20px;
          background: linear-gradient(45deg, #375a7f, #00bc8c);
          -webkit-background-clip: text;
          -webkit-text-fill-color: transparent;
          background-clip: text;
        }
        
        .recent-section, .info-section, .features-section {
          padding: 50px 40px;
        }
        
        .info-section {
          background: rgba(0, 0, 0, 0.2);
        }
        
        .features-section {
          background: rgba(0, 0, 0, 0.3);
        }
        
        .section-content {
          max-width: 1200px;
          margin: 0 auto;
        }
        
        .section-content h2 {
          font-size: 2rem;
          margin-bottom: 30px;
          text-align: center;
          position: relative;
        }
        
        .section-content h2::after {
          content: '';
          display: block;
          width: 60px;
          height: 3px;
          background: linear-gradient(90deg, #375a7f, #00bc8c);
          margin: 15px auto 0;
        }
        
        /* Recent Layouts */
        .recent-layouts {
          display: flex;
          flex-wrap: wrap;
          gap: 20px;
          justify-content: center;
        }
        
        .layout-card {
          width: 300px;
          background: rgba(45, 45, 45, 0.8);
          border-radius: 8px;
          overflow: hidden;
          box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
          border: 1px solid #404040;
          padding: 20px;
          transition: transform 0.3s, box-shadow 0.3s;
        }
        
        .layout-card:hover {
          transform: translateY(-5px);
          box-shadow: 0 8px 15px rgba(0, 0, 0, 0.4);
        }
        
        .layout-info h4 {
          margin: 0 0 10px 0;
          font-size: 1.2rem;
          color: #ffffff;
        }
        
        .layout-info p {
          margin: 0 0 15px 0;
          color: #b0b0b0;
          font-size: 0.9rem;
        }
        
        .layout-actions {
          display: flex;
          gap: 10px;
          margin-top: 15px;
        }
        
        .empty-state {
          text-align: center;
          padding: 40px;
          background: rgba(45, 45, 45, 0.8);
          border-radius: 8px;
          border: 1px dashed #404040;
        }
        
        .empty-icon {
          font-size: 3rem;
          margin-bottom: 20px;
          opacity: 0.6;
        }
        
        /* Features Grid */
        .features-grid {
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
          gap: 30px;
          margin-top: 30px;
        }
        
        .feature {
          background: rgba(45, 45, 45, 0.8);
          border-radius: 8px;
          padding: 25px;
          text-align: center;
          transition: transform 0.3s;
          box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }
        
        .feature:hover {
          transform: translateY(-5px);
        }
        
        .feature-icon {
          font-size: 2.5rem;
          margin-bottom: 20px;
        }
        
        .feature h4 {
          margin: 0 0 15px 0;
          color: #ffffff;
        }
        
        .feature p {
          margin: 0;
          color: #b0b0b0;
        }
        
        /* Media Queries */
        @media (max-width: 768px) {
          .hero-content h1 {
            font-size: 2.5rem;
          }
          
          .feature-cards {
            flex-direction: column;
          }
          
          .feature-card {
            margin-bottom: 20px;
          }
          
          .steps {
            flex-direction: column;
          }
          
          .step {
            margin-bottom: 30px;
          }
          
          .recent-section, .info-section, .features-section {
            padding: 40px 20px;
          }
        }
        
        .hero-subtitle {
          font-size: 1.2rem;
          margin-bottom: 40px;
          color: #cccccc;
          max-width: 600px;
          margin-left: auto;
          margin-right: auto;
        }
        
        .feature-cards {
          display: flex;
          gap: 40px;
          justify-content: center;
          flex-wrap: wrap;
          margin-top: 40px;
        }
        
        .feature-card {
          background: rgba(255, 255, 255, 0.1);
          border: 1px solid rgba(255, 255, 255, 0.2);
          border-radius: 12px;
          padding: 30px;
          max-width: 300px;
          text-align: center;
          transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .feature-card:hover {
          transform: translateY(-5px);
          box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
        
        .feature-icon {
          font-size: 3rem;
          margin-bottom: 20px;
        }
        
        .feature-card h3 {
          margin-bottom: 15px;
          color: #ffffff;
        }
        
        .feature-card p {
          color: #cccccc;
          margin-bottom: 25px;
          line-height: 1.5;
        }
        
        .info-section {
          padding: 60px 40px;
          background: rgba(0, 0, 0, 0.2);
        }
        
        .info-content {
          max-width: 800px;
          margin: 0 auto;
        }
        
        .info-content h2 {
          text-align: center;
          margin-bottom: 40px;
          font-size: 2.5rem;
          color: #ffffff;
        }
        
        .steps {
          display: flex;
          flex-direction: column;
          gap: 30px;
        }
        
        .step {
          display: flex;
          align-items: flex-start;
          gap: 20px;
          padding: 20px;
          background: rgba(255, 255, 255, 0.05);
          border-radius: 8px;
          border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .step-number {
          background: #375a7f;
          color: white;
          width: 40px;
          height: 40px;
          border-radius: 50%;
          display: flex;
          align-items: center;
          justify-content: center;
          font-weight: bold;
          font-size: 1.2rem;
          flex-shrink: 0;
        }
        
        .step-content h4 {
          margin: 0 0 10px 0;
          color: #ffffff;
        }
        
        .step-content p {
          margin: 0;
          color: #cccccc;
          line-height: 1.5;
        }
        
        .btn {
          padding: 12px 24px;
          border: none;
          border-radius: 6px;
          font-size: 1rem;
          cursor: pointer;
          transition: all 0.3s ease;
          text-decoration: none;
          display: inline-block;
          min-width: 150px;
          position: relative;
          z-index: 10;
          pointer-events: auto;
          font-weight: 500;
        }
        
        .btn:active {
          transform: translateY(1px);
          opacity: 0.9;
        }
        
        .btn-primary {
          background: linear-gradient(45deg, #375a7f, #4a6fa5);
          color: white;
        }
        
        .btn-primary:hover {
          background: linear-gradient(45deg, #4a6fa5, #375a7f);
          transform: translateY(-2px);
          box-shadow: 0 5px 15px rgba(55, 90, 127, 0.4);
        }
        
        .btn-secondary {
          background: linear-gradient(45deg, #00bc8c, #00d4aa);
          color: white;
        }
        
        .btn-secondary:hover {
          background: linear-gradient(45deg, #00d4aa, #00bc8c);
          transform: translateY(-2px);
          box-shadow: 0 5px 15px rgba(0, 188, 140, 0.4);
        }
        
        /* Make buttons more clickable */
        .btn-sm {
          padding: 8px 16px;
          font-size: 0.9rem;
          min-width: 100px;
        }
        
        /* Ensure buttons are fully clickable */
        #go-to-builder, #go-to-simulation {
          position: relative;
          z-index: 100;
        }
        
        @media (max-width: 768px) {
          .hero-content h1 {
            font-size: 2.5rem;
          }
          
          .feature-cards {
            flex-direction: column;
            align-items: center;
          }
          
          .hero-section,
          .info-section {
            padding: 40px 20px;
          }
        }
      </style>
    `;
    }
}
exports.HomePage = HomePage;


/***/ }),

/***/ "./src/pages/SimulationPageComponent.ts":
/*!**********************************************!*\
  !*** ./src/pages/SimulationPageComponent.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SimulationPageComponent = void 0;
const AppState_1 = __webpack_require__(/*! ../core/AppState */ "./src/core/AppState.ts");
const World = __webpack_require__(/*! ../model/world */ "./src/model/world.ts");
const Visualizer = __webpack_require__(/*! ../visualizer/visualizer */ "./src/visualizer/visualizer.ts");
const kpi_collector_1 = __webpack_require__(/*! ../model/kpi-collector */ "./src/model/kpi-collector.ts");
const KPIVisualizationComponent_1 = __webpack_require__(/*! ../components/KPIVisualizationComponent */ "./src/components/KPIVisualizationComponent.ts");
/**
 * Simulation page for running traffic simulations
 */
class SimulationPageComponent {
    constructor(container) {
        this.layouts = [];
        this.scenarios = [];
        this.isRunning = false;
        this.analytics = {
            totalCars: 0,
            averageSpeed: 0,
            totalIntersections: 0,
            totalRoads: 0,
            simulationTime: 0
        };
        this.analyticsInterval = null;
        this.selectedTrafficControlModel = 'fixed-timing'; // Default model
        // Benchmark related properties
        this.isBenchmarkRunning = false;
        this.benchmarkDuration = 60; // Default: 60 simulation seconds
        this.benchmarkTimer = null;
        this.benchmarkStartTime = 0;
        this.benchmarkResults = {};
        this.benchmarkIntervalSamples = [];
        this.benchmarkSettings = {};
        this.currentScenario = null;
        // GUI control for settings
        this.gui = null;
        // KPI Visualization Component
        this.kpiVisualization = null;
        // Handle window resize event
        this.handleResize = () => {
            if (this.visualizer) {
                this.visualizer.resize(window.innerWidth, window.innerHeight);
            }
        };
        this.container = container;
        this.init();
    }
    async init() {
        // Apply styles first to prevent theme flicker
        this.addStyles();
        await this.loadLayouts();
        await this.loadScenarios();
        this.render();
        // Add event listeners with a small delay to ensure DOM is fully rendered
        setTimeout(() => this.addEventListeners(), 100);
        await this.initializeSimulation();
        // Check if there's a selected layout to load (from home page)
        if (AppState_1.appState.selectedLayoutId) {
            const layoutId = AppState_1.appState.selectedLayoutId;
            // Clear the selected layout so it doesn't reload on next navigation
            AppState_1.appState.selectedLayoutId = null;
            // Load the selected layout
            await this.loadLayoutById(layoutId);
        }
    }
    async loadLayouts() {
        try {
            this.layouts = await AppState_1.appState.storage.loadAllLayouts();
        }
        catch (error) {
            console.error('Failed to load layouts:', error);
            this.layouts = [];
        }
    }
    async loadScenarios() {
        try {
            this.scenarios = await AppState_1.appState.storage.loadAllScenarios();
        }
        catch (error) {
            console.error('Failed to load scenarios:', error);
            this.scenarios = [];
        }
    }
    render() {
        this.container.innerHTML = `
      <div class="simulation-page">
        <div class="page-header">
          <h2>Traffic Simulation</h2>
          <p>Run and analyze traffic simulations on your road networks.</p>
        </div>
        
        <div class="simulation-content">
          <div class="sidebar">
            <!-- Layout Selection -->
            <div class="panel">
              <h3>Layout Selection</h3>
              <button id="load-layout" class="btn btn-primary btn-block">
                📁 Load Layout
              </button>
              
              <div class="layout-status">
                <small class="text-muted">
                  ${this.layouts.length > 0
            ? `${this.layouts.length} saved layout(s) available`
            : 'No saved layouts found. Create one in the Builder first.'}
                </small>
              </div>
            </div>
            
            <!-- Scenario Management Panel -->
            <div class="panel">
              <h3>Scenario Management</h3>
              
              <div class="control-group">
                <button id="save-scenario" class="btn btn-primary btn-block">
                  💾 Save Current Scenario
                </button>
              </div>
              
              <div class="control-group">
                <button id="load-scenario" class="btn btn-info btn-block">
                  📂 Load Scenario
                </button>
              </div>
              
              <div class="scenario-status">
                <small class="text-muted">
                  ${this.scenarios.length > 0
            ? `${this.scenarios.length} saved scenario(s) available`
            : 'No saved scenarios found.'}
                </small>
                ${this.currentScenario
            ? `<div class="current-scenario-info">Current: ${this.currentScenario.name}</div>`
            : ''}
              </div>
            </div>
            
            <!-- Simulation Controls -->
            <div class="panel">
              <h3>Simulation Controls</h3>
              
              <div class="control-group">
                <button id="toggle-simulation" class="btn btn-success btn-block">
                  ▶️ Start Simulation
                </button>
              </div>
              
              <div class="control-group">
                <button id="reset-simulation" class="btn btn-info btn-block">
                  🔄 Reset Simulation
                </button>
              </div>
              
              <div class="control-group">
                <button id="run-benchmark" class="btn btn-primary btn-block">
                  📊 Run KPI Benchmark
                </button>
              </div>
              
              <div class="control-group">
                <label for="traffic-control-model">Traffic Control Model:</label>
                <div class="model-status">
                  <span class="active-model-indicator" id="active-model-indicator">Fixed Timing</span>
                </div>
                <select id="traffic-control-model" class="form-control">
                  <option value="fixed-timing">Fixed Timing</option>
                  <option value="adaptive-timing">Adaptive Timing</option>
                  <option value="traffic-enforcer">Traffic Enforcer</option>
                  <option value="all-red-flashing">All Red Flashing</option>
                </select>
              </div>
              
              <div class="control-group">
                <label for="cars-range">Number of Cars: <span id="cars-value">100</span></label>
                <input type="range" id="cars-range" min="0" max="200" value="100" class="slider">
              </div>
              
              <div class="control-group">
                <label for="time-factor-range">Time Factor: <span id="time-factor-value">1.0</span>x</label>
                <input type="range" id="time-factor-range" min="0.1" max="5" step="0.1" value="1" class="slider">
              </div>
            </div>
            
            <!-- Analytics Panel -->
            <div class="panel">
              <h3>Analytics</h3>
              <button id="toggle-analytics" class="btn btn-info btn-block">
                Show Analytics
              </button>
              
              <div id="analytics-panel" class="analytics" style="display: none;">
                <div class="analytics-section">
                  <h4>Simulation Stats</h4>
                  
                  <div class="metric">
                    <span class="label">Active Cars:</span>
                    <span class="value" id="active-cars">0</span>
                  </div>
                  
                  <div class="metric">
                    <span class="label">Total Vehicles:</span>
                    <span class="value" id="total-vehicles">0</span>
                  </div>
                  
                  <div class="metric">
                    <span class="label">Completed Trips:</span>
                    <span class="value" id="completed-trips">0</span>
                  </div>
                  
                  <div class="metric">
                    <span class="label">Simulation Time:</span>
                    <span class="value" id="simulation-time">0.0s</span>
                  </div>
                </div>
                
                <div class="analytics-section">
                  <h4>Performance Metrics</h4>
                  
                  <div class="metric">
                    <span class="label">Average Speed:</span>
                    <span class="value" id="average-speed">0.00 m/s</span>
                  </div>
                  
                  <div class="metric">
                    <span class="label">Avg Wait Time:</span>
                    <span class="value" id="avg-wait-time">0.0s</span>
                  </div>
                  
                  <div class="metric">
                    <span class="label">Max Wait Time:</span>
                    <span class="value" id="max-wait-time">0.0s</span>
                  </div>
                  
                  <div class="metric">
                    <span class="label">Total Stops:</span>
                    <span class="value" id="total-stops">0</span>
                  </div>
                  
                  <div class="metric">
                    <span class="label">Stopped Vehicles:</span>
                    <span class="value" id="stopped-vehicles">0</span>
                  </div>
                  
                  <div class="metric">
                    <span class="label">Global Throughput:</span>
                    <span class="value" id="global-throughput">0.00 veh/min</span>
                  </div>
                  
                  <div class="metric">
                    <span class="label">Congestion Index:</span>
                    <span class="value" id="congestion-index">0.00</span>
                  </div>
                </div>
                
                <div class="analytics-section">
                  <h4>Network Stats</h4>
                  
                  <div class="metric">
                    <span class="label">Intersections:</span>
                    <span class="value" id="total-intersections">0</span>
                  </div>
                  
                  <div class="metric">
                    <span class="label">Roads:</span>
                    <span class="value" id="total-roads">0</span>
                  </div>
                </div>
                
                <div class="analytics-section">
                  <h4>Lane Metrics</h4>
                  <button id="toggle-lane-metrics" class="btn btn-sm">Show/Hide Lane Metrics</button>
                  
                  <div id="lane-metrics-container" class="metrics-table-container" style="display: none;">
                    <table class="metrics-table">
                      <thead>
                        <tr>
                          <th>Lane ID</th>
                          <th>Avg Speed</th>
                          <th>Vehicles</th>
                          <th>Congestion</th>
                          <th>Throughput</th>
                          <th>Total Passed</th>
                          <th>Queue Length</th>
                        </tr>
                      </thead>
                      <tbody id="lane-metrics-body">
                        <!-- Lanes will be populated here -->
                      </tbody>
                    </table>
                  </div>
                </div>
                
                <div class="analytics-section">
                  <h4>Intersection Metrics</h4>
                  <button id="toggle-intersection-metrics" class="btn btn-sm">Show/Hide Intersection Metrics</button>
                  
                  <div id="intersection-metrics-container" class="metrics-table-container" style="display: none;">
                    <table class="metrics-table">
                      <thead>
                        <tr>
                          <th>ID</th>
                          <th>Throughput</th>
                          <th>Avg Wait</th>
                          <th>Max Wait</th>
                          <th>Avg Queue</th>
                          <th>Total Passed</th>
                          <th>Congestion</th>
                        </tr>
                      </thead>
                      <tbody id="intersection-metrics-body">
                        <!-- Intersections will be populated here -->
                      </tbody>
                    </table>
                  </div>
                </div>
                
                <div class="analytics-actions">
                  <button id="export-metrics-csv" class="btn btn-sm btn-success">📄 Export CSV</button>
                  <button id="export-metrics-json" class="btn btn-sm btn-info">📋 Export JSON</button>
                  <button id="validate-metrics" class="btn btn-sm btn-secondary">✓ Validate Data</button>
                </div>
                
                <!-- Developer Tools Section -->
                <div class="analytics-section analytics-dev-tools">
                  <h4>Developer Tools</h4>
                  <button id="validate-kpis" class="btn btn-sm btn-secondary btn-block">
                    🔍 Validate KPI Collection
                  </button>
                  <div class="validation-output" id="validation-output" style="display: none;">
                    <div id="validation-html-results" class="validation-formatted"></div>
                    <h4>Debug Log Output:</h4>
                    <pre id="validation-results">No validation results yet.</pre>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- Instructions -->
            <div class="panel">
              <h3>Instructions</h3>
              <ul class="instructions">
                <li>Select a saved layout or use the current one</li>
                <li>Adjust the number of cars and simulation speed</li>
                <li>Click Start to begin the simulation</li>
                <li>Monitor real-time analytics</li>
                <li>Save analytics for later analysis</li>
              </ul>
            </div>
          </div>
          
          <div class="visualization-area">
            <canvas id="simulation-canvas"></canvas>
          </div>
        </div>
      </div>
      
      <!-- KPI Benchmark Modal (hidden by default) -->
      <div id="benchmark-modal" class="modal" style="display: none;">
        <div class="modal-content benchmark-modal-content">
          <div class="modal-header">
            <span class="close">&times;</span>
            <h2>KPI Benchmark Configuration</h2>
          </div>
          <div class="modal-body">
            <div class="benchmark-settings">
              <div class="form-group">
                <label for="benchmark-layout">Layout:</label>
                <select id="benchmark-layout" class="form-control">
                  <option value="">Current Layout</option>
                  <!-- Layout options will be populated dynamically -->
                </select>
                <small class="setting-description">Select a layout to use for the benchmark (or use current layout)</small>
              </div>
              
              <div class="form-group">
                <label for="benchmark-duration">Simulation Duration (seconds):</label>
                <input type="number" id="benchmark-duration" class="form-control" min="10" max="300" value="60">
                <small class="setting-description">How long the simulation should run (in simulation seconds)</small>
              </div>
              
              <div class="form-group">
                <label for="benchmark-model">Traffic Control Model:</label>
                <select id="benchmark-model" class="form-control">
                  <option value="fixed-timing">Fixed Timing</option>
                  <option value="adaptive-timing">Adaptive Timing</option>
                  <option value="traffic-enforcer">Traffic Enforcer</option>
                  <option value="all-red-flashing">All Red Flashing</option>
                </select>
                <small class="setting-description">Traffic control model to test during benchmark</small>
              </div>
              
              <div class="form-group">
                <label for="benchmark-cars">Number of Vehicles:</label>
                <input type="number" id="benchmark-cars" class="form-control" min="10" max="200" value="100">
                <small class="setting-description">Number of vehicles to simulate</small>
              </div>
              
              <div class="form-group">
                <label for="benchmark-time-factor">Time Factor:</label>
                <input type="number" id="benchmark-time-factor" class="form-control" min="0.1" max="5" step="0.1" value="2">
                <small class="setting-description">Speed of simulation (higher = faster)</small>
              </div>
              
              <div class="benchmark-options">
                <div class="option">
                  <input type="checkbox" id="benchmark-repeat" checked>
                  <label for="benchmark-repeat">Collect continuous data</label>
                </div>
                <div class="option">
                  <input type="checkbox" id="benchmark-export" checked>
                  <label for="benchmark-export">Export results after completion</label>
                </div>
              </div>
            </div>
          </div>
          <div class="modal-footer">
            <button class="btn btn-secondary" id="cancel-benchmark">Cancel</button>
            <button class="btn btn-primary" id="start-benchmark">Start Benchmark</button>
          </div>
        </div>
      </div>
      
      <!-- Benchmark Results Modal (hidden by default) -->
      <div id="benchmark-results-modal" class="modal" style="display: none;">
        <div class="modal-content benchmark-results-content">
          <div class="modal-header">
            <span class="close">&times;</span>
            <h2>KPI Benchmark Results</h2>
          </div>
          <div class="modal-body">
            <div id="benchmark-summary" class="benchmark-summary">
              <!-- Summary info will be added here dynamically -->
            </div>
            <div id="benchmark-metrics" class="benchmark-metrics">
              <!-- Metrics will be added here dynamically -->
            </div>
            <div id="benchmark-charts" class="benchmark-charts">
              <!-- Charts will be added here dynamically -->
            </div>
          </div>
          <div class="modal-footer">
            <button class="btn btn-secondary" id="close-benchmark-results">Close</button>
            <button class="btn btn-success" id="export-benchmark-results">Export Results (CSV)</button>
          </div>
        </div>
      </div>
      
      <!-- Scenario Dialog -->
      <div id="scenario-dialog" class="modal" style="display: none;">
        <div class="modal-content">
          <div class="modal-header">
            <h2>Scenario Management</h2>
            <span class="close-modal" id="close-scenario-dialog">&times;</span>
          </div>
          <div class="modal-body">
            <!-- Tabs -->
            <div class="dialog-tabs">
              <button class="tab-btn active" data-tab="save-tab">Save Scenario</button>
              <button class="tab-btn" data-tab="load-tab">Load Scenario</button>
            </div>
            
            <!-- Save Tab -->
            <div id="save-tab" class="tab-content">
              <div class="form-group">
                <label for="scenario-name">Scenario Name:</label>
                <input type="text" id="scenario-name" class="form-control" placeholder="Enter a name for this scenario">
              </div>
              <div class="form-group">
                <label for="scenario-description">Description (optional):</label>
                <textarea id="scenario-description" class="form-control" placeholder="Add a description"></textarea>
              </div>
              <button id="save-scenario-confirm" class="btn btn-primary">Save Scenario</button>
            </div>
            
            <!-- Load Tab -->
            <div id="load-tab" class="tab-content" style="display: none;">
              <div class="scenarios-list-container">
                <ul id="scenarios-list" class="scenarios-list">
                  <!-- Scenarios will be listed here dynamically -->
                </ul>
              </div>
              <div class="form-actions">
                <button id="load-scenario-confirm" class="btn btn-primary" disabled>Load Selected</button>
                <button id="delete-scenario" class="btn btn-danger" disabled>Delete Selected</button>
              </div>
            </div>
          </div>
        </div>
      </div>
    `;
        // Update the visualization area if needed
        const visualizationArea = this.container.querySelector('.visualizer-area');
        if (visualizationArea) {
            // Any additional setup for the visualization area
        }
    }
    addEventListeners() {
        // Load layout button
        const loadLayoutButton = document.getElementById('load-layout');
        loadLayoutButton === null || loadLayoutButton === void 0 ? void 0 : loadLayoutButton.addEventListener('click', () => this.showLoadLayoutDialog());
        // Save scenario button
        const saveScenarioButton = document.getElementById('save-scenario');
        saveScenarioButton === null || saveScenarioButton === void 0 ? void 0 : saveScenarioButton.addEventListener('click', () => this.showScenarioDialog('save'));
        // Load scenario button
        const loadScenarioButton = document.getElementById('load-scenario');
        loadScenarioButton === null || loadScenarioButton === void 0 ? void 0 : loadScenarioButton.addEventListener('click', () => this.showScenarioDialog('load'));
        // Toggle simulation button
        const toggleSimulationButton = document.getElementById('toggle-simulation');
        toggleSimulationButton === null || toggleSimulationButton === void 0 ? void 0 : toggleSimulationButton.addEventListener('click', () => this.toggleSimulation());
        // Reset simulation button
        const resetSimulationButton = document.getElementById('reset-simulation');
        resetSimulationButton === null || resetSimulationButton === void 0 ? void 0 : resetSimulationButton.addEventListener('click', () => this.resetSimulation());
        // Run benchmark button
        const runBenchmarkButton = document.getElementById('run-benchmark');
        runBenchmarkButton === null || runBenchmarkButton === void 0 ? void 0 : runBenchmarkButton.addEventListener('click', () => this.runBenchmark());
        // Traffic control model dropdown
        const trafficControlModelSelect = document.getElementById('traffic-control-model');
        trafficControlModelSelect === null || trafficControlModelSelect === void 0 ? void 0 : trafficControlModelSelect.addEventListener('change', () => {
            this.selectedTrafficControlModel = trafficControlModelSelect.value;
            this.updateTrafficControlModel();
        });
        // Cars range slider
        const carsRangeSlider = document.getElementById('cars-range');
        carsRangeSlider === null || carsRangeSlider === void 0 ? void 0 : carsRangeSlider.addEventListener('input', () => {
            const value = parseInt(carsRangeSlider.value);
            document.getElementById('cars-value').textContent = value.toString();
            if (this.world) {
                this.world.carsNumber = value;
            }
        });
        // Time factor range slider
        const timeFactorRangeSlider = document.getElementById('time-factor-range');
        timeFactorRangeSlider === null || timeFactorRangeSlider === void 0 ? void 0 : timeFactorRangeSlider.addEventListener('input', () => {
            const value = parseFloat(timeFactorRangeSlider.value);
            document.getElementById('time-factor-value').textContent = value.toFixed(1);
            if (this.visualizer) {
                this.visualizer.setTimeFactor(value);
            }
        });
        // Toggle analytics button
        const toggleAnalyticsButton = document.getElementById('toggle-analytics');
        toggleAnalyticsButton === null || toggleAnalyticsButton === void 0 ? void 0 : toggleAnalyticsButton.addEventListener('click', () => {
            const panel = document.getElementById('analytics-panel');
            if (!panel)
                return;
            const isHidden = (panel === null || panel === void 0 ? void 0 : panel.style.display) === 'none';
            panel.style.display = isHidden ? 'block' : 'none';
            toggleAnalyticsButton.textContent = isHidden ? 'Hide Analytics' : 'Show Analytics';
        });
        // Close scenario dialog button
        const closeScenarioDialogBtn = document.getElementById('close-scenario-dialog');
        closeScenarioDialogBtn === null || closeScenarioDialogBtn === void 0 ? void 0 : closeScenarioDialogBtn.addEventListener('click', () => {
            const dialog = document.getElementById('scenario-dialog');
            if (dialog) {
                dialog.style.display = 'none';
            }
        });
        // Tab buttons in scenario dialog
        const tabButtons = document.querySelectorAll('.tab-btn');
        tabButtons.forEach(btn => {
            btn.addEventListener('click', (e) => {
                const target = e.target;
                const tabId = target.getAttribute('data-tab');
                // Hide all tab contents and remove active class
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.style.display = 'none';
                });
                document.querySelectorAll('.tab-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                // Show selected tab content and add active class
                if (tabId) {
                    document.getElementById(tabId).style.display = 'block';
                    target.classList.add('active');
                }
            });
        });
        // Save scenario confirm button
        const saveScenarioConfirmButton = document.getElementById('save-scenario-confirm');
        saveScenarioConfirmButton === null || saveScenarioConfirmButton === void 0 ? void 0 : saveScenarioConfirmButton.addEventListener('click', () => this.saveScenario());
        // Load scenario confirm button
        const loadScenarioConfirmButton = document.getElementById('load-scenario-confirm');
        loadScenarioConfirmButton === null || loadScenarioConfirmButton === void 0 ? void 0 : loadScenarioConfirmButton.addEventListener('click', (e) => {
            console.log('Load scenario button clicked');
            e.preventDefault();
            this.loadSelectedScenario();
        });
        // Delete scenario button
        const deleteScenarioButton = document.getElementById('delete-scenario');
        deleteScenarioButton === null || deleteScenarioButton === void 0 ? void 0 : deleteScenarioButton.addEventListener('click', () => {
            const selectedItem = document.querySelector('.list-item.selected');
            if (selectedItem) {
                const scenarioId = selectedItem.getAttribute('data-id');
                if (scenarioId) {
                    this.deleteScenario(scenarioId);
                }
            }
            else {
                this.showNotification('No scenario selected', 'warning');
            }
        });
        // Add click listener to scenarios list items to enable/disable buttons
        document.addEventListener('click', (e) => {
            const target = e.target;
            // Check if click is on a list item or its children (excluding delete button)
            if (target.closest('.list-item') && !target.classList.contains('btn-delete')) {
                const loadButton = document.getElementById('load-scenario-confirm');
                const deleteButton = document.getElementById('delete-scenario');
                if (loadButton)
                    loadButton.disabled = false;
                if (deleteButton)
                    deleteButton.disabled = false;
            }
        });
        // Export metrics buttons
        const exportCSVButton = document.getElementById('export-metrics-csv');
        exportCSVButton === null || exportCSVButton === void 0 ? void 0 : exportCSVButton.addEventListener('click', () => {
            kpi_collector_1.kpiCollector.downloadMetricsCSV();
            this.showNotification('CSV exported successfully', 'success');
        });
        const exportJSONButton = document.getElementById('export-metrics-json');
        exportJSONButton === null || exportJSONButton === void 0 ? void 0 : exportJSONButton.addEventListener('click', () => {
            kpi_collector_1.kpiCollector.downloadMetricsJSON();
            this.showNotification('JSON exported successfully', 'success');
        });
        // Validate metrics button (enhanced functionality)
        const validateMetricsButton = document.getElementById('validate-metrics');
        validateMetricsButton === null || validateMetricsButton === void 0 ? void 0 : validateMetricsButton.addEventListener('click', () => {
            // Get validation results from KPI collection accuracy
            const kpiValidationResults = kpi_collector_1.kpiCollector.validateMetrics();
            // Get export validation results
            const exportValidation = kpi_collector_1.kpiCollector.validateExportData();
            const validationOutput = document.getElementById('validation-output');
            const validationHtmlResults = document.getElementById('validation-html-results');
            if (validationOutput && validationHtmlResults) {
                // Combine both validation results
                let combinedResults = `
          <div class="validation-section">
            <h4>📊 KPI Collection Validation</h4>
            ${kpiValidationResults}
          </div>
          
          <div class="validation-section">
            <h4>📤 Export Data Validation</h4>
            <div class="export-validation-summary">
              <p><strong>${exportValidation.summary}</strong></p>
            </div>
            
            ${exportValidation.discrepancies.length > 0 ? `
              <div class="validation-discrepancies">
                <h5>Found Discrepancies:</h5>
                <ul>
                  ${exportValidation.discrepancies.map(d => `<li class="validation-error">${d}</li>`).join('')}
                </ul>
              </div>
            ` : `
              <div class="validation-success">
                <p>✅ All export formats (CSV and JSON) accurately match the UI display data.</p>
                <p>✅ Data integrity verified across all metric categories.</p>
              </div>
            `}
          </div>
        `;
                validationHtmlResults.innerHTML = combinedResults;
                validationOutput.style.display = 'block';
            }
            const notificationType = exportValidation.isValid ? 'success' : 'warning';
            const notificationMessage = exportValidation.isValid
                ? 'All validations passed - data is accurate and complete'
                : `Validation completed with ${exportValidation.discrepancies.length} issue(s) found`;
            this.showNotification(notificationMessage, notificationType);
        });
        // Toggle lane metrics table
        const toggleLaneMetricsButton = document.getElementById('toggle-lane-metrics');
        toggleLaneMetricsButton === null || toggleLaneMetricsButton === void 0 ? void 0 : toggleLaneMetricsButton.addEventListener('click', () => {
            const container = document.getElementById('lane-metrics-container');
            if (container) {
                const isHidden = container.style.display === 'none';
                container.style.display = isHidden ? 'block' : 'none';
            }
        });
        // Toggle intersection metrics table
        const toggleIntersectionMetricsButton = document.getElementById('toggle-intersection-metrics');
        toggleIntersectionMetricsButton === null || toggleIntersectionMetricsButton === void 0 ? void 0 : toggleIntersectionMetricsButton.addEventListener('click', () => {
            const container = document.getElementById('intersection-metrics-container');
            if (container) {
                const isHidden = container.style.display === 'none';
                container.style.display = isHidden ? 'block' : 'none';
            }
        });
    }
    // Show the scenario dialog for saving or loading
    showScenarioDialog(mode) {
        const dialog = document.getElementById('scenario-dialog');
        dialog.style.display = 'block';
        // Set the active tab based on mode
        const saveTab = document.getElementById('save-tab');
        const loadTab = document.getElementById('load-tab');
        const saveTabBtn = document.querySelector(`.tab-btn[data-tab="save-tab"]`);
        const loadTabBtn = document.querySelector(`.tab-btn[data-tab="load-tab"]`);
        if (mode === 'save') {
            saveTab.style.display = 'block';
            loadTab.style.display = 'none';
            saveTabBtn.classList.add('active');
            loadTabBtn.classList.remove('active');
        }
        else {
            saveTab.style.display = 'none';
            loadTab.style.display = 'block';
            saveTabBtn.classList.remove('active');
            loadTabBtn.classList.add('active');
            // Populate the scenarios list
            this.populateScenariosListUI();
        }
    }
    // Populate the scenarios list in the UI
    populateScenariosListUI() {
        const scenariosList = document.getElementById('scenarios-list');
        // Clear the list
        scenariosList.innerHTML = '';
        if (this.scenarios.length === 0) {
            scenariosList.innerHTML = '<div class="list-empty-message">No saved scenarios found.</div>';
            // Disable the load/delete buttons since there are no scenarios
            const loadButton = document.getElementById('load-scenario-confirm');
            const deleteButton = document.getElementById('delete-scenario');
            if (loadButton)
                loadButton.disabled = true;
            if (deleteButton)
                deleteButton.disabled = true;
            return;
        }
        console.log(`Populating scenarios list with ${this.scenarios.length} scenarios`);
        // Add each scenario to the list
        this.scenarios.forEach(scenario => {
            console.log(`Adding scenario to list: ${scenario.id} - ${scenario.name}`);
            const scenarioItem = document.createElement('div');
            scenarioItem.className = 'list-item';
            scenarioItem.dataset.id = scenario.id;
            const date = new Date(scenario.createdAt).toLocaleDateString();
            const time = new Date(scenario.createdAt).toLocaleTimeString();
            scenarioItem.innerHTML = `
        <div class="list-item-info">
          <div class="list-item-title">${scenario.name}</div>
          <div class="list-item-meta">Created: ${date} ${time}</div>
        </div>
        <button class="btn-delete" data-id="${scenario.id}">&times;</button>
      `;
            // Add click event to select the scenario
            scenarioItem.addEventListener('click', (e) => {
                // Ignore clicks on the delete button
                if (e.target.classList.contains('btn-delete')) {
                    return;
                }
                console.log(`Scenario selected: ${scenario.id} - ${scenario.name}`);
                // Remove the 'selected' class from all items
                document.querySelectorAll('.list-item').forEach(item => {
                    item.classList.remove('selected');
                });
                // Add the 'selected' class to this item
                scenarioItem.classList.add('selected');
                // Enable the load and delete buttons
                const loadButton = document.getElementById('load-scenario-confirm');
                const deleteButton = document.getElementById('delete-scenario');
                if (loadButton)
                    loadButton.disabled = false;
                if (deleteButton)
                    deleteButton.disabled = false;
            });
            // Add double-click event to load the scenario immediately
            scenarioItem.addEventListener('dblclick', (e) => {
                // Ignore double clicks on the delete button
                if (e.target.classList.contains('btn-delete')) {
                    return;
                }
                console.log(`Scenario double-clicked (loading): ${scenario.id} - ${scenario.name}`);
                this.loadScenarioById(scenario.id);
            });
            // Add delete button event
            const deleteButton = scenarioItem.querySelector('.btn-delete');
            deleteButton === null || deleteButton === void 0 ? void 0 : deleteButton.addEventListener('click', (e) => {
                e.stopPropagation();
                console.log(`Delete button clicked for scenario: ${scenario.id}`);
                this.deleteScenario(scenario.id);
            });
            scenariosList.appendChild(scenarioItem);
        });
    }
    // Save the current scenario
    async saveScenario() {
        if (!this.world) {
            this.showNotification('No simulation world to save', 'warning');
            return;
        }
        // Get scenario name from input
        const scenarioNameInput = document.getElementById('scenario-name');
        const scenarioName = scenarioNameInput.value.trim() || `Scenario ${new Date().toLocaleString()}`;
        // Get scenario description from input
        const scenarioDescriptionInput = document.getElementById('scenario-description');
        const scenarioDescription = scenarioDescriptionInput.value.trim();
        // Get scenario data from world
        const scenarioData = this.world.saveAsScenario();
        // Add description to scenario data
        scenarioData.description = scenarioDescription;
        try {
            // Save scenario
            await AppState_1.appState.storage.saveScenario(scenarioData, scenarioName);
            // Reload scenarios
            await this.loadScenarios();
            // Find the newly saved scenario from the reloaded scenarios list
            const newScenarioId = `scenario_${Date.now()}`;
            // Get most recently saved scenario (should be the last one in the array)
            const savedScenario = this.scenarios.length > 0 ? this.scenarios[this.scenarios.length - 1] : null;
            // Update current scenario info
            this.currentScenario = savedScenario || {
                name: scenarioName,
                id: newScenarioId,
                data: scenarioData
            };
            // Update scenario status in UI
            const scenarioStatus = document.querySelector('.scenario-status');
            if (scenarioStatus) {
                scenarioStatus.innerHTML = `
          <small class="text-muted">
            ${this.scenarios.length} saved scenario(s) available
          </small>
          <div class="current-scenario-info">Current: ${scenarioName}</div>
        `;
            }
            // Close dialog
            document.getElementById('scenario-dialog').style.display = 'none';
            // Show success notification
            this.showNotification('Scenario saved successfully', 'success');
        }
        catch (error) {
            console.error('Failed to save scenario:', error);
            this.showNotification('Failed to save scenario', 'error');
        }
    }
    // Load a scenario by ID
    async loadScenarioById(id) {
        try {
            console.log(`Attempting to load scenario with ID: ${id}`);
            // Debug: List all available scenarios
            console.log('Available scenarios:', this.scenarios);
            const scenarioData = await AppState_1.appState.storage.loadScenario(id);
            console.log('Loaded scenario data:', scenarioData);
            if (!scenarioData) {
                console.error(`No scenario data found for ID: ${id}`);
                this.showNotification('Scenario not found', 'error');
                return;
            }
            // Find the scenario in the scenarios array to get its name
            const scenario = this.scenarios.find(s => s.id === id);
            console.log('Found scenario metadata:', scenario);
            if (!scenario) {
                console.error(`Scenario metadata not found for ID: ${id}`);
                this.showNotification('Scenario metadata not found', 'error');
                return;
            }
            // Load the scenario
            if (this.world) {
                // Stop simulation if running
                if (this.isRunning) {
                    this.toggleSimulation();
                }
                // Reset KPI collector
                kpi_collector_1.kpiCollector.reset();
                try {
                    // Load the scenario into the world
                    console.log('Loading scenario into world...');
                    this.world.loadScenario(scenarioData);
                    console.log('Scenario loaded into world successfully');
                    // Update UI components
                    this.updateUIFromWorld();
                    // Update current scenario info
                    this.currentScenario = scenario;
                    // Update scenario status in UI
                    const scenarioStatus = document.querySelector('.scenario-status');
                    if (scenarioStatus) {
                        scenarioStatus.innerHTML = `
              <small class="text-muted">
                ${this.scenarios.length} saved scenario(s) available
              </small>
              <div class="current-scenario-info">Current: ${scenario.name}</div>
            `;
                    }
                    // Show success notification
                    this.showNotification(`Scenario "${scenario.name}" loaded successfully`, 'success');
                    // Close dialog if it's open
                    const dialog = document.getElementById('scenario-dialog');
                    if (dialog && dialog.style.display === 'block') {
                        dialog.style.display = 'none';
                    }
                }
                catch (worldError) {
                    console.error('Error loading scenario into world:', worldError);
                    this.showNotification(`Error loading scenario: ${worldError.message}`, 'error');
                }
            }
            else {
                console.error('World object is not initialized');
                this.showNotification('Simulation world not initialized', 'error');
            }
        }
        catch (error) {
            console.error('Failed to load scenario:', error);
            this.showNotification(`Failed to load scenario: ${error.message}`, 'error');
        }
    }
    // Load the selected scenario from the list
    loadSelectedScenario() {
        console.log('loadSelectedScenario called');
        const selectedItem = document.querySelector('.list-item.selected');
        if (!selectedItem) {
            console.warn('No scenario selected');
            this.showNotification('No scenario selected', 'warning');
            return;
        }
        const scenarioId = selectedItem.getAttribute('data-id');
        if (!scenarioId) {
            console.error('Selected item does not have a data-id attribute');
            this.showNotification('Invalid scenario selection', 'error');
            return;
        }
        console.log(`Loading selected scenario with ID: ${scenarioId}`);
        this.loadScenarioById(scenarioId);
    }
    // Delete a scenario
    async deleteScenario(id) {
        if (!confirm('Are you sure you want to delete this scenario?')) {
            return;
        }
        try {
            // Delete the scenario from storage
            await AppState_1.appState.storage.deleteScenario(id);
            // Reload scenarios
            this.scenarios = await AppState_1.appState.storage.loadAllScenarios();
            // Update the UI
            this.populateScenariosListUI();
            // Update scenario status
            const scenarioStatus = document.querySelector('.scenario-status');
            if (scenarioStatus) {
                scenarioStatus.innerHTML = `
          <small class="text-muted">
            ${this.scenarios.length} saved scenario(s) available
          </small>
          ${this.currentScenario && this.currentScenario.id !== id
                    ? `<div class="current-scenario-info">Current: ${this.currentScenario.name}</div>`
                    : ''}
        `;
            }
            // Clear current scenario if it was deleted
            if (this.currentScenario && this.currentScenario.id === id) {
                this.currentScenario = null;
            }
            // Reset the buttons
            const loadButton = document.getElementById('load-scenario-confirm');
            const deleteButton = document.getElementById('delete-scenario');
            if (loadButton)
                loadButton.disabled = true;
            if (deleteButton)
                deleteButton.disabled = true;
            // Show success notification
            this.showNotification('Scenario deleted successfully', 'success');
        }
        catch (error) {
            console.error('Failed to delete scenario:', error);
            this.showNotification('Failed to delete scenario', 'error');
        }
    }
    // Update UI components from world state
    updateUIFromWorld() {
        if (!this.world)
            return;
        // Update cars range slider
        const carsRangeSlider = document.getElementById('cars-range');
        if (carsRangeSlider) {
            carsRangeSlider.value = this.world.carsNumber.toString();
            document.getElementById('cars-value').textContent = this.world.carsNumber.toString();
        }
        // Update traffic control model dropdown
        const trafficControlModelSelect = document.getElementById('traffic-control-model');
        if (trafficControlModelSelect && this.world.activeTrafficControlStrategy) {
            trafficControlModelSelect.value = this.world.activeTrafficControlStrategy;
            this.selectedTrafficControlModel = this.world.activeTrafficControlStrategy;
            this.updateActiveModelIndicator(this.selectedTrafficControlModel);
        }
    }
    // Update the active model indicator
    updateActiveModelIndicator(modelType) {
        const indicator = document.getElementById('active-model-indicator');
        if (!indicator)
            return;
        let modelName = 'Fixed Timing';
        switch (modelType) {
            case 'fixed-timing':
                modelName = 'Fixed Timing';
                break;
            case 'adaptive-timing':
                modelName = 'Adaptive Timing';
                break;
            case 'traffic-enforcer':
                modelName = 'Traffic Enforcer';
                break;
            case 'all-red-flashing':
                modelName = 'All Red Flashing';
                break;
        }
        indicator.textContent = modelName;
    }
    // Initialize the simulation
    async initializeSimulation() {
        try {
            // Create a new world instance
            this.world = new World();
            // Initialize visualizer with the canvas element
            // Pass world and canvas ID to visualizer (note: constructor expects world first, then canvasId)
            this.visualizer = new Visualizer(this.world, 'simulation-canvas');
            // Set initial cars number
            const carsRangeSlider = document.getElementById('cars-range');
            if (carsRangeSlider) {
                this.world.carsNumber = parseInt(carsRangeSlider.value);
            }
            // Set initial time factor
            const timeFactorRangeSlider = document.getElementById('time-factor-range');
            if (timeFactorRangeSlider && this.visualizer) {
                this.visualizer.setTimeFactor(parseFloat(timeFactorRangeSlider.value));
            }
            // Start with an empty map - don't automatically generate one
            // Users should explicitly load a layout or scenario
            // Set initial traffic control strategy
            this.updateTrafficControlModel();
        }
        catch (error) {
            console.error('Failed to initialize simulation:', error);
        }
    }
    // Show a notification message
    showNotification(message, type = 'success') {
        // Create notification element if it doesn't exist
        let notificationContainer = document.getElementById('notification-container');
        if (!notificationContainer) {
            notificationContainer = document.createElement('div');
            notificationContainer.id = 'notification-container';
            notificationContainer.style.position = 'fixed';
            notificationContainer.style.top = '20px';
            notificationContainer.style.right = '20px';
            notificationContainer.style.zIndex = '9999';
            document.body.appendChild(notificationContainer);
        }
        // Create notification
        const notification = document.createElement('div');
        notification.className = `notification notification-${type}`;
        notification.innerHTML = `
      <div class="notification-content">
        ${message}
      </div>
      <button class="notification-close">&times;</button>
    `;
        // Style the notification
        notification.style.backgroundColor =
            type === 'success' ? '#43a047' :
                type === 'warning' ? '#fb8c00' :
                    '#e53935';
        notification.style.color = '#fff';
        notification.style.padding = '12px 20px';
        notification.style.marginBottom = '10px';
        notification.style.borderRadius = '4px';
        notification.style.boxShadow = '0 2px 10px rgba(0,0,0,0.2)';
        notification.style.display = 'flex';
        notification.style.justifyContent = 'space-between';
        notification.style.alignItems = 'center';
        notification.style.transition = 'all 0.3s ease';
        // Add close button event
        const closeButton = notification.querySelector('.notification-close');
        closeButton.style.background = 'none';
        closeButton.style.border = 'none';
        closeButton.style.color = '#fff';
        closeButton.style.fontSize = '20px';
        closeButton.style.cursor = 'pointer';
        closeButton.style.marginLeft = '10px';
        closeButton.onclick = () => {
            notification.style.opacity = '0';
            setTimeout(() => {
                notification.remove();
            }, 300);
        };
        // Add to container
        notificationContainer.appendChild(notification);
        // Auto-remove after 5 seconds
        setTimeout(() => {
            notification.style.opacity = '0';
            setTimeout(() => {
                notification.remove();
            }, 300);
        }, 5000);
    }
    // Show the load layout dialog
    showLoadLayoutDialog() {
        // Create dialog if it doesn't exist
        let dialog = document.getElementById('load-layout-dialog');
        if (!dialog) {
            dialog = document.createElement('div');
            dialog.id = 'load-layout-dialog';
            dialog.className = 'dialog';
            dialog.innerHTML = `
        <div class="dialog-content">
          <div class="dialog-header">
            <h3>Load Layout</h3>
            <button class="close-btn">&times;</button>
          </div>
          <div class="dialog-body">
            <div id="layouts-list" class="list-container">
              <div class="list-empty-message">No saved layouts found.</div>
            </div>
            <div class="form-actions">
              <button id="load-layout-confirm" class="btn btn-primary">Load</button>
              <button class="btn btn-secondary close-dialog">Cancel</button>
            </div>
          </div>
        </div>
      `;
            document.body.appendChild(dialog);
            // Add close button events
            const closeButtons = dialog.querySelectorAll('.close-btn, .close-dialog');
            closeButtons.forEach(button => {
                button.addEventListener('click', () => {
                    dialog.style.display = 'none';
                });
            });
            // Add load button event
            const loadButton = dialog.querySelector('#load-layout-confirm');
            loadButton === null || loadButton === void 0 ? void 0 : loadButton.addEventListener('click', () => {
                const selectedItem = document.querySelector('.list-item.selected');
                if (selectedItem) {
                    const layoutId = selectedItem.getAttribute('data-id');
                    this.loadLayoutById(layoutId);
                    dialog.style.display = 'none';
                }
                else {
                    this.showNotification('No layout selected', 'warning');
                }
            });
        }
        // Show dialog
        dialog.style.display = 'block';
        // Populate layouts list
        this.populateLayoutsListUI();
    }
    // Populate the layouts list in the UI
    populateLayoutsListUI() {
        const layoutsList = document.getElementById('layouts-list');
        // Clear the list
        layoutsList.innerHTML = '';
        if (this.layouts.length === 0) {
            layoutsList.innerHTML = '<div class="list-empty-message">No saved layouts found.</div>';
            return;
        }
        // Add each layout to the list
        this.layouts.forEach(layout => {
            const layoutItem = document.createElement('div');
            layoutItem.className = 'list-item';
            layoutItem.dataset.id = layout.id;
            const date = new Date(layout.createdAt).toLocaleDateString();
            const time = new Date(layout.createdAt).toLocaleTimeString();
            layoutItem.innerHTML = `
        <div class="list-item-info">
          <div class="list-item-title">${layout.name}</div>
          <div class="list-item-meta">Created: ${date} ${time}</div>
        </div>
      `;
            // Add click event to select the layout
            layoutItem.addEventListener('click', () => {
                // Remove the 'selected' class from all items
                document.querySelectorAll('.list-item').forEach(item => {
                    item.classList.remove('selected');
                });
                // Add the 'selected' class to this item
                layoutItem.classList.add('selected');
            });
            layoutsList.appendChild(layoutItem);
        });
    }
    // Load a layout by ID
    async loadLayoutById(id) {
        try {
            // Find the layout in the layouts array
            const layout = this.layouts.find(l => l.id === id);
            if (!layout) {
                this.showNotification('Layout not found', 'error');
                return;
            }
            // Stop simulation if running
            if (this.isRunning) {
                this.toggleSimulation();
            }
            // Reset KPI collector
            kpi_collector_1.kpiCollector.reset();
            // Clear the current world
            this.world.clear();
            // Load the layout data
            if (layout && layout.data) {
                const worldData = layout.data;
                // Load into world
                this.world.load(JSON.stringify(worldData));
                // Reset car count to 100 by default
                this.world.carsNumber = 100;
                // Update UI components
                const carsRangeSlider = document.getElementById('cars-range');
                if (carsRangeSlider) {
                    carsRangeSlider.value = this.world.carsNumber.toString();
                    document.getElementById('cars-value').textContent = this.world.carsNumber.toString();
                }
                // Show success notification
                this.showNotification(`Layout "${layout.name}" loaded successfully`, 'success');
            }
        }
        catch (error) {
            console.error('Failed to load layout:', error);
            this.showNotification('Failed to load layout', 'error');
        }
    }
    // Toggle simulation running state
    toggleSimulation() {
        // Don't allow toggling during benchmark
        if (this.isBenchmarkRunning) {
            this.showNotification('Cannot toggle simulation during benchmark', 'warning');
            return;
        }
        const toggleButton = document.getElementById('toggle-simulation');
        if (this.isRunning) {
            // Stop simulation
            this.isRunning = false;
            this.visualizer.stop();
            toggleButton.textContent = '▶️ Start Simulation';
            toggleButton.classList.replace('btn-danger', 'btn-success');
            // Clear analytics interval
            if (this.analyticsInterval !== null) {
                clearInterval(this.analyticsInterval);
                this.analyticsInterval = null;
            }
            // Stop KPI collection
            kpi_collector_1.kpiCollector.stopRecording();
        }
        else {
            // Start simulation
            this.isRunning = true;
            this.visualizer.start();
            toggleButton.textContent = '⏸ Pause Simulation';
            toggleButton.classList.replace('btn-success', 'btn-danger');
            // Start KPI collection
            kpi_collector_1.kpiCollector.startRecording(this.world.time);
            // Set up analytics interval
            this.analyticsInterval = window.setInterval(() => {
                this.updateAnalytics();
            }, 500);
        }
    }
    // Stop the simulation
    stop() {
        if (this.isRunning) {
            this.isRunning = false;
            if (this.visualizer) {
                this.visualizer.stop();
            }
            // Clear analytics interval
            if (this.analyticsInterval !== null) {
                clearInterval(this.analyticsInterval);
                this.analyticsInterval = null;
            }
            // Stop KPI collection
            kpi_collector_1.kpiCollector.stopRecording();
            // Update button state
            const toggleButton = document.getElementById('toggle-simulation');
            if (toggleButton) {
                toggleButton.textContent = '▶️ Start Simulation';
                toggleButton.classList.replace('btn-danger', 'btn-success');
            }
        }
    }
    // Reset simulation to initial state
    resetSimulation() {
        // Don't allow reset during benchmark
        if (this.isBenchmarkRunning) {
            this.showNotification('Cannot reset simulation during benchmark', 'warning');
            return;
        }
        // Stop simulation if running
        if (this.isRunning) {
            this.toggleSimulation();
        }
        // Reset KPI collector
        kpi_collector_1.kpiCollector.reset();
        // Clear all cars
        for (const id in this.world.cars.all()) {
            const car = this.world.cars.all()[id];
            if (car) {
                this.world.removeCar(car);
            }
        }
        // Reset time
        this.world.time = 0;
        // Reset traffic lights
        for (const id in this.world.intersections.all()) {
            const intersection = this.world.intersections.all()[id];
            if (intersection) {
                // Reset trafficLightController if it exists
                if (intersection.trafficLightController && typeof intersection.trafficLightController.reset === 'function') {
                    intersection.trafficLightController.reset();
                }
                // Legacy support for controlSignals
                else if (intersection.controlSignals && typeof intersection.controlSignals.reset === 'function') {
                    intersection.controlSignals.reset();
                }
            }
        }
        // Update analytics
        this.updateAnalytics();
        // Show notification
        this.showNotification('Simulation reset', 'success');
    }
    // Run a KPI benchmark
    runBenchmark() {
        // Don't start a benchmark if one is already running
        if (this.isBenchmarkRunning) {
            this.showNotification('Benchmark already running', 'warning');
            return;
        }
        // Reset simulation first
        this.resetSimulation();
        // Initialize benchmark settings
        this.benchmarkSettings = {
            duration: this.benchmarkDuration,
            carsNumber: this.world.carsNumber,
            timeFactor: parseFloat(document.getElementById('time-factor-range').value),
            trafficControlModel: this.selectedTrafficControlModel,
            startTime: new Date().toISOString()
        };
        // Show notification
        this.showNotification(`Starting ${this.benchmarkDuration} second benchmark...`, 'success');
        // Start simulation
        this.isBenchmarkRunning = true;
        this.benchmarkStartTime = this.world.time;
        this.benchmarkIntervalSamples = [];
        // Update benchmark button
        const benchmarkButton = document.getElementById('run-benchmark');
        benchmarkButton.textContent = '⏱️ Benchmark Running...';
        benchmarkButton.classList.add('btn-warning');
        benchmarkButton.disabled = true;
        // Start simulation if not already running
        if (!this.isRunning) {
            this.toggleSimulation();
        }
        // Set interval to collect samples
        const sampleInterval = window.setInterval(() => {
            // Collect a sample every second
            this.benchmarkIntervalSamples.push(kpi_collector_1.kpiCollector.getMetrics(this.world.time));
        }, 1000);
        // Set timeout to end benchmark
        this.benchmarkTimer = window.setTimeout(() => {
            clearInterval(sampleInterval);
            this.endBenchmark();
        }, this.benchmarkDuration * 1000 / this.visualizer.timeFactor);
    }
    // End the benchmark and collect results
    endBenchmark() {
        // Stop benchmark
        this.isBenchmarkRunning = false;
        // Stop simulation
        if (this.isRunning) {
            this.toggleSimulation();
        }
        // Get final metrics
        const finalMetrics = kpi_collector_1.kpiCollector.getMetrics(this.world.time);
        // Build benchmark results
        this.benchmarkResults = {
            settings: this.benchmarkSettings,
            finalMetrics: finalMetrics,
            samples: this.benchmarkIntervalSamples,
            endTime: new Date().toISOString(),
            duration: this.world.time - this.benchmarkStartTime,
            validation: kpi_collector_1.kpiCollector.validateMetrics()
        };
        // Update benchmark button
        const benchmarkButton = document.getElementById('run-benchmark');
        benchmarkButton.textContent = '📊 Run KPI Benchmark';
        benchmarkButton.classList.remove('btn-warning');
        benchmarkButton.disabled = false;
        // Show results dialog
        this.showBenchmarkResults();
        // Show notification
        this.showNotification('Benchmark completed', 'success');
    }
    // Show benchmark results dialog
    showBenchmarkResults() {
        // Create dialog if it doesn't exist
        let dialog = document.getElementById('benchmark-results-dialog');
        if (!dialog) {
            dialog = document.createElement('div');
            dialog.id = 'benchmark-results-dialog';
            dialog.className = 'dialog benchmark-dialog';
            dialog.innerHTML = `
        <div class="dialog-content" style="max-width: 95vw; max-height: 90vh; width: 1400px;">
          <div class="dialog-header">
            <h3>📊 KPI Benchmark Results</h3>
            <button class="close-btn" style="font-size: 24px;">&times;</button>
          </div>
          <div class="dialog-body" style="max-height: calc(90vh - 100px); overflow-y: auto;">
            <div id="kpi-visualization-container"></div>
          </div>
        </div>
      `;
            document.body.appendChild(dialog);
            // Add close button events
            const closeButtons = dialog.querySelectorAll('.close-btn');
            closeButtons.forEach(button => {
                button.addEventListener('click', () => {
                    dialog.style.display = 'none';
                    // Clean up KPI visualization
                    if (this.kpiVisualization) {
                        this.kpiVisualization.destroy();
                        this.kpiVisualization = null;
                    }
                });
            });
        }
        // Show dialog
        dialog.style.display = 'block';
        // Create benchmark run data for the KPI visualization component
        const benchmarkRun = {
            id: `benchmark_${Date.now()}`,
            name: `Benchmark ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString()}`,
            timestamp: this.benchmarkResults.endTime,
            finalMetrics: this.benchmarkResults.finalMetrics,
            samples: this.benchmarkResults.samples,
            settings: this.benchmarkResults.settings,
            validation: this.benchmarkResults.validation
        };
        // Initialize KPI visualization component
        const container = document.getElementById('kpi-visualization-container');
        if (this.kpiVisualization) {
            this.kpiVisualization.destroy();
        }
        this.kpiVisualization = new KPIVisualizationComponent_1.KPIVisualizationComponent(container);
        this.kpiVisualization.displayBenchmarkResults(benchmarkRun);
    }
    // Populate benchmark results UI
    populateBenchmarkResultsUI() {
        const summaryContainer = document.getElementById('benchmark-summary');
        const metricsContainer = document.getElementById('benchmark-metrics');
        const validationContainer = document.getElementById('benchmark-validation');
        // Format date for display
        const startDate = new Date(this.benchmarkResults.settings.startTime);
        const endDate = new Date(this.benchmarkResults.endTime);
        // Summary
        summaryContainer.innerHTML = `
      <div class="metrics-table">
        <div class="metrics-row">
          <div class="metrics-label">Duration:</div>
          <div class="metrics-value">${this.benchmarkResults.duration.toFixed(1)} simulation seconds</div>
        </div>
        <div class="metrics-row">
          <div class="metrics-label">Vehicles:</div>
          <div class="metrics-value">${this.benchmarkResults.settings.carsNumber}</div>
        </div>
        <div class="metrics-row">
          <div class="metrics-label">Traffic Control:</div>
          <div class="metrics-value">${this.getTrafficControlName(this.benchmarkResults.settings.trafficControlModel)}</div>
        </div>
        <div class="metrics-row">
          <div class="metrics-label">Time Factor:</div>
          <div class="metrics-value">${this.benchmarkResults.settings.timeFactor}x</div>
        </div>
        <div class="metrics-row">
          <div class="metrics-label">Started:</div>
          <div class="metrics-value">${startDate.toLocaleString()}</div>
        </div>
        <div class="metrics-row">
          <div class="metrics-label">Ended:</div>
          <div class="metrics-value">${endDate.toLocaleString()}</div>
        </div>
      </div>
    `;
        // Metrics
        const metrics = this.benchmarkResults.finalMetrics;
        metricsContainer.innerHTML = `
      <div class="metrics-table">
        <div class="metrics-row">
          <div class="metrics-label">Average Speed:</div>
          <div class="metrics-value">${metrics.averageSpeed.toFixed(2)} m/s</div>
        </div>
        <div class="metrics-row">
          <div class="metrics-label">Average Wait Time:</div>
          <div class="metrics-value">${metrics.averageWaitTime.toFixed(1)} s</div>
        </div>
        <div class="metrics-row">
          <div class="metrics-label">Maximum Wait Time:</div>
          <div class="metrics-value">${metrics.maxWaitTime.toFixed(1)} s</div>
        </div>
        <div class="metrics-row">
          <div class="metrics-label">Total Stops:</div>
          <div class="metrics-value">${metrics.totalStops}</div>
        </div>
        <div class="metrics-row">
          <div class="metrics-label">Stopped Vehicles:</div>
          <div class="metrics-value">${metrics.stoppedVehicles}</div>
        </div>
        <div class="metrics-row">
          <div class="metrics-label">Completed Trips:</div>
          <div class="metrics-value">${metrics.completedTrips}</div>
        </div>
        <div class="metrics-row">
          <div class="metrics-label">Global Throughput:</div>
          <div class="metrics-value">${metrics.globalThroughput.toFixed(2)} vehicles/min</div>
        </div>
        <div class="metrics-row">
          <div class="metrics-label">Congestion Index:</div>
          <div class="metrics-value">${metrics.congestionIndex.toFixed(3)}</div>
        </div>
      </div>
    `;
        // Validation
        validationContainer.innerHTML = `
      <div class="validation-formatted">
        ${this.benchmarkResults.validation}
      </div>
    `;
    }
    // Get human-readable traffic control model name
    getTrafficControlName(modelType) {
        switch (modelType) {
            case 'fixed-timing': return 'Fixed Timing';
            case 'adaptive-timing': return 'Adaptive Timing';
            case 'traffic-enforcer': return 'Traffic Enforcer';
            case 'all-red-flashing': return 'All Red Flashing';
            default: return modelType;
        }
    }
    // Update traffic control model
    updateTrafficControlModel() {
        if (!this.world)
            return;
        // Apply selected strategy
        this.world.applyTrafficControlStrategy(this.selectedTrafficControlModel);
        // Update indicator
        this.updateActiveModelIndicator(this.selectedTrafficControlModel);
    }
    // Update analytics display
    updateAnalytics() {
        if (!this.world)
            return;
        // Collect basic stats
        this.analytics = {
            totalCars: Object.keys(this.world.cars.all() || {}).length,
            averageSpeed: this.world.instantSpeed,
            totalIntersections: Object.keys(this.world.intersections.all() || {}).length,
            totalRoads: Object.keys(this.world.roads.all() || {}).length,
            simulationTime: this.world.time
        };
        // Update UI
        document.getElementById('active-cars').textContent = this.analytics.totalCars.toString();
        document.getElementById('simulation-time').textContent = this.analytics.simulationTime.toFixed(1) + 's';
        // Get KPI metrics
        const kpiMetrics = kpi_collector_1.kpiCollector.getMetrics(this.world.time);
        // Update KPI UI
        document.getElementById('total-vehicles').textContent = kpiMetrics.totalVehicles.toString();
        document.getElementById('completed-trips').textContent = kpiMetrics.completedTrips.toString();
        document.getElementById('average-speed').textContent = kpiMetrics.averageSpeed.toFixed(2) + ' m/s';
        document.getElementById('avg-wait-time').textContent = kpiMetrics.averageWaitTime.toFixed(1) + 's';
        document.getElementById('max-wait-time').textContent = kpiMetrics.maxWaitTime.toFixed(1) + 's';
        document.getElementById('total-stops').textContent = kpiMetrics.totalStops.toString();
    }
    // Save benchmark results
    async saveBenchmarkResults() {
        try {
            if (!this.benchmarkResults) {
                this.showNotification('No benchmark results to save', 'warning');
                return;
            }
            // Save as analytics
            await AppState_1.appState.storage.saveAnalytics({
                type: 'benchmark',
                data: this.benchmarkResults
            });
            // Show success notification
            this.showNotification('Benchmark results saved successfully', 'success');
        }
        catch (error) {
            console.error('Failed to save benchmark results:', error);
            this.showNotification('Failed to save benchmark results', 'error');
        }
    }
    /**
     * Saves current simulation analytics data
     */
    async saveAnalytics() {
        try {
            if (!this.world) {
                this.showNotification('No simulation data to save', 'warning');
                return;
            }
            // Generate filename based on time
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const filename = `traffic-sim-analytics-${timestamp}.json`;
            // Get KPI metrics
            const kpiMetrics = kpi_collector_1.kpiCollector.getMetrics(this.world.time);
            // Create and save analytics data
            const analyticsData = {
                timestamp: new Date().toISOString(),
                metrics: {
                    ...this.analytics,
                    kpi: kpiMetrics
                },
                layout: {
                    intersections: this.world.intersections.length,
                    roads: this.world.roads.length
                },
                settings: {
                    carsNumber: this.world.carsNumber,
                    trafficControlModel: this.selectedTrafficControlModel
                }
            };
            // Save to storage
            await AppState_1.appState.storage.saveAnalytics(analyticsData);
            // Show success message
            this.showNotification('Analytics saved successfully', 'success');
        }
        catch (error) {
            console.error('Failed to save analytics:', error);
            this.showNotification('Failed to save analytics', 'error');
        }
    }
    // Adds necessary styles for the UI
    addStyles() {
        const styleElement = document.createElement('style');
        styleElement.textContent = `
      .simulation-page {
        display: flex;
        flex-direction: column;
        height: 100%;
      }
      
      .page-header {
        padding: 1rem;
        background-color: #2c2c2c;
        color: #fff;
      }
      
      .page-header h2 {
        margin: 0;
        font-size: 1.5rem;
      }
      
      .page-header p {
        margin: 0.5rem 0 0;
        color: #aaa;
      }
      
      .simulation-content {
        display: flex;
        flex: 1;
        min-height: 0;
      }
      
      .sidebar {
        width: 300px;
        background-color: #1e1e1e;
        padding: 1rem;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }
      
      .visualization-area {
        flex: 1;
        position: relative;
        overflow: hidden;
        background-color: #333;
      }
      
      #simulation-canvas {
        width: 100%;
        height: 100%;
        display: block;
      }
      
      .panel {
        background-color: #252525;
        border-radius: 6px;
        padding: 1rem;
      }
      
      .panel h3 {
        margin-top: 0;
        margin-bottom: 15px;
        font-size: 16px;
        color: #eee;
        border-bottom: 1px solid #444;
        padding-bottom: 8px;
      }
      
      .control-group {
        margin-bottom: 15px;
      }
      
      .control-group label {
        display: block;
        margin-bottom: 5px;
        color: #ccc;
        font-size: 13px;
      }
      
      .text-muted {
        color: #888;
      }
      
      .btn {
        display: inline-block;
        font-weight: 400;
        text-align: center;
        white-space: nowrap;
        vertical-align: middle;
        user-select: none;
        padding: 0.375rem 0.75rem;
        font-size: 0.9rem;
        line-height: 1.5;
        border: 1px solid transparent;
        border-radius: 4px;
      }
      
      .btn-block {
        display: block;
        width: 100%;
      }
      
      .btn-primary { background-color: #375a7f; color: white; border: 1px solid #375a7f; }
      .btn-primary:hover { background-color: #2e4c6d; }
      .btn-success { background-color: #00bc8c; color: white; border: 1px solid #00bc8c; }
      .btn-success:hover { background-color: #00a085; }
      .btn-info { background-color: #3498db; color: white; border: 1px solid #3498db; }
      .btn-info:hover { background-color: #2980b9; }
      .btn-warning { background-color: #f39c12; color: #212529; border: 1px solid #f39c12; }
      .btn-warning:hover { background-color: #e67e22; }
      .btn-secondary { background-color: #444444; color: white; border: 1px solid #666666; }
      .btn-secondary:hover { background-color: #555555; }
      .btn-danger { background-color: #e74c3c; color: white; border: 1px solid #e74c3c; }
      .btn-danger:hover { background-color: #d62c1a; }
      
      .slider {
        width: 100%;
      }
      
      .analytics {
        margin-top: 15px;
        padding: 10px;
        background-color: #2a2a2a;
        border-radius: 5px;
      }
      
      .analytics-section {
        margin-bottom: 15px;
        padding-bottom: 10px;
        border-bottom: 1px solid #444;
      }
      
      .analytics-section:last-child {
        border-bottom: none;
        margin-bottom: 5px;
      }
      
      .analytics-section h4 {
        margin: 0 0 8px 0;
        font-size: 14px;
        color: #aaa;
      }
      
      .metric {
        display: flex;
        justify-content: space-between;
        margin-bottom: 5px;
        font-size: 13px;
      }
      
      .label {
        color: #ddd;
      }
      
      .value {
        font-weight: 500;
        color: #fff;
      }
      
      .analytics-actions {
        display: flex;
        gap: 8px;
        margin-top: 15px;
      }
      
      .analytics-actions .btn {
        flex: 1;
        font-size: 12px;
        padding: 8px;
      }
      
      .instructions {
        padding-left: 20px;
        margin-top: 0;
      }
      
      .instructions li {
        margin-bottom: 5px;
      }
      
      .analytics-dev-tools {
        margin-top: 15px;
        padding-top: 15px;
        border-top: 1px dashed #555;
      }
      
      .validation-output {
        margin-top: 10px;
        padding: 10px;
        background: #222;
        border-radius: 4px;
        border: 1px solid #444;
        max-height: 500px;
        overflow-y: auto;
      }
      
      .validation-output pre {
        margin: 0;
        font-family: monospace;
        font-size: 11px;
        white-space: pre-wrap;
        color: #ccc;
      }
      
      .validation-formatted {
        margin-bottom: 20px;
      }
      
      .validation-table {
        width: 100%;
        border-collapse: collapse;
        margin-bottom: 15px;
        font-size: 13px;
      }
      
      .validation-table th {
        background-color: #007bff;
        color: white;
        text-align: left;
        padding: 8px;
      }
      
      .validation-table td {
        padding: 6px 8px;
        border-bottom: 1px solid #444;
      }
      
      .validation-table tr:nth-child(even) {
        background-color: #2a2a2a;
      }
      
      .validation-error {
        background-color: #500 !important;
        color: #f88;
        font-weight: bold;
      }
      
      .validation-success {
        background-color: #052 !important;
        color: #8f8;
        font-weight: bold;
      }
      
      .active-model-indicator {
        display: inline-block;
        font-weight: bold;
        padding: 3px 8px;
        margin-bottom: 8px;
        border-radius: 4px;
        background-color: #333;
        border: 1px solid #555;
        color: #33ee33;
      }
      
      .model-status {
        margin-bottom: 5px;
        text-align: center;
      }
      
      #traffic-control-model {
        width: 100%;
        padding: 6px;
        background-color: #333;
        color: #fff;
        border: 1px solid #555;
        border-radius: 4px;
      }
      
      /* Scenario Dialog Styles */
      .dialog {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        z-index: 1000;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      
      .dialog-content {
        background-color: #333;
        border-radius: 8px;
        width: 90%;
        max-width: 600px;
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        color: #fff;
      }
      
      .dialog-header {
        padding: 15px;
        border-bottom: 1px solid #444;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      
      .dialog-header h3 {
        margin: 0;
        font-size: 18px;
      }
      
      .dialog-body {
        padding: 15px;
        max-height: 70vh;
        overflow-y: auto;
      }
      
      .close-btn {
        background: none;
        border: none;
        color: #ccc;
        font-size: 24px;
        cursor: pointer;
      }
      
      .close-btn:hover {
        color: #fff;
      }
      
      .form-group {
        margin-bottom: 15px;
      }
      
      .form-group label {
        display: block;
        margin-bottom: 5px;
        color: #ccc;
      }
      
      .form-control {
        width: 100%;
        padding: 8px 10px;
        background-color: #222;
        border: 1px solid #555;
        border-radius: 4px;
        color: #fff;
      }
      
      textarea.form-control {
        min-height: 100px;
        resize: vertical;
      }
      
      .form-actions {
        display: flex;
        justify-content: flex-end;
        gap: 10px;
        margin-top: 20px;
      }
      
      /* Tab styles */
      .tab-control {
        display: flex;
        border-bottom: 1px solid #444;
        margin-bottom: 15px;
      }
      
      .tab-btn {
        padding: 8px 15px;
        background-color: transparent;
        border: none;
        color: #ccc;
        cursor: pointer;
        border-bottom: 2px solid transparent;
      }
      
      .tab-btn.active {
        color: #fff;
        border-bottom-color: #007bff;
      }
      
      .tab-content {
        padding: 10px 0;
      }
      
      .list-container {
        max-height: 300px;
        overflow-y: auto;
        background-color: #222;
        border-radius: 4px;
        border: 1px solid #444;
      }
      
      .list-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px;
        border-bottom: 1px solid #333;
        cursor: pointer;
      }
      
      .list-item:last-child {
        border-bottom: none;
      }
      
      .list-item.selected {
        background-color: #2a5885;
      }
      
      .list-item:hover {
        background-color: #2a2a2a;
      }
      
      .list-item-title {
        font-weight: bold;
        color: #fff;
        margin-bottom: 3px;
      }
      
      .list-item-meta {
        font-size: 12px;
        color: #aaa;
      }
      
      .list-empty-message {
        padding: 15px;
        text-align: center;
        color: #888;
      }
      
      .btn-delete {
        background: none;
        border: none;
        color: #f55;
        font-size: 18px;
        cursor: pointer;
      }
      
      .current-scenario-info {
        font-size: 12px;
        padding: 5px 0;
        color: #33ee33;
      }
      
      /* Benchmark Results styles */
      .metrics-table {
        width: 100%;
        margin-bottom: 20px;
      }
      
      .metrics-row {
        display: flex;
        border-bottom: 1px solid #444;
        padding: 6px 0;
      }
      
      .metrics-row:last-child {
        border-bottom: none;
      }
      
      .metrics-label {
        width: 40%;
        color: #aaa;
        font-size: 14px;
      }
      
      .metrics-value {
        width: 60%;
        color: #fff;
        font-size: 14px;
        font-weight: 500;
      }
    `;
        document.head.appendChild(styleElement);
    }
    // Clean up resources when component is destroyed
    destroy() {
        console.log('🧹 Simulation: Destroying page and cleaning up resources...');
        // Stop the simulation if running
        if (this.isRunning) {
            this.stop();
        }
        // Clean up KPI visualization
        if (this.kpiVisualization) {
            this.kpiVisualization.destroy();
            this.kpiVisualization = null;
        }
        // Clean up world
        if (this.world) {
            this.world.clear();
            this.world = null;
        }
        // Clean up visualizer
        if (this.visualizer) {
            if (typeof this.visualizer.destroy === 'function') {
                this.visualizer.destroy();
            }
            this.visualizer = null;
        }
        // Clean up GUI
        if (this.gui) {
            this.gui.destroy();
            this.gui = null;
        }
        // Remove event listeners
        window.removeEventListener('resize', this.handleResize);
        console.log('✅ Simulation: Page destroyed and cleaned up');
    }
}
exports.SimulationPageComponent = SimulationPageComponent;


/***/ }),

/***/ "./src/settings.ts":
/*!*************************!*\
  !*** ./src/settings.ts ***!
  \*************************/
/***/ ((module) => {

"use strict";

const settings = {
    colors: {
        background: '#97a1a1',
        redLight: 'hsl(0, 100%, 50%)',
        greenLight: '#85ee00',
        intersection: '#586970',
        road: '#586970',
        roadMarking: '#bbb',
        hoveredIntersection: '#3d4c53',
        tempRoad: '#aaa',
        gridPoint: '#586970',
        grid1: 'rgba(255, 255, 255, 0.5)',
        grid2: 'rgba(220, 220, 220, 0.5)',
        hoveredGrid: '#f4e8e1'
    },
    fps: 30,
    lightsFlipInterval: 160,
    gridSize: 14,
    defaultTimeFactor: 5
};
module.exports = settings;


/***/ }),

/***/ "./src/tests/TestCase.ts":
/*!*******************************!*\
  !*** ./src/tests/TestCase.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TestCase = void 0;
/**
 * Base class for test cases in Road Traffic Simulator
 *
 * Provides assertion methods and test lifecycle hooks
 */
class TestCase {
    /**
     * Set up the test environment before each test method
     */
    setUp() {
        // Default implementation does nothing
    }
    /**
     * Clean up the test environment after each test method
     */
    tearDown() {
        // Default implementation does nothing
    }
    /**
     * Assert that a condition is true
     */
    assertTrue(condition, message) {
        if (!condition) {
            throw new Error(message || 'Assertion failed: expected true but got false');
        }
    }
    /**
     * Assert that a condition is false
     */
    assertFalse(condition, message) {
        if (condition) {
            throw new Error(message || 'Assertion failed: expected false but got true');
        }
    }
    /**
     * Assert that two values are equal
     */
    assertEqual(actual, expected, message) {
        if (actual !== expected) {
            throw new Error(message || `Assertion failed: expected ${expected} but got ${actual}`);
        }
    }
    /**
     * Assert that two values are not equal
     */
    assertNotEqual(actual, expected, message) {
        if (actual === expected) {
            throw new Error(message || `Assertion failed: expected different value than ${expected}`);
        }
    }
    /**
     * Assert that a value is null
     */
    assertNull(value, message) {
        if (value !== null) {
            throw new Error(message || `Assertion failed: expected null but got ${value}`);
        }
    }
    /**
     * Assert that a value is not null
     */
    assertNotNull(value, message) {
        if (value === null) {
            throw new Error(message || 'Assertion failed: expected non-null value but got null');
        }
    }
    /**
     * Assert that a value is undefined
     */
    assertUndefined(value, message) {
        if (value !== undefined) {
            throw new Error(message || `Assertion failed: expected undefined but got ${value}`);
        }
    }
    /**
     * Assert that a value is not undefined
     */
    assertDefined(value, message) {
        if (value === undefined) {
            throw new Error(message || 'Assertion failed: expected defined value but got undefined');
        }
    }
    /**
     * Assert that an array contains an item
     */
    assertContains(array, item, message) {
        if (array.indexOf(item) === -1) {
            throw new Error(message || `Assertion failed: array does not contain ${item}`);
        }
    }
    /**
     * Assert that an array does not contain an item
     */
    assertNotContains(array, item, message) {
        if (array.indexOf(item) !== -1) {
            throw new Error(message || `Assertion failed: array should not contain ${item}`);
        }
    }
    /**
     * Assert that a string contains a substring
     */
    assertStringContains(str, substring, message) {
        if (str.indexOf(substring) === -1) {
            throw new Error(message || `Assertion failed: "${str}" does not contain "${substring}"`);
        }
    }
    /**
     * Assert that a string does not contain a substring
     */
    assertStringNotContains(str, substring, message) {
        if (str.indexOf(substring) !== -1) {
            throw new Error(message || `Assertion failed: "${str}" should not contain "${substring}"`);
        }
    }
    /**
     * Assert that a value is approximately equal to another value within a tolerance
     */
    assertApproximateEqual(actual, expected, tolerance = 0.001, message) {
        if (Math.abs(actual - expected) > tolerance) {
            throw new Error(message || `Assertion failed: ${actual} is not approximately equal to ${expected} within tolerance ${tolerance}`);
        }
    }
    /**
     * Assert that a function throws an error
     */
    assertThrows(fn, expectedErrorType, message) {
        try {
            fn();
            throw new Error(message || 'Assertion failed: function did not throw an error');
        }
        catch (error) {
            if (expectedErrorType && !(error instanceof expectedErrorType)) {
                throw new Error(message || `Assertion failed: function threw ${error} which is not an instance of ${expectedErrorType}`);
            }
        }
    }
    /**
     * Assert that a function does not throw an error
     */
    assertDoesNotThrow(fn, message) {
        try {
            fn();
        }
        catch (error) {
            throw new Error(message || `Assertion failed: function threw unexpected error: ${error}`);
        }
    }
    /**
     * Skip a test with a message
     */
    skip(message) {
        throw new SkipTestError(message || 'Test skipped');
    }
}
exports.TestCase = TestCase;
/**
 * Custom error class for skipped tests
 */
class SkipTestError extends Error {
    constructor(message) {
        super(message);
        this.name = 'SkipTestError';
    }
}


/***/ }),

/***/ "./src/visualizer/graphics.ts":
/*!************************************!*\
  !*** ./src/visualizer/graphics.ts ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! ../helpers */ "./src/helpers.ts");
const { PI } = Math;
class Graphics {
    constructor(ctx) {
        this.ctx = ctx;
    }
    fillRect(rect, style, alpha) {
        if (style) {
            this.ctx.fillStyle = style;
        }
        const _alpha = this.ctx.globalAlpha;
        if (alpha !== undefined) {
            this.ctx.globalAlpha = alpha;
        }
        this.ctx.fillRect(rect.left(), rect.top(), rect.width(), rect.height());
        this.ctx.globalAlpha = _alpha;
    }
    drawRect(rect) {
        const vertices = rect.getVertices();
        this.ctx.beginPath();
        this.moveTo(vertices[0]);
        for (let i = 1; i < vertices.length; i++) {
            this.lineTo(vertices[i]);
        }
        this.ctx.closePath();
    }
    drawImage(image, rect) {
        this.ctx.drawImage(image, rect.left(), rect.top(), rect.width(), rect.height());
    }
    clear(color) {
        try {
            this.ctx.fillStyle = color;
            this.ctx.fillRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
        }
        catch (error) {
            console.error('🎨 [GRAPHICS ERROR] clear() failed:', error);
            throw error;
        }
    }
    moveTo(point) {
        this.ctx.moveTo(point.x, point.y);
    }
    lineTo(point) {
        this.ctx.lineTo(point.x, point.y);
    }
    drawLine(source, target) {
        this.ctx.beginPath();
        this.moveTo(source);
        this.lineTo(target);
    }
    drawSegment(segment) {
        this.drawLine(segment.source, segment.target);
    }
    drawCurve(curve, width, color) {
        const pointsNumber = 10;
        if (width) {
            this.ctx.lineWidth = width;
        }
        this.ctx.beginPath();
        this.moveTo(curve.getPoint(0));
        for (let i = 0; i <= pointsNumber; i++) {
            const point = curve.getPoint(i / pointsNumber);
            this.lineTo(point);
        }
        if (curve.O) {
            this.moveTo(curve.O);
            this.ctx.arc(curve.O.x, curve.O.y, width || 1, 0, 2 * PI);
        }
        if (curve.Q) {
            this.moveTo(curve.Q);
            this.ctx.arc(curve.Q.x, curve.Q.y, width || 1, 0, 2 * PI);
        }
        if (color) {
            this.stroke(color);
        }
    }
    drawTriangle(p1, p2, p3) {
        this.ctx.beginPath();
        this.moveTo(p1);
        this.lineTo(p2);
        this.lineTo(p3);
    }
    fill(style, alpha) {
        this.ctx.fillStyle = style;
        const _alpha = this.ctx.globalAlpha;
        if (alpha !== undefined) {
            this.ctx.globalAlpha = alpha;
        }
        this.ctx.fill();
        this.ctx.globalAlpha = _alpha;
    }
    stroke(style) {
        this.ctx.strokeStyle = style;
        this.ctx.stroke();
    }
    polyline(...points) {
        if (points.length >= 1) {
            this.ctx.beginPath();
            this.moveTo(points[0]);
            for (let i = 1; i < points.length; i++) {
                this.lineTo(points[i]);
            }
            this.ctx.closePath();
        }
    }
    save() {
        this.ctx.save();
    }
    restore() {
        this.ctx.restore();
    }
}
module.exports = Graphics;


/***/ }),

/***/ "./src/visualizer/highlighter.ts":
/*!***************************************!*\
  !*** ./src/visualizer/highlighter.ts ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! ../helpers */ "./src/helpers.ts");
const Tool = __webpack_require__(/*! ./tool */ "./src/visualizer/tool.ts");
const settings = __webpack_require__(/*! ../settings */ "./src/settings.ts");
class ToolHighlighter extends Tool {
    constructor(visualizer, autobind) {
        super(visualizer, autobind);
        this.hoveredCell = null;
    }
    mousemove(e) {
        try {
            // Skip if visualizer or world are unavailable
            if (!this.visualizer || !this.visualizer.world || !this.visualizer.world.intersections) {
                this.hoveredCell = null; // Reset the hover state if world isn't ready
                return;
            }
            // Get cell safely
            const cell = this.getCell(e);
            if (!cell) {
                this.hoveredCell = null; // Reset if no cell detected
                return;
            }
            // Only update if cell actually changed
            if (this.hoveredCell &&
                this.hoveredCell.x === cell.x &&
                this.hoveredCell.y === cell.y) {
                return; // Skip if cell hasn't changed to avoid redundant processing
            }
            // Update hovered cell
            this.hoveredCell = cell;
            // Find intersection under hover
            const hoveredIntersection = this.getHoveredIntersection(cell);
            // Safely get intersections with extra verification
            try {
                const intersections = this.visualizer.world.intersections.all() || {};
                // Reset all intersection colors
                for (const id in intersections) {
                    if (intersections[id]) {
                        intersections[id].color = null;
                    }
                }
                // Set color for hovered intersection
                if (hoveredIntersection) {
                    hoveredIntersection.color = settings.colors.hoveredIntersection;
                }
                // Force a single redraw if visualizer exists but don't start animation loop
                if (this.visualizer.drawSingleFrame && !this.visualizer.running) {
                    this.visualizer.drawSingleFrame();
                }
            }
            catch (innerError) {
                console.error('🔧 [HIGHLIGHTER ERROR] Error handling intersections:', innerError);
                // Reset state on error
                this.hoveredCell = null;
            }
        }
        catch (error) {
            console.error('🔧 [HIGHLIGHTER ERROR] mousemove failed:', error);
            this.hoveredCell = null; // Reset on error
        }
    }
    mouseout(e) {
        try {
            // Clear hover state
            this.hoveredCell = null;
            // Reset intersection colors
            if (this.visualizer && this.visualizer.world && this.visualizer.world.intersections) {
                const intersections = this.visualizer.world.intersections.all();
                for (const id in intersections) {
                    if (intersections[id]) {
                        intersections[id].color = null;
                    }
                }
                // Force a single redraw if visualizer exists but don't start animation loop
                if (this.visualizer.drawSingleFrame && !this.visualizer.running) {
                    this.visualizer.drawSingleFrame();
                }
            }
        }
        catch (error) {
            console.error('🔧 [HIGHLIGHTER ERROR] mouseout failed:', error);
        }
    }
    reset() {
        try {
            // Clear hover state
            this.hoveredCell = null;
            // Clear any intersection colors
            if (this.visualizer && this.visualizer.world && this.visualizer.world.intersections) {
                const intersections = this.visualizer.world.intersections.all();
                for (const id in intersections) {
                    if (intersections[id]) {
                        intersections[id].color = null;
                    }
                }
            }
        }
        catch (error) {
            console.error('🔧 [HIGHLIGHTER ERROR] reset failed:', error);
        }
    }
    draw() {
        try {
            // Safely check all needed components before drawing
            if (this.hoveredCell &&
                this.visualizer &&
                this.visualizer.graphics &&
                typeof this.visualizer.graphics.fillRect === 'function') {
                const color = settings.colors.hoveredGrid;
                this.visualizer.graphics.fillRect(this.hoveredCell, color, 0.5);
            }
        }
        catch (error) {
            console.error('🔧 [HIGHLIGHTER ERROR] draw failed:', error);
            // Reset state on error to prevent future errors
            this.hoveredCell = null;
        }
    }
}
module.exports = ToolHighlighter;


/***/ }),

/***/ "./src/visualizer/intersection-builder.ts":
/*!************************************************!*\
  !*** ./src/visualizer/intersection-builder.ts ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! ../helpers */ "./src/helpers.ts");
const Tool = __webpack_require__(/*! ./tool */ "./src/visualizer/tool.ts");
const Intersection = __webpack_require__(/*! ../model/intersection */ "./src/model/intersection.ts");
const Point = __webpack_require__(/*! ../geom/point */ "./src/geom/point.ts");
class ToolIntersectionBuilder extends Tool {
    constructor(visualizer, autobind) {
        super(visualizer, autobind);
        this.tempIntersection = null;
        this.mouseDownPos = null;
    }
    mousedown(e) {
        // Don't allow intersection creation in simulation mode
        if (!this.visualizer.isBuilderMode) {
            return;
        }
        // Simple shift key detection like the original
        if (e.shiftKey) {
            console.log('🟡 SHIFT+CLICK detected - creating intersection');
            const rawPoint = new Point(e.clientX - this.canvas.getBoundingClientRect().left, e.clientY - this.canvas.getBoundingClientRect().top);
            const cell = this.getCell(e);
            console.log('🟡 Raw click point:', rawPoint.x, rawPoint.y);
            console.log('🟡 Converted to cell:', cell.x, cell.y, cell.width(), cell.height());
            this.mouseDownPos = cell;
            // Create intersection exactly like the original
            this.tempIntersection = new Intersection(this.mouseDownPos);
            console.log('🟡 Created temp intersection with rect:', this.tempIntersection.rect.x, this.tempIntersection.rect.y);
            // Prevent other tools from handling this event
            e.stopImmediatePropagation();
        }
    }
    mouseup(e) {
        // Don't allow intersection creation in simulation mode
        if (!this.visualizer.isBuilderMode) {
            return;
        }
        if (this.tempIntersection) {
            console.log('🟡 IntersectionBuilder: Finalizing intersection creation');
            console.log('🟡 Final intersection rect:', this.tempIntersection.rect.x, this.tempIntersection.rect.y, this.tempIntersection.rect.width(), this.tempIntersection.rect.height());
            // Check intersection count before adding
            const beforeCount = Object.keys(this.visualizer.world.intersections.all()).length;
            console.log('🟡 Intersection count before adding:', beforeCount);
            // Add intersection immediately - no setTimeout delay
            this.visualizer.world.addIntersection(this.tempIntersection);
            // Check intersection count after adding
            const afterCount = Object.keys(this.visualizer.world.intersections.all()).length;
            console.log('🟡 Intersection count after adding:', afterCount);
            // Force immediate redraw regardless of running state
            this.visualizer.drawSingleFrame();
            this.tempIntersection = null;
        }
        this.mouseDownPos = null;
    }
    mousemove(e) {
        if (this.tempIntersection) {
            const currentCell = this.getCell(e);
            // Only resize if we're dragging, preserve minimum size
            if (this.mouseDownPos && (currentCell.x !== this.mouseDownPos.x || currentCell.y !== this.mouseDownPos.y)) {
                const rect = this.visualizer.zoomer.getBoundingBox(this.mouseDownPos, currentCell);
                // Ensure minimum size is maintained
                rect.width(Math.max(rect.width(), 56));
                rect.height(Math.max(rect.height(), 56));
                this.tempIntersection.rect = rect;
            }
        }
    }
    mouseout(e) {
        this.mouseDownPos = null;
        this.tempIntersection = null;
    }
    draw() {
        if (this.tempIntersection) {
            this.visualizer.drawIntersection(this.tempIntersection, 0.4);
        }
    }
}
module.exports = ToolIntersectionBuilder;


/***/ }),

/***/ "./src/visualizer/intersection-mover.ts":
/*!**********************************************!*\
  !*** ./src/visualizer/intersection-mover.ts ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! ../helpers */ "./src/helpers.ts");
const Tool = __webpack_require__(/*! ./tool */ "./src/visualizer/tool.ts");
class ToolIntersectionMover extends Tool {
    constructor(visualizer, autobind) {
        super(visualizer, autobind);
        this.intersection = null;
    }
    mousedown(e) {
        // Don't allow intersection moving in simulation mode
        if (!this.visualizer.isBuilderMode) {
            return;
        }
        const intersection = this.getHoveredIntersection(this.getCell(e));
        if (intersection) {
            this.intersection = intersection;
            e.stopImmediatePropagation();
        }
    }
    mouseup(e) {
        this.intersection = null;
    }
    mousemove(e) {
        // Don't allow intersection moving in simulation mode
        if (!this.visualizer.isBuilderMode) {
            return;
        }
        if (this.intersection) {
            const cell = this.getCell(e);
            this.intersection.rect.left(cell.x);
            this.intersection.rect.top(cell.y);
            this.intersection.update();
        }
    }
    mouseout(e) {
        this.intersection = null;
    }
    draw() {
        // No drawing needed for intersection mover tool
    }
}
module.exports = ToolIntersectionMover;


/***/ }),

/***/ "./src/visualizer/mover.ts":
/*!*********************************!*\
  !*** ./src/visualizer/mover.ts ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! ../helpers */ "./src/helpers.ts");
const Tool = __webpack_require__(/*! ./tool */ "./src/visualizer/tool.ts");
class ToolMover extends Tool {
    constructor(visualizer, autobind) {
        super(visualizer, autobind);
        this.startPosition = null;
    }
    contextmenu(e) {
        return false;
    }
    mousedown(e) {
        // Always handle mousedown like the original - let other tools stop propagation first
        this.startPosition = this.getPoint(e);
        e.stopImmediatePropagation();
    }
    mouseup(e) {
        this.startPosition = null;
    }
    mousemove(e) {
        if (this.startPosition) {
            const currentPosition = this.getPoint(e);
            const offset = currentPosition.subtract(this.startPosition);
            this.visualizer.zoomer.moveCenter(offset);
            this.startPosition = currentPosition;
        }
    }
    mouseout(e) {
        this.startPosition = null;
    }
    draw() {
        // No drawing needed for mover tool
    }
}
module.exports = ToolMover;


/***/ }),

/***/ "./src/visualizer/road-builder.ts":
/*!****************************************!*\
  !*** ./src/visualizer/road-builder.ts ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! ../helpers */ "./src/helpers.ts");
const Tool = __webpack_require__(/*! ./tool */ "./src/visualizer/tool.ts");
const Road = __webpack_require__(/*! ../model/road */ "./src/model/road.ts");
class ToolRoadBuilder extends Tool {
    constructor(visualizer, autobind) {
        super(visualizer, autobind);
        this.sourceIntersection = null;
        this.road = null;
        this.dualRoad = null;
    }
    mousedown(e) {
        // Don't allow road creation in simulation mode
        if (!this.visualizer.isBuilderMode) {
            return;
        }
        console.log('RoadBuilder mousedown - shift:', e.shiftKey);
        const cell = this.getCell(e);
        const hoveredIntersection = this.getHoveredIntersection(cell);
        console.log('Hovered intersection:', hoveredIntersection);
        if (e.shiftKey && hoveredIntersection) {
            console.log('Starting road from intersection:', hoveredIntersection.id);
            this.sourceIntersection = hoveredIntersection;
            e.stopImmediatePropagation();
        }
    }
    mouseup(e) {
        // Don't allow road creation in simulation mode
        if (!this.visualizer.isBuilderMode) {
            return;
        }
        if (this.road) {
            this.visualizer.world.addRoad(this.road);
        }
        if (this.dualRoad) {
            this.visualizer.world.addRoad(this.dualRoad);
        }
        this.road = this.dualRoad = this.sourceIntersection = null;
    }
    mousemove(e) {
        // Don't allow road creation in simulation mode
        if (!this.visualizer.isBuilderMode) {
            return;
        }
        const cell = this.getCell(e);
        const hoveredIntersection = this.getHoveredIntersection(cell);
        if (this.sourceIntersection && hoveredIntersection &&
            this.sourceIntersection.id !== hoveredIntersection.id) {
            if (this.road) {
                this.road.target = hoveredIntersection;
                this.dualRoad.source = hoveredIntersection;
            }
            else {
                this.road = new Road(this.sourceIntersection, hoveredIntersection);
                this.dualRoad = new Road(hoveredIntersection, this.sourceIntersection);
            }
        }
        else {
            this.road = this.dualRoad = null;
        }
    }
    mouseout(e) {
        this.road = this.dualRoad = this.sourceIntersection = null;
    }
    draw() {
        if (this.road) {
            this.visualizer.drawRoad(this.road, 0.4);
        }
        if (this.dualRoad) {
            this.visualizer.drawRoad(this.dualRoad, 0.4);
        }
    }
}
module.exports = ToolRoadBuilder;


/***/ }),

/***/ "./src/visualizer/tool.ts":
/*!********************************!*\
  !*** ./src/visualizer/tool.ts ***!
  \********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! ../helpers */ "./src/helpers.ts");
const $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
__webpack_require__(/*! jquery-mousewheel */ "./node_modules/jquery-mousewheel/jquery.mousewheel.js");
const Point = __webpack_require__(/*! ../geom/point */ "./src/geom/point.ts");
const METHODS = [
    'click',
    'mousedown',
    'mouseup',
    'mousemove',
    'mouseout',
    'mousewheel',
    'contextmenu'
];
class Tool {
    constructor(visualizer, autobind) {
        this.boundMethods = {};
        this.visualizer = visualizer;
        this.ctx = this.visualizer.ctx;
        this.canvas = this.ctx.canvas;
        this.isBound = false;
        if (autobind) {
            this.bind();
        }
    }
    bind() {
        this.isBound = true;
        for (const method of METHODS) {
            if (this[method]) {
                // We need to bind the methods to preserve 'this' context
                this.boundMethods[method] = this[method].bind(this);
                $(this.canvas).on(method, this.boundMethods[method]);
            }
        }
    }
    unbind() {
        this.isBound = false;
        for (const method of METHODS) {
            if (this.boundMethods[method]) {
                $(this.canvas).off(method, this.boundMethods[method]);
            }
        }
        this.boundMethods = {};
    }
    toggleState() {
        if (this.isBound) {
            this.unbind();
        }
        else {
            this.bind();
        }
    }
    draw() {
        // Override in subclasses
    }
    getPoint(e) {
        const rect = this.canvas.getBoundingClientRect();
        const point = new Point(e.clientX - rect.left, e.clientY - rect.top);
        // Reduced coordinate debugging - only log on shift+click
        if (e.shiftKey) {
            console.log('🎯 Shift+Click coordinate calculation:');
            console.log('  Event coords:', e.clientX, e.clientY);
            console.log('  Canvas rect:', rect.left, rect.top, rect.width, rect.height);
            console.log('  Canvas size:', this.canvas.width, this.canvas.height);
            console.log('  Calculated point:', point.x, point.y);
        }
        return point;
    }
    getCell(e) {
        return this.visualizer.zoomer.toCellCoords(this.getPoint(e));
    }
    getHoveredIntersection(cell) {
        const intersections = this.visualizer.world.intersections.all();
        for (const id in intersections) {
            const intersection = intersections[id];
            if (intersection.rect.containsRect(cell)) {
                return intersection;
            }
        }
        return null;
    }
}
module.exports = Tool;


/***/ }),

/***/ "./src/visualizer/visualizer.ts":
/*!**************************************!*\
  !*** ./src/visualizer/visualizer.ts ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! ../helpers */ "./src/helpers.ts");
const $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
const chroma = __webpack_require__(/*! chroma-js */ "./node_modules/chroma-js/dist/chroma.cjs");
const Point = __webpack_require__(/*! ../geom/point */ "./src/geom/point.ts");
const Rect = __webpack_require__(/*! ../geom/rect */ "./src/geom/rect.ts");
const Graphics = __webpack_require__(/*! ./graphics */ "./src/visualizer/graphics.ts");
const ToolMover = __webpack_require__(/*! ./mover */ "./src/visualizer/mover.ts");
const ToolIntersectionMover = __webpack_require__(/*! ./intersection-mover */ "./src/visualizer/intersection-mover.ts");
const ToolIntersectionBuilder = __webpack_require__(/*! ./intersection-builder */ "./src/visualizer/intersection-builder.ts");
const ToolRoadBuilder = __webpack_require__(/*! ./road-builder */ "./src/visualizer/road-builder.ts");
const ToolHighlighter = __webpack_require__(/*! ./highlighter */ "./src/visualizer/highlighter.ts");
const Zoomer = __webpack_require__(/*! ./zoomer */ "./src/visualizer/zoomer.ts");
const settings = __webpack_require__(/*! ../settings */ "./src/settings.ts");
const Pool = __webpack_require__(/*! ../model/pool */ "./src/model/pool.ts");
const Car = __webpack_require__(/*! ../model/car */ "./src/model/car.ts");
const Road = __webpack_require__(/*! ../model/road */ "./src/model/road.ts");
const Intersection = __webpack_require__(/*! ../model/intersection */ "./src/model/intersection.ts");
const { PI } = Math;
class Visualizer {
    constructor(world, canvasId = 'canvas') {
        this.isBuilderMode = false; // New property to control simulation behavior
        this.toolCheckInterval = null; // Track interval to prevent duplicates
        this._errorCount = 0; // Track consecutive errors for error recovery
        this.draw = (time) => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
            // Calculate time delta - capped for stability
            const delta = (time - this.previousTime) || 0;
            // Process draw cycle at stable frame rate
            if (delta > 16) { // ~60fps target rate
                const adjustedDelta = Math.min(delta, 100); // Cap at 100ms for stability
                this.previousTime = time;
                try {
                    // FORCE complete transformation reset with fallback
                    if (this.ctx.resetTransform) {
                        this.ctx.resetTransform();
                    }
                    else {
                        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                    }
                    // Clear canvas with proper background color - ensure it's always clearing with the right color
                    this.graphics.clear(settings.colors.background);
                    this.ctx.save(); // Save the clean state
                    // Apply zoom transformation
                    if (this.zoomer) {
                        this.zoomer.transform();
                    }
                    // ALWAYS draw these elements regardless of simulation state
                    this.drawGrid();
                    // Step the world simulation if running in simulation mode
                    if (!this.isBuilderMode && this.running && this.world && this.world.onTick) {
                        try {
                            console.log('🎨 [SIM DEBUG] Calling world.onTick() with delta:', this.timeFactor * adjustedDelta / 1000);
                            console.log('🎨 [SIM DEBUG] Current carsNumber:', this.world.carsNumber);
                            console.log('🎨 [SIM DEBUG] Current cars count:', Object.keys(((_b = (_a = this.world) === null || _a === void 0 ? void 0 : _a.cars) === null || _b === void 0 ? void 0 : _b.all()) || {}).length);
                            this.world.onTick(this.timeFactor * adjustedDelta / 1000);
                            console.log('🎨 [SIM DEBUG] After onTick, cars count:', Object.keys(((_d = (_c = this.world) === null || _c === void 0 ? void 0 : _c.cars) === null || _d === void 0 ? void 0 : _d.all()) || {}).length);
                        }
                        catch (simError) {
                            console.error('🎨 [SIM ERROR] Error in simulation tick:', simError);
                            console.error('🎨 [SIM ERROR] Stack trace:', simError.stack);
                            // Continue rendering even if simulation step fails
                        }
                    }
                    // ALWAYS DRAW ALL WORLD OBJECTS, regardless of simulation state or errors
                    // This ensures we never get a black canvas during simulation
                    // Draw intersections
                    const intersections = ((_f = (_e = this.world) === null || _e === void 0 ? void 0 : _e.intersections) === null || _f === void 0 ? void 0 : _f.all()) || {};
                    for (const id in intersections) {
                        const intersection = intersections[id];
                        try {
                            if (intersection && typeof intersection === 'object') {
                                this.drawIntersection(intersection, 0.9);
                            }
                        }
                        catch (error) {
                            // Log but continue with other elements
                            console.error('🎨 [VIZ ERROR] Failed to draw intersection:', id, error);
                        }
                    }
                    // Draw roads
                    const roads = ((_h = (_g = this.world) === null || _g === void 0 ? void 0 : _g.roads) === null || _h === void 0 ? void 0 : _h.all()) || {};
                    for (const id in roads) {
                        const road = roads[id];
                        try {
                            if (road && typeof road === 'object') {
                                this.drawRoad(road, 0.9);
                            }
                        }
                        catch (error) {
                            // Log but continue with other elements
                            console.error('🎨 [VIZ ERROR] Failed to draw road:', id, error);
                        }
                    }
                    // Draw traffic signals for roads
                    for (const id in roads) {
                        const road = roads[id];
                        try {
                            if (road) {
                                this.drawSignals(road);
                            }
                        }
                        catch (error) {
                            // Log but continue with other elements
                            console.error('🎨 [VIZ ERROR] Failed to draw signals:', id, error);
                        }
                    }
                    // Draw cars - CRITICAL for simulation visibility
                    // Specifically handle cars in a way that avoids skipping them during simulation
                    try {
                        // Double check that cars collection exists and has vehicles
                        const cars = ((_k = (_j = this.world) === null || _j === void 0 ? void 0 : _j.cars) === null || _k === void 0 ? void 0 : _k.all()) || {};
                        const carCount = Object.keys(cars).length;
                        // Always try to draw cars, regardless of builder/simulation mode
                        // This ensures vehicles are visible during simulation
                        for (const id in cars) {
                            try {
                                if (cars[id]) {
                                    this.drawCar(cars[id]);
                                }
                            }
                            catch (carError) {
                                // Log but continue with other cars - don't let one bad car ruin everything
                                console.error('🎨 [VIZ ERROR] Failed to draw car:', id, carError);
                            }
                        }
                        // If in simulation mode but no cars were found, try to refresh them
                        if (!this.isBuilderMode && this.running && carCount === 0 && ((_l = this.world) === null || _l === void 0 ? void 0 : _l.refreshCars)) {
                            console.log('🎨 [VIZ DEBUG] No cars found in simulation mode, trying to refresh');
                            try {
                                this.world.refreshCars();
                            }
                            catch (refreshError) {
                                console.error('🎨 [VIZ ERROR] Failed to refresh cars:', refreshError);
                            }
                        }
                    }
                    catch (carsError) {
                        console.error('🎨 [VIZ ERROR] Error processing cars:', carsError);
                    }
                    // Draw builder tools last (only relevant in builder mode)
                    if (this.isBuilderMode) {
                        if (this.toolIntersectionBuilder && this.toolIntersectionBuilder.draw) {
                            this.toolIntersectionBuilder.draw();
                        }
                        if (this.toolRoadbuilder && this.toolRoadbuilder.draw) {
                            this.toolRoadbuilder.draw();
                        }
                        if (this.toolHighlighter && this.toolHighlighter.draw) {
                            this.toolHighlighter.draw();
                        }
                    }
                    this.ctx.restore(); // Restore to clean state
                }
                catch (error) {
                    console.error('🎨 [VIZ ERROR] ERROR in draw cycle:', error);
                    // Recovery: try to clear the canvas with the right color
                    try {
                        this.ctx.resetTransform();
                        this.graphics.clear(settings.colors.background);
                    }
                    catch (clearError) {
                        console.error('🎨 [VIZ ERROR] ERROR clearing canvas during recovery:', clearError);
                    }
                }
            }
            // ALWAYS request the next frame when running - this is critical for simulation
            if (this.running) {
                window.requestAnimationFrame(this.draw);
            }
        };
        this.world = world;
        // Ensure draw method is properly bound to this instance
        this.draw = this.draw.bind(this);
        // Get the canvas that should exist (created by page component)
        this.$canvas = $(`#${canvasId}`);
        this.canvas = this.$canvas[0];
        // Canvas setup
        if (!this.canvas) {
            console.error(`❌ Canvas element with id "${canvasId}" not found!`);
            throw new Error(`Canvas element with id "${canvasId}" not found`);
        }
        this.ctx = this.canvas.getContext('2d');
        if (!this.ctx) {
            console.error('❌ Canvas 2D context not available!');
            throw new Error('Could not get 2D context from canvas');
        }
        this.carImage = new Image();
        this.carImage.src = 'images/car.png';
        this.updateCanvasSize();
        this.zoomer = new Zoomer(4, this, true);
        this.graphics = new Graphics(this.ctx);
        // IMPORTANT: Create tools in correct order - mover must be created LAST so it's the fallback
        this.toolRoadbuilder = new ToolRoadBuilder(this, false); // Don't autobind in simulation mode
        this.toolIntersectionBuilder = new ToolIntersectionBuilder(this, false); // Don't autobind in simulation mode
        this.toolHighlighter = new ToolHighlighter(this, true); // Always allow highlighting
        this.toolIntersectionMover = new ToolIntersectionMover(this, false); // Don't autobind in simulation mode
        // Mover is ALWAYS enabled to allow panning in both builder and simulation modes
        this.toolMover = new ToolMover(this, true);
        // Set up more robust event binding that persists across page state changes
        this.ensureToolsAreBound();
        this._running = false;
        this.previousTime = 0;
        this.timeFactor = settings.defaultTimeFactor;
        this.debug = {
            enabled: false,
            showIds: false,
            showIntersections: true
        };
        // Add window resize listener
        $(window).on('resize', () => {
            this.updateCanvasSize();
        });
    }
    drawIntersection(intersection, alpha) {
        try {
            if (!intersection) {
                console.warn('🎨 [VIZ WARN] Invalid intersection passed to drawIntersection');
                return;
            }
            if (!intersection.rect) {
                console.warn('🎨 [VIZ WARN] Intersection missing rect:', intersection.id);
                return;
            }
            const color = intersection.color || settings.colors.intersection;
            this.graphics.drawRect(intersection.rect);
            this.ctx.lineWidth = 0.4;
            this.graphics.stroke(settings.colors.roadMarking);
            this.graphics.fillRect(intersection.rect, color, alpha);
            // Debug information display for intersections
            if (this.debug && this.debug.enabled) {
                this.ctx.save();
                this.ctx.fillStyle = "white";
                this.ctx.font = "1.2px Arial";
                this.ctx.textAlign = "center";
                const center = intersection.rect.center();
                // Display intersection ID if debug is enabled and showIds is true
                if (this.debug.showIds) {
                    // Show shortened ID for cleaner display
                    this.ctx.fillText(intersection.id.slice(-3), center.x, center.y - 1);
                }
                // Show traffic light timing info if debug.showIntersections is true
                if (this.debug.showIntersections) {
                    if (intersection.trafficLightController) {
                        // Show strategy type and phase for new controllers
                        const strategy = intersection.trafficLightController.getStrategy();
                        const strategyType = strategy.strategyType;
                        const phase = strategy.getCurrentPhase();
                        const totalPhases = strategy.getTotalPhases();
                        this.ctx.fillText(`${strategyType}|${phase + 1}/${totalPhases}`, center.x, center.y + 1);
                    }
                    else if (intersection.controlSignals &&
                        intersection.controlSignals.flipInterval &&
                        intersection.controlSignals.phaseOffset) {
                        // Fallback for legacy control signals
                        const flipInterval = Math.round(intersection.controlSignals.flipInterval * 10) / 10;
                        const phaseOffset = Math.round(intersection.controlSignals.phaseOffset * 10) / 10;
                        this.ctx.fillText(`${flipInterval}|${phaseOffset}`, center.x, center.y + 1);
                    }
                }
                this.ctx.restore();
            }
        }
        catch (error) {
            console.error('🎨 [VIZ ERROR] Failed to draw intersection:', intersection === null || intersection === void 0 ? void 0 : intersection.id, error);
            throw error;
        }
    }
    drawSignals(road) {
        // Comprehensive safety checks to prevent errors
        try {
            if (!road || !road.target || !road.targetSide || road.targetSideId === undefined) {
                return;
            }
            const intersection = road.target;
            if (!intersection) {
                return;
            }
            const segment = road.targetSide;
            const sideId = road.targetSideId;
            if (!segment || !segment.center || !segment.length) {
                return;
            }
            // Get signals from the new traffic light controller if available, otherwise fall back to legacy
            let lights;
            if (intersection.trafficLightController) {
                lights = intersection.getSignalState()[sideId];
            }
            else if (intersection.controlSignals && intersection.controlSignals.state) {
                lights = intersection.controlSignals.state[sideId];
            }
            else {
                return;
            }
            if (!lights || !Array.isArray(lights)) {
                return;
            }
            this.ctx.save();
            this.ctx.translate(segment.center.x, segment.center.y);
            this.ctx.rotate((sideId + 1) * PI / 2);
            this.ctx.scale(1 * segment.length, 1 * segment.length);
            // map lane ending to [(0, -0.5), (0, 0.5)]
            if (lights[0]) {
                this.graphics.drawTriangle(new Point(0.1, -0.2), new Point(0.2, -0.4), new Point(0.3, -0.2));
                this.graphics.fill(settings.colors.greenLight);
            }
            if (lights[1]) {
                this.graphics.drawTriangle(new Point(0.3, -0.1), new Point(0.5, 0), new Point(0.3, 0.1));
                this.graphics.fill(settings.colors.greenLight);
            }
            if (lights[2]) {
                this.graphics.drawTriangle(new Point(0.1, 0.2), new Point(0.2, 0.4), new Point(0.3, 0.2));
                this.graphics.fill(settings.colors.greenLight);
            }
            this.ctx.restore();
            if (this.debug) {
                this.ctx.save();
                this.ctx.fillStyle = "black";
                this.ctx.font = "1px Arial";
                const center = intersection.rect.center();
                if (intersection.controlSignals.flipInterval && intersection.controlSignals.phaseOffset) {
                    const flipInterval = Math.round(intersection.controlSignals.flipInterval * 100) / 100;
                    const phaseOffset = Math.round(intersection.controlSignals.phaseOffset * 100) / 100;
                    this.ctx.fillText(flipInterval + ' ' + phaseOffset, center.x, center.y);
                }
                this.ctx.restore();
            }
        }
        catch (error) {
            // Silently handle drawing errors to prevent console spam
        }
    }
    drawRoad(road, alpha) {
        try {
            if (!road) {
                console.warn('🎨 [VIZ WARN] Invalid road passed to drawRoad');
                return;
            }
            if (!road.source || !road.target) {
                console.error('🎨 [VIZ ERROR] Road missing source or target:', road.id, {
                    source: !!road.source,
                    target: !!road.target
                });
                throw new Error('invalid road');
            }
            const sourceSide = road.sourceSide;
            const targetSide = road.targetSide;
            this.ctx.save();
            this.ctx.lineWidth = 0.4;
            const leftLine = road.leftmostLane.leftBorder;
            this.graphics.drawSegment(leftLine);
            this.graphics.stroke(settings.colors.roadMarking);
            const rightLine = road.rightmostLane.rightBorder;
            this.graphics.drawSegment(rightLine);
            this.graphics.stroke(settings.colors.roadMarking);
            this.ctx.restore();
            this.graphics.polyline(sourceSide.source, sourceSide.target, targetSide.source, targetSide.target);
            this.graphics.fill(settings.colors.road, alpha);
            this.ctx.save();
            for (let i = 1; i < road.lanes.length; i++) {
                const lane = road.lanes[i];
                const line = lane.rightBorder;
                const dashSize = 1;
                this.graphics.drawSegment(line);
                this.ctx.lineWidth = 0.2;
                this.ctx.lineDashOffset = 1.5 * dashSize;
                this.ctx.setLineDash([dashSize]);
                this.graphics.stroke(settings.colors.roadMarking);
            }
            this.ctx.restore();
        }
        catch (error) {
            console.error('🎨 [VIZ ERROR] Failed to draw road:', road === null || road === void 0 ? void 0 : road.id, error);
            throw error;
        }
    }
    drawCar(car) {
        var _a, _b;
        try {
            // Safety checks to avoid errors
            if (!car || !car.coords || car.direction === undefined) {
                console.warn('🎨 [VIZ WARN] Invalid car data in drawCar');
                return;
            }
            const angle = car.direction;
            const center = car.coords;
            const rect = new Rect(0, 0, 1.1 * car.length, 1.7 * car.width);
            rect.center(new Point(0, 0));
            const boundRect = new Rect(0, 0, car.length, car.width);
            boundRect.center(new Point(0, 0));
            this.graphics.save();
            this.ctx.translate(center.x, center.y);
            this.ctx.rotate(angle);
            // Calculate color - ensure we have valid values to prevent black cars
            let style = '#FF0000'; // Default to red if there's an issue
            try {
                // Make sure speed and maxSpeed are numbers to prevent NaN issues
                const speed = typeof car.speed === 'number' ? car.speed : 0;
                const maxSpeed = typeof car.maxSpeed === 'number' && car.maxSpeed > 0 ? car.maxSpeed : 1;
                // Calculate a luminance value that can't go too dark
                const l = Math.max(0.4, 0.90 - 0.30 * speed / maxSpeed);
                // Use the car's color or a default if not present
                const carColor = car.color || '#3388FF';
                style = chroma(carColor, 0.8, l, 'hsl').hex();
            }
            catch (colorError) {
                // Fallback to a visible color if there's an issue with chroma
                style = '#FF4433';
            }
            // Draw the car with the calculated or fallback style
            this.graphics.fillRect(boundRect, style);
            this.graphics.restore();
            if (this.debug) {
                this.ctx.save();
                this.ctx.fillStyle = "black";
                this.ctx.font = "1px Arial";
                this.ctx.fillText(car.id.toString(), center.x, center.y);
                const curve = (_b = (_a = car.trajectory) === null || _a === void 0 ? void 0 : _a.temp) === null || _b === void 0 ? void 0 : _b.lane;
                if (curve) {
                    this.graphics.drawCurve(curve, 0.1, 'red');
                }
                this.ctx.restore();
            }
        }
        catch (error) {
            console.error('🎨 [VIZ ERROR] Error in drawCar:', error);
            // Continue execution - don't let one car crash the whole render
        }
    }
    drawGrid() {
        const gridSize = settings.gridSize;
        // Calculate grid bounds that will be visible on screen
        const halfWidth = this.canvas.width / 2;
        const halfHeight = this.canvas.height / 2;
        const scale = this.zoomer.scale * this.zoomer.defaultZoom;
        // Calculate visible world coordinates
        const visibleLeft = -halfWidth / scale;
        const visibleRight = halfWidth / scale;
        const visibleTop = -halfHeight / scale;
        const visibleBottom = halfHeight / scale;
        const sz = 2; // Grid point size
        // Draw grid within visible bounds
        for (let i = Math.floor(visibleLeft / gridSize) * gridSize; i <= visibleRight; i += gridSize) {
            for (let j = Math.floor(visibleTop / gridSize) * gridSize; j <= visibleBottom; j += gridSize) {
                const rect = new Rect(i - sz / 2, j - sz / 2, sz, sz);
                this.graphics.fillRect(rect, settings.colors.gridPoint);
            }
        }
    }
    updateCanvasSize() {
        // Get the canvas container dimensions instead of full window
        const canvasContainer = this.canvas.parentElement;
        if (!canvasContainer)
            return;
        const containerRect = canvasContainer.getBoundingClientRect();
        const targetWidth = Math.max(containerRect.width, 600);
        const targetHeight = Math.max(containerRect.height, 400);
        const currentWidth = this.canvas.width;
        const currentHeight = this.canvas.height;
        if (currentWidth !== targetWidth || currentHeight !== targetHeight) {
            // Set the canvas dimensions to fit the container
            this.canvas.width = targetWidth;
            this.canvas.height = targetHeight;
            // Set CSS dimensions to fill the container
            this.canvas.style.width = '100%';
            this.canvas.style.height = '100%';
            // Ensure canvas is positioned correctly within its container
            this.canvas.style.position = 'relative';
            this.canvas.style.display = 'block';
            // Update zoomer's screen center when canvas size changes (only if zoomer exists and is initialized)
            if (this.zoomer && this.zoomer.screenCenter) {
                this.zoomer.screenCenter = new Point(targetWidth / 2, targetHeight / 2);
                this.zoomer.center = new Point(targetWidth / 2, targetHeight / 2);
            }
            // Force a repaint
            this.ctx.fillStyle = '#000000';
            this.ctx.fillRect(0, 0, 1, 1);
            this.ctx.clearRect(0, 0, 1, 1);
        }
    }
    unbindAllTools() {
        console.log('🔧 [TOOLS DEBUG] unbindAllTools() called');
        const tools = [
            this.toolRoadbuilder,
            this.toolIntersectionBuilder,
            this.toolHighlighter,
            this.toolIntersectionMover,
            this.toolMover
        ];
        tools.forEach((tool) => {
            if (tool && tool.isBound) {
                try {
                    console.log('🔧 [TOOLS DEBUG] Unbinding tool:', tool.constructor.name);
                    tool.unbind();
                }
                catch (error) {
                    console.error('🔧 [TOOLS ERROR] Failed to unbind tool:', error);
                }
            }
        });
        console.log('🔧 [TOOLS DEBUG] unbindAllTools() completed');
    }
    resetToolStates() {
        console.log('🔧 [TOOLS DEBUG] resetToolStates() called');
        const tools = [
            this.toolRoadbuilder,
            this.toolIntersectionBuilder,
            this.toolHighlighter,
            this.toolIntersectionMover,
            this.toolMover
        ];
        tools.forEach((tool) => {
            if (tool) {
                try {
                    // Reset highlighter state specifically
                    if (tool.hoveredCell !== undefined) {
                        console.log('🔧 [TOOLS DEBUG] Resetting hoveredCell for tool');
                        tool.hoveredCell = null;
                    }
                    // Reset any other tool-specific state
                    if (typeof tool.reset === 'function') {
                        console.log('🔧 [TOOLS DEBUG] Calling tool.reset() method');
                        tool.reset();
                    }
                }
                catch (error) {
                    console.error('🔧 [TOOLS ERROR] Failed to reset tool state:', error);
                }
            }
        });
        // Clear any intersection colors that might be stuck
        if (this.world && this.world.intersections) {
            const intersections = this.world.intersections.all();
            for (const id in intersections) {
                if (intersections[id]) {
                    intersections[id].color = null;
                }
            }
        }
        console.log('🔧 [TOOLS DEBUG] resetToolStates() completed');
    }
    ensureToolsAreBound() {
        console.log('🔧 [TOOLS DEBUG] ensureToolsAreBound() called');
        // Clear any existing tool check intervals first
        if (this.toolCheckInterval !== null) {
            clearInterval(this.toolCheckInterval);
            this.toolCheckInterval = null;
        }
        const tools = [
            this.toolRoadbuilder,
            this.toolIntersectionBuilder,
            this.toolHighlighter,
            this.toolIntersectionMover,
            this.toolMover
        ];
        // Properly unbind all tools first to ensure clean state
        tools.forEach((tool) => {
            if (tool && tool.isBound) {
                try {
                    console.log('🔧 [TOOLS DEBUG] Unbinding tool to rebind:', tool.constructor.name);
                    tool.unbind();
                }
                catch (error) {
                    console.error('🔧 [TOOLS ERROR] Failed to unbind tool:', error);
                }
            }
        });
        // Now bind all tools
        tools.forEach((tool) => {
            if (tool) {
                try {
                    console.log('🔧 [TOOLS DEBUG] Binding tool:', tool.constructor.name);
                    tool.bind();
                }
                catch (error) {
                    console.error('🔧 [TOOLS ERROR] Failed to bind tool:', error);
                }
            }
        });
        console.log('🔧 [TOOLS DEBUG] ensureToolsAreBound() completed');
    }
    get running() {
        return this._running;
    }
    set running(running) {
        if (running) {
            this.start();
        }
        else {
            this.stop();
        }
    }
    start() {
        if (!this._running) {
            this._running = true;
            this.draw(0);
        }
    }
    stop() {
        this._running = false;
    }
    // Method to force a single frame draw without starting animation loop
    drawSingleFrame() {
        console.log('🎨 [VIZ DEBUG] drawSingleFrame() called');
        try {
            // Force a complete redraw by calling draw with current time
            const currentTime = performance.now();
            this.previousTime = currentTime - 33; // ~30fps timing for smooth single frame
            // Store current running state
            const wasRunning = this.running;
            // Temporarily disable running flag to prevent animation loop
            this._running = false;
            // Ensure transformation is reset
            if (this.ctx.resetTransform) {
                this.ctx.resetTransform();
            }
            else {
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
            }
            // Clear with proper background to ensure no black canvas
            this.graphics.clear(settings.colors.background);
            // Draw the frame with a larger delta to ensure all elements are drawn
            this.draw(currentTime);
            // If the canvas is still black or appears incorrect, force another full redraw
            setTimeout(() => {
                if (this.ctx && this.canvas) {
                    // Check a pixel to see if it's black (this is a heuristic)
                    const pixelData = this.ctx.getImageData(this.canvas.width / 2, this.canvas.height / 2, 1, 1).data;
                    const isBlack = pixelData[0] < 20 && pixelData[1] < 20 && pixelData[2] < 20;
                    if (isBlack) {
                        console.log('🎨 [VIZ DEBUG] Canvas appears black, forcing another redraw');
                        // Force a complete redraw cycle
                        if (this.ctx.resetTransform) {
                            this.ctx.resetTransform();
                        }
                        else {
                            this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                        }
                        this.graphics.clear(settings.colors.background);
                        this.draw(performance.now());
                    }
                }
                // Restore original running state
                this._running = wasRunning;
                // If it was running, ensure animation loop continues
                if (wasRunning) {
                    window.requestAnimationFrame(this.draw);
                }
            }, 50);
        }
        catch (error) {
            console.error('🎨 [VIZ ERROR] drawSingleFrame failed:', error);
            // Recovery attempt - reset running state
            this._running = false;
            // Try a simple redraw to recover
            try {
                this.ctx.resetTransform();
                this.graphics.clear(settings.colors.background);
            }
            catch (e) {
                console.error('🎨 [VIZ ERROR] Recovery failed:', e);
            }
        }
    }
    // Method to force canvas refresh after state changes
    forceRefresh() {
        console.log('🎨 [VIZ DEBUG] forceRefresh() called');
        try {
            // Safety check - don't proceed if critical components are missing
            if (!this.canvas || !this.ctx || !this.graphics) {
                console.error('🎨 [VIZ ERROR] Missing required objects for refresh');
                return;
            }
            // Store current state
            const wasRunning = this._running;
            // First, stop any running animation
            if (wasRunning) {
                this._running = false;
            }
            // Force transformation reset
            if (this.ctx.resetTransform) {
                this.ctx.resetTransform();
            }
            else {
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
            }
            // Clear with proper background - use a known good color
            this.ctx.fillStyle = settings.colors.background;
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            // Then use the graphics method for proper clearing
            this.graphics.clear(settings.colors.background);
            // Ensure the world state is valid - check for cars, roads, and intersections
            if (this.world) {
                // Make sure pools are accessible
                if (!this.world.cars || !this.world.cars.all) {
                    console.warn('🎨 [VIZ WARN] Cars pool missing or invalid - recreating');
                    this.world.cars = this.world.cars || new Pool(Car);
                }
                if (!this.world.roads || !this.world.roads.all) {
                    console.warn('🎨 [VIZ WARN] Roads pool missing or invalid - recreating');
                    this.world.roads = this.world.roads || new Pool(Road);
                }
                if (!this.world.intersections || !this.world.intersections.all) {
                    console.warn('🎨 [VIZ WARN] Intersections pool missing or invalid - recreating');
                    this.world.intersections = this.world.intersections || new Pool(Intersection);
                }
            }
            // Reset and rebind tools to ensure clean state
            this.unbindAllTools();
            this.resetToolStates();
            // Wait briefly to ensure all DOM operations complete
            setTimeout(() => {
                try {
                    // Rebind all tools
                    this.ensureToolsAreBound();
                    // Draw a single frame first to ensure canvas is rendered
                    this.drawSingleFrame();
                    // After the single frame draw, if we should be running
                    // wait a bit then restore animation state
                    if (wasRunning) {
                        setTimeout(() => {
                            this._running = true;
                            window.requestAnimationFrame(this.draw);
                            console.log('🎨 [VIZ DEBUG] Animation loop restarted');
                        }, 100);
                    }
                    console.log('🎨 [VIZ DEBUG] forceRefresh() completed successfully');
                }
                catch (innerError) {
                    console.error('🎨 [VIZ ERROR] Inner forceRefresh operation failed:', innerError);
                }
            }, 100);
        }
        catch (error) {
            console.error('🎨 [VIZ ERROR] forceRefresh failed:', error);
            // Emergency recovery
            try {
                if (this.ctx && this.graphics) {
                    this.ctx.resetTransform();
                    this.graphics.clear('#333333'); // Use a different color to show recovery
                }
            }
            catch (e) {
                console.error('🎨 [VIZ ERROR] Emergency recovery failed:', e);
            }
        }
    }
    // Debug method to check world state
    debugWorldState() {
        var _a, _b, _c, _d, _e, _f;
        console.log('🔍 DEBUG: World State Check:');
        console.log('  - World exists:', !!this.world);
        console.log('  - Intersections pool:', !!((_a = this.world) === null || _a === void 0 ? void 0 : _a.intersections));
        console.log('  - Roads pool:', !!((_b = this.world) === null || _b === void 0 ? void 0 : _b.roads));
        console.log('  - Cars pool:', !!((_c = this.world) === null || _c === void 0 ? void 0 : _c.cars));
        if ((_d = this.world) === null || _d === void 0 ? void 0 : _d.intersections) {
            const intersections = this.world.intersections.all();
            console.log('  - Intersections count:', Object.keys(intersections || {}).length);
            if (Object.keys(intersections || {}).length > 0) {
                console.log('  - First intersection:', Object.values(intersections || {})[0]);
            }
        }
        if ((_e = this.world) === null || _e === void 0 ? void 0 : _e.roads) {
            const roads = this.world.roads.all();
            console.log('  - Roads count:', Object.keys(roads || {}).length);
            if (Object.keys(roads || {}).length > 0) {
                console.log('  - First road:', Object.values(roads || {})[0]);
            }
        }
        if ((_f = this.world) === null || _f === void 0 ? void 0 : _f.cars) {
            const cars = this.world.cars.all();
            console.log('  - Cars count:', Object.keys(cars || {}).length);
        }
    }
    // Cleanup method to prevent memory leaks
    destroy() {
        // Stop any running animation
        this.stop();
        // Clear tool check interval
        if (this.toolCheckInterval) {
            clearInterval(this.toolCheckInterval);
            this.toolCheckInterval = null;
        }
        // Unbind tools
        const tools = [
            this.toolRoadbuilder,
            this.toolIntersectionBuilder,
            this.toolHighlighter,
            this.toolIntersectionMover,
            this.toolMover
        ];
        tools.forEach(tool => {
            if (tool && tool.unbind) {
                tool.unbind();
            }
        });
    }
    // DEBUG: Simple canvas test method (removed to prevent red background flash)
    // testCanvasRendering(): void {
    //   console.log('🧪 Testing basic canvas rendering...');
    //   
    //   // Clear any existing transforms
    //   this.ctx.resetTransform();
    //   
    //   // Clear canvas with solid color
    //   this.ctx.fillStyle = '#ff0000';
    //   this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    //   
    //   // Draw test shapes at screen coordinates
    //   this.ctx.fillStyle = '#00ff00';
    //   this.ctx.fillRect(50, 50, 200, 100);
    //   
    //   this.ctx.fillStyle = '#0000ff';
    //   this.ctx.fillRect(300, 200, 150, 100);
    //   
    //   // Draw large visible text
    //   this.ctx.fillStyle = '#ffffff';
    //   this.ctx.font = 'bold 30px Arial';
    //   this.ctx.fillText('CANVAS TEST OK!', 50, 150);
    //   
    //   this.ctx.font = 'bold 20px Arial';
    //   this.ctx.fillText('Canvas size: ' + this.canvas.width + 'x' + this.canvas.height, 50, 180);
    //   
    //   console.log('🧪 Basic canvas test completed - should be RED with GREEN/BLUE boxes');
    // }
    // Method to set the time factor (simulation speed)
    setTimeFactor(factor) {
        if (typeof factor !== 'number' || isNaN(factor)) {
            console.error('Invalid time factor:', factor);
            return;
        }
        console.log('Setting time factor to:', factor);
        this.timeFactor = Math.max(0.1, Math.min(5.0, factor)); // Clamp between 0.1 and 5.0
    }
}
module.exports = Visualizer;


/***/ }),

/***/ "./src/visualizer/zoomer.ts":
/*!**********************************!*\
  !*** ./src/visualizer/zoomer.ts ***!
  \**********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! ../helpers */ "./src/helpers.ts");
const $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
__webpack_require__(/*! jquery-mousewheel */ "./node_modules/jquery-mousewheel/jquery.mousewheel.js");
const Point = __webpack_require__(/*! ../geom/point */ "./src/geom/point.ts");
const Rect = __webpack_require__(/*! ../geom/rect */ "./src/geom/rect.ts");
const settings = __webpack_require__(/*! ../settings */ "./src/settings.ts");
const { min, max } = Math;
class Zoomer {
    constructor(defaultZoom, visualizer, autobind) {
        this.defaultZoom = defaultZoom;
        this.visualizer = visualizer;
        this.ctx = this.visualizer.ctx;
        this.canvas = this.ctx.canvas;
        this._scale = 1;
        // Get canvas dimensions, with fallbacks
        const width = this.canvas.width || 800;
        const height = this.canvas.height || 600;
        this.screenCenter = new Point(width / 2, height / 2);
        this.center = new Point(width / 2, height / 2);
        // Bind mousewheel event for zooming
        if (autobind) {
            $(this.canvas).on('mousewheel DOMMouseScroll wheel', this.mousewheel.bind(this));
        }
    }
    get scale() {
        return this._scale;
    }
    set scale(scale) {
        this.zoom(scale, this.screenCenter);
    }
    toCellCoords(point) {
        const gridSize = settings.gridSize;
        const centerOffset = point.subtract(this.center).divide(this.scale).divide(this.defaultZoom);
        const x = Math.floor(centerOffset.x / gridSize) * gridSize;
        const y = Math.floor(centerOffset.y / gridSize) * gridSize;
        return new Rect(x, y, gridSize, gridSize);
    }
    getBoundingBox(cell1, cell2) {
        cell1 = cell1 || this.toCellCoords(new Point(0, 0));
        cell2 = cell2 || this.toCellCoords(new Point(this.canvas.width, this.canvas.height));
        const xMin = min(cell1.left(), cell2.left());
        const xMax = max(cell1.right(), cell2.right());
        const yMin = min(cell1.top(), cell2.top());
        const yMax = max(cell1.bottom(), cell2.bottom());
        return new Rect(xMin, yMin, xMax - xMin, yMax - yMin);
    }
    transform() {
        // Ensure we have valid center coordinates
        if (!this.center) {
            this.center = new Point(this.canvas.width / 2, this.canvas.height / 2);
        }
        // Apply translation to center
        this.ctx.translate(this.center.x, this.center.y);
        // Apply scaling
        const k = this.scale * this.defaultZoom;
        this.ctx.scale(k, k);
    }
    zoom(k, zoomCenter) {
        k = k || 1;
        if (zoomCenter) {
            const offset = this.center.subtract(zoomCenter);
            this.center = zoomCenter.add(offset.mult(k / this._scale));
        }
        this._scale = k;
    }
    moveCenter(offset) {
        this.center = this.center.add(offset);
    }
    mousewheel(e) {
        // Reduced logging to prevent console spam
        // console.log('🔷 Zoomer mousewheel event detected:', e.type, 'deltaY:', e.deltaY, 'wheelDelta:', e.originalEvent?.wheelDelta);
        e.preventDefault();
        const originalEvent = e.originalEvent || e;
        let deltaY = originalEvent.deltaY || -e.deltaY || e.detail || 0;
        // Handle different wheel event formats
        if (originalEvent.wheelDelta) {
            deltaY = -originalEvent.wheelDelta;
        }
        // Normalize wheel delta
        if (originalEvent.deltaMode === 1) { // DOM_DELTA_LINE
            deltaY *= 40;
        }
        else if (originalEvent.deltaMode === 2) { // DOM_DELTA_PAGE
            deltaY *= 800;
        }
        const zoomFactor = Math.pow(2, -0.001 * deltaY);
        const newScale = this.scale * zoomFactor;
        // console.log('🔷 Zoom calculation: deltaY=', deltaY, 'zoomFactor=', zoomFactor, 'newScale=', newScale);
        // Constrain zoom levels
        if (newScale > 0.05 && newScale < 5) {
            const rect = this.canvas.getBoundingClientRect();
            const mousePoint = new Point(e.clientX - rect.left, e.clientY - rect.top);
            // console.log('🔷 Applying zoom at point:', mousePoint.x, mousePoint.y);
            this.zoom(newScale, mousePoint);
        }
        else {
            // console.log('🔷 Zoom level constrained:', newScale);
        }
    }
}
module.exports = Zoomer;


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = __webpack_module_cache__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module cache are used so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	var __webpack_exports__ = __webpack_require__(__webpack_require__.s = "./src/app.ts");
/******/ 	
/******/ })()
;
//# sourceMappingURL=main.js.map